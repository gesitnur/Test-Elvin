{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nconst indexedDB = typeof window !== 'undefined' && (window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB);\nconst isSupported = !!indexedDB;\nconst DB_NAME = 'uppy-blobs';\nconst STORE_NAME = 'files'; // maybe have a thumbnail store in the future\n\nconst DEFAULT_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours\n\nconst DB_VERSION = 3; // Set default `expires` dates on existing stored blobs.\n\nfunction migrateExpiration(store) {\n  const request = store.openCursor();\n  request.onsuccess = event => {\n    const cursor = event.target.result;\n    if (!cursor) {\n      return;\n    }\n    const entry = cursor.value;\n    entry.expires = Date.now() + DEFAULT_EXPIRY;\n    cursor.update(entry);\n  };\n}\nfunction connect(dbName) {\n  const request = indexedDB.open(dbName, DB_VERSION);\n  return new Promise((resolve, reject) => {\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n      const transaction = event.currentTarget.transaction;\n      if (event.oldVersion < 2) {\n        // Added in v2: DB structure changed to a single shared object store\n        const store = db.createObjectStore(STORE_NAME, {\n          keyPath: 'id'\n        });\n        store.createIndex('store', 'store', {\n          unique: false\n        });\n      }\n      if (event.oldVersion < 3) {\n        // Added in v3\n        const store = transaction.objectStore(STORE_NAME);\n        store.createIndex('expires', 'expires', {\n          unique: false\n        });\n        migrateExpiration(store);\n      }\n      transaction.oncomplete = () => {\n        resolve(db);\n      };\n    };\n    request.onsuccess = event => {\n      resolve(event.target.result);\n    };\n    request.onerror = reject;\n  });\n}\nfunction waitForRequest(request) {\n  return new Promise((resolve, reject) => {\n    request.onsuccess = event => {\n      resolve(event.target.result);\n    };\n    request.onerror = reject;\n  });\n}\nlet cleanedUp = false;\nclass IndexedDBStore {\n  constructor(opts) {\n    this.opts = _objectSpread({\n      dbName: DB_NAME,\n      storeName: 'default',\n      expires: DEFAULT_EXPIRY,\n      // 24 hours\n      maxFileSize: 10 * 1024 * 1024,\n      // 10 MB\n      maxTotalSize: 300 * 1024 * 1024\n    }, opts);\n    this.name = this.opts.storeName;\n    const createConnection = () => {\n      return connect(this.opts.dbName);\n    };\n    if (!cleanedUp) {\n      cleanedUp = true;\n      this.ready = IndexedDBStore.cleanup().then(createConnection, createConnection);\n    } else {\n      this.ready = createConnection();\n    }\n  }\n  key(fileID) {\n    return `${this.name}!${fileID}`;\n  }\n  /**\n   * List all file blobs currently in the store.\n   */\n\n  list() {\n    return this.ready.then(db => {\n      const transaction = db.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      const request = store.index('store').getAll(IDBKeyRange.only(this.name));\n      return waitForRequest(request);\n    }).then(files => {\n      const result = {};\n      files.forEach(file => {\n        result[file.fileID] = file.data;\n      });\n      return result;\n    });\n  }\n  /**\n   * Get one file blob from the store.\n   */\n\n  get(fileID) {\n    return this.ready.then(db => {\n      const transaction = db.transaction([STORE_NAME], 'readonly');\n      const request = transaction.objectStore(STORE_NAME).get(this.key(fileID));\n      return waitForRequest(request);\n    }).then(result => ({\n      id: result.data.fileID,\n      data: result.data.data\n    }));\n  }\n  /**\n   * Get the total size of all stored files.\n   *\n   * @private\n   */\n\n  getSize() {\n    return this.ready.then(db => {\n      const transaction = db.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      const request = store.index('store').openCursor(IDBKeyRange.only(this.name));\n      return new Promise((resolve, reject) => {\n        let size = 0;\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            size += cursor.value.data.size;\n            cursor.continue();\n          } else {\n            resolve(size);\n          }\n        };\n        request.onerror = () => {\n          reject(new Error('Could not retrieve stored blobs size'));\n        };\n      });\n    });\n  }\n  /**\n   * Save a file in the store.\n   */\n\n  put(file) {\n    if (file.data.size > this.opts.maxFileSize) {\n      return Promise.reject(new Error('File is too big to store.'));\n    }\n    return this.getSize().then(size => {\n      if (size > this.opts.maxTotalSize) {\n        return Promise.reject(new Error('No space left'));\n      }\n      return this.ready;\n    }).then(db => {\n      const transaction = db.transaction([STORE_NAME], 'readwrite');\n      const request = transaction.objectStore(STORE_NAME).add({\n        id: this.key(file.id),\n        fileID: file.id,\n        store: this.name,\n        expires: Date.now() + this.opts.expires,\n        data: file.data\n      });\n      return waitForRequest(request);\n    });\n  }\n  /**\n   * Delete a file blob from the store.\n   */\n\n  delete(fileID) {\n    return this.ready.then(db => {\n      const transaction = db.transaction([STORE_NAME], 'readwrite');\n      const request = transaction.objectStore(STORE_NAME).delete(this.key(fileID));\n      return waitForRequest(request);\n    });\n  }\n  /**\n   * Delete all stored blobs that have an expiry date that is before Date.now().\n   * This is a static method because it deletes expired blobs from _all_ Uppy instances.\n   */\n\n  static cleanup() {\n    return connect(DB_NAME).then(db => {\n      const transaction = db.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      const request = store.index('expires').openCursor(IDBKeyRange.upperBound(Date.now()));\n      return new Promise((resolve, reject) => {\n        request.onsuccess = event => {\n          const cursor = event.target.result;\n          if (cursor) {\n            cursor.delete(); // Ignoring return value â€¦ it's not terrible if this goes wrong.\n\n            cursor.continue();\n          } else {\n            resolve(db);\n          }\n        };\n        request.onerror = reject;\n      });\n    }).then(db => {\n      db.close();\n    });\n  }\n}\nIndexedDBStore.isSupported = isSupported;\nexport default IndexedDBStore;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}