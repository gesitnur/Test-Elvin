{"ast":null,"code":"var _class, _temp;\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar _require = require('preact'),\n  h = _require.h;\nvar AuthView = require('./AuthView');\nvar Header = require('./Header');\nvar Browser = require('../Browser');\nvar LoaderView = require('../Loader');\nvar generateFileID = require('@uppy/utils/lib/generateFileID');\nvar getFileType = require('@uppy/utils/lib/getFileType');\nvar findIndex = require('@uppy/utils/lib/findIndex');\nvar isPreviewSupported = require('@uppy/utils/lib/isPreviewSupported');\nvar SharedHandler = require('../SharedHandler');\nvar CloseWrapper = require('../CloseWrapper'); // location.origin does not exist in IE\n\nfunction getOrigin() {\n  if ('origin' in location) {\n    return location.origin; // eslint-disable-line compat/compat\n  }\n\n  return location.protocol + \"//\" + location.hostname + (location.port ? \":\" + location.port : '');\n}\n/**\n * Class to easily generate generic views for Provider plugins\n */\n\nmodule.exports = (_temp = _class = /*#__PURE__*/function () {\n  /**\n   * @param {object} plugin instance of the plugin\n   * @param {object} opts\n   */\n  function ProviderView(plugin, opts) {\n    this.plugin = plugin;\n    this.provider = opts.provider;\n    this._sharedHandler = new SharedHandler(plugin); // set default options\n\n    var defaultOptions = {\n      viewType: 'list',\n      showTitles: true,\n      showFilter: true,\n      showBreadcrumbs: true\n    }; // merge default options with the ones set by user\n\n    this.opts = _extends({}, defaultOptions, opts); // Logic\n\n    this.addFile = this.addFile.bind(this);\n    this.filterQuery = this.filterQuery.bind(this);\n    this.getFolder = this.getFolder.bind(this);\n    this.getNextFolder = this.getNextFolder.bind(this);\n    this.logout = this.logout.bind(this);\n    this.preFirstRender = this.preFirstRender.bind(this);\n    this.handleAuth = this.handleAuth.bind(this);\n    this.sortByTitle = this.sortByTitle.bind(this);\n    this.sortByDate = this.sortByDate.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n    this.listAllFiles = this.listAllFiles.bind(this);\n    this.donePicking = this.donePicking.bind(this);\n    this.cancelPicking = this.cancelPicking.bind(this);\n    this.clearSelection = this.clearSelection.bind(this); // Visual\n\n    this.render = this.render.bind(this);\n    this.clearSelection(); // Set default state for the plugin\n\n    this.plugin.setPluginState({\n      authenticated: false,\n      files: [],\n      folders: [],\n      directories: [],\n      filterInput: '',\n      isSearchVisible: false\n    });\n  }\n  var _proto = ProviderView.prototype;\n  _proto.tearDown = function tearDown() {// Nothing.\n  };\n  _proto._updateFilesAndFolders = function _updateFilesAndFolders(res, files, folders) {\n    this.nextPagePath = res.nextPagePath;\n    res.items.forEach(function (item) {\n      if (item.isFolder) {\n        folders.push(item);\n      } else {\n        files.push(item);\n      }\n    });\n    this.plugin.setPluginState({\n      folders: folders,\n      files: files\n    });\n  }\n  /**\n   * Called only the first time the provider view is rendered.\n   * Kind of like an init function.\n   */;\n\n  _proto.preFirstRender = function preFirstRender() {\n    this.plugin.setPluginState({\n      didFirstRender: true\n    });\n    this.plugin.onFirstRender();\n  }\n  /**\n   * Based on folder ID, fetch a new folder and update it to state\n   *\n   * @param  {string} id Folder id\n   * @returns {Promise}   Folders/files in folder\n   */;\n\n  _proto.getFolder = function getFolder(id, name) {\n    var _this = this;\n    return this._sharedHandler.loaderWrapper(this.provider.list(id), function (res) {\n      var folders = [];\n      var files = [];\n      var updatedDirectories;\n      var state = _this.plugin.getPluginState();\n      var index = findIndex(state.directories, function (dir) {\n        return id === dir.id;\n      });\n      if (index !== -1) {\n        updatedDirectories = state.directories.slice(0, index + 1);\n      } else {\n        updatedDirectories = state.directories.concat([{\n          id: id,\n          title: name\n        }]);\n      }\n      _this.username = res.username || _this.username;\n      _this._updateFilesAndFolders(res, files, folders);\n      _this.plugin.setPluginState({\n        directories: updatedDirectories\n      });\n    }, this.handleError);\n  }\n  /**\n   * Fetches new folder\n   *\n   * @param  {object} folder\n   */;\n\n  _proto.getNextFolder = function getNextFolder(folder) {\n    this.getFolder(folder.requestPath, folder.name);\n    this.lastCheckbox = undefined;\n  };\n  _proto.addFile = function addFile(file) {\n    var tagFile = {\n      id: this.providerFileToId(file),\n      source: this.plugin.id,\n      data: file,\n      name: file.name || file.id,\n      type: file.mimeType,\n      isRemote: true,\n      body: {\n        fileId: file.id\n      },\n      remote: {\n        companionUrl: this.plugin.opts.companionUrl,\n        url: \"\" + this.provider.fileUrl(file.requestPath),\n        body: {\n          fileId: file.id\n        },\n        providerOptions: this.provider.opts\n      }\n    };\n    var fileType = getFileType(tagFile); // TODO Should we just always use the thumbnail URL if it exists?\n\n    if (fileType && isPreviewSupported(fileType)) {\n      tagFile.preview = file.thumbnail;\n    }\n    this.plugin.uppy.log('Adding remote file');\n    try {\n      this.plugin.uppy.addFile(tagFile);\n      return true;\n    } catch (err) {\n      if (!err.isRestriction) {\n        this.plugin.uppy.log(err);\n      }\n      return false;\n    }\n  }\n  /**\n   * Removes session token on client side.\n   */;\n\n  _proto.logout = function logout() {\n    var _this2 = this;\n    this.provider.logout().then(function (res) {\n      if (res.ok) {\n        if (!res.revoked) {\n          var message = _this2.plugin.uppy.i18n('companionUnauthorizeHint', {\n            provider: _this2.plugin.title,\n            url: res.manual_revoke_url\n          });\n          _this2.plugin.uppy.info(message, 'info', 7000);\n        }\n        var newState = {\n          authenticated: false,\n          files: [],\n          folders: [],\n          directories: []\n        };\n        _this2.plugin.setPluginState(newState);\n      }\n    }).catch(this.handleError);\n  };\n  _proto.filterQuery = function filterQuery(e) {\n    var state = this.plugin.getPluginState();\n    this.plugin.setPluginState(_extends({}, state, {\n      filterInput: e ? e.target.value : ''\n    }));\n  };\n  _proto.sortByTitle = function sortByTitle() {\n    var state = _extends({}, this.plugin.getPluginState());\n    var files = state.files,\n      folders = state.folders,\n      sorting = state.sorting;\n    var sortedFiles = files.sort(function (fileA, fileB) {\n      if (sorting === 'titleDescending') {\n        return fileB.name.localeCompare(fileA.name);\n      }\n      return fileA.name.localeCompare(fileB.name);\n    });\n    var sortedFolders = folders.sort(function (folderA, folderB) {\n      if (sorting === 'titleDescending') {\n        return folderB.name.localeCompare(folderA.name);\n      }\n      return folderA.name.localeCompare(folderB.name);\n    });\n    this.plugin.setPluginState(_extends({}, state, {\n      files: sortedFiles,\n      folders: sortedFolders,\n      sorting: sorting === 'titleDescending' ? 'titleAscending' : 'titleDescending'\n    }));\n  };\n  _proto.sortByDate = function sortByDate() {\n    var state = _extends({}, this.plugin.getPluginState());\n    var files = state.files,\n      folders = state.folders,\n      sorting = state.sorting;\n    var sortedFiles = files.sort(function (fileA, fileB) {\n      var a = new Date(fileA.modifiedDate);\n      var b = new Date(fileB.modifiedDate);\n      if (sorting === 'dateDescending') {\n        return a > b ? -1 : a < b ? 1 : 0;\n      }\n      return a > b ? 1 : a < b ? -1 : 0;\n    });\n    var sortedFolders = folders.sort(function (folderA, folderB) {\n      var a = new Date(folderA.modifiedDate);\n      var b = new Date(folderB.modifiedDate);\n      if (sorting === 'dateDescending') {\n        return a > b ? -1 : a < b ? 1 : 0;\n      }\n      return a > b ? 1 : a < b ? -1 : 0;\n    });\n    this.plugin.setPluginState(_extends({}, state, {\n      files: sortedFiles,\n      folders: sortedFolders,\n      sorting: sorting === 'dateDescending' ? 'dateAscending' : 'dateDescending'\n    }));\n  };\n  _proto.sortBySize = function sortBySize() {\n    var state = _extends({}, this.plugin.getPluginState());\n    var files = state.files,\n      sorting = state.sorting; // check that plugin supports file sizes\n\n    if (!files.length || !this.plugin.getItemData(files[0]).size) {\n      return;\n    }\n    var sortedFiles = files.sort(function (fileA, fileB) {\n      var a = fileA.size;\n      var b = fileB.size;\n      if (sorting === 'sizeDescending') {\n        return a > b ? -1 : a < b ? 1 : 0;\n      }\n      return a > b ? 1 : a < b ? -1 : 0;\n    });\n    this.plugin.setPluginState(_extends({}, state, {\n      files: sortedFiles,\n      sorting: sorting === 'sizeDescending' ? 'sizeAscending' : 'sizeDescending'\n    }));\n  }\n  /**\n   * Adds all files found inside of specified folder.\n   *\n   * Uses separated state while folder contents are being fetched and\n   * mantains list of selected folders, which are separated from files.\n   */;\n\n  _proto.addFolder = function addFolder(folder) {\n    var _this3 = this;\n    var folderId = this.providerFileToId(folder);\n    var state = this.plugin.getPluginState();\n    var folders = _extends({}, state.selectedFolders);\n    if (folderId in folders && folders[folderId].loading) {\n      return;\n    }\n    folders[folderId] = {\n      loading: true,\n      files: []\n    };\n    this.plugin.setPluginState({\n      selectedFolders: _extends({}, folders)\n    });\n    return this.listAllFiles(folder.requestPath).then(function (files) {\n      var count = 0;\n      files.forEach(function (file) {\n        var success = _this3.addFile(file);\n        if (success) count++;\n      });\n      var ids = files.map(_this3.providerFileToId);\n      folders[folderId] = {\n        loading: false,\n        files: ids\n      };\n      _this3.plugin.setPluginState({\n        selectedFolders: folders\n      });\n      var message;\n      if (files.length) {\n        message = _this3.plugin.uppy.i18n('folderAdded', {\n          smart_count: count,\n          folder: folder.name\n        });\n      } else {\n        message = _this3.plugin.uppy.i18n('emptyFolderAdded');\n      }\n      _this3.plugin.uppy.info(message);\n    }).catch(function (e) {\n      var state = _this3.plugin.getPluginState();\n      var selectedFolders = _extends({}, state.selectedFolders);\n      delete selectedFolders[folderId];\n      _this3.plugin.setPluginState({\n        selectedFolders: selectedFolders\n      });\n      _this3.handleError(e);\n    });\n  };\n  _proto.providerFileToId = function providerFileToId(file) {\n    return generateFileID({\n      data: file,\n      name: file.name || file.id,\n      type: file.mimeType\n    });\n  };\n  _proto.handleAuth = function handleAuth() {\n    var _this4 = this;\n    var authState = btoa(JSON.stringify({\n      origin: getOrigin()\n    }));\n    var clientVersion = \"@uppy/provider-views=\" + ProviderView.VERSION;\n    var link = this.provider.authUrl({\n      state: authState,\n      uppyVersions: clientVersion\n    });\n    var authWindow = window.open(link, '_blank');\n    var handleToken = function handleToken(e) {\n      if (!_this4._isOriginAllowed(e.origin, _this4.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {\n        _this4.plugin.uppy.log(\"rejecting event from \" + e.origin + \" vs allowed pattern \" + _this4.plugin.opts.companionAllowedHosts);\n        return;\n      } // Check if it's a string before doing the JSON.parse to maintain support\n      // for older Companion versions that used object references\n\n      var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;\n      if (!data.token) {\n        _this4.plugin.uppy.log('did not receive token from auth window');\n        return;\n      }\n      authWindow.close();\n      window.removeEventListener('message', handleToken);\n      _this4.provider.setAuthToken(data.token);\n      _this4.preFirstRender();\n    };\n    window.addEventListener('message', handleToken);\n  };\n  _proto._isOriginAllowed = function _isOriginAllowed(origin, allowedOrigin) {\n    var getRegex = function getRegex(value) {\n      if (typeof value === 'string') {\n        return new RegExp(\"^\" + value + \"$\");\n      }\n      if (value instanceof RegExp) {\n        return value;\n      }\n    };\n    var patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];\n    return patterns.filter(function (pattern) {\n      return pattern != null;\n    }) // loose comparison to catch undefined\n    .some(function (pattern) {\n      return pattern.test(origin) || pattern.test(origin + \"/\");\n    }); // allowing for trailing '/'\n  };\n\n  _proto.handleError = function handleError(error) {\n    var uppy = this.plugin.uppy;\n    uppy.log(error.toString());\n    if (error.isAuthError) {\n      return;\n    }\n    var message = uppy.i18n('companionError');\n    uppy.info({\n      message: message,\n      details: error.toString()\n    }, 'error', 5000);\n  };\n  _proto.handleScroll = function handleScroll(e) {\n    var _this5 = this;\n    var scrollPos = e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight);\n    var path = this.nextPagePath || null;\n    if (scrollPos < 50 && path && !this._isHandlingScroll) {\n      this.provider.list(path).then(function (res) {\n        var _this5$plugin$getPlug = _this5.plugin.getPluginState(),\n          files = _this5$plugin$getPlug.files,\n          folders = _this5$plugin$getPlug.folders;\n        _this5._updateFilesAndFolders(res, files, folders);\n      }).catch(this.handleError).then(function () {\n        _this5._isHandlingScroll = false;\n      }); // always called\n\n      this._isHandlingScroll = true;\n    }\n  };\n  _proto.listAllFiles = function listAllFiles(path, files) {\n    var _this6 = this;\n    if (files === void 0) {\n      files = null;\n    }\n    files = files || [];\n    return new Promise(function (resolve, reject) {\n      _this6.provider.list(path).then(function (res) {\n        res.items.forEach(function (item) {\n          if (!item.isFolder) {\n            files.push(item);\n          } else {\n            _this6.addFolder(item);\n          }\n        });\n        var moreFiles = res.nextPagePath || null;\n        if (moreFiles) {\n          return _this6.listAllFiles(moreFiles, files).then(function (files) {\n            return resolve(files);\n          }).catch(function (e) {\n            return reject(e);\n          });\n        }\n        return resolve(files);\n      }).catch(function (e) {\n        return reject(e);\n      });\n    });\n  };\n  _proto.donePicking = function donePicking() {\n    var _this7 = this;\n    var _this$plugin$getPlugi = this.plugin.getPluginState(),\n      currentSelection = _this$plugin$getPlugi.currentSelection;\n    var promises = currentSelection.map(function (file) {\n      if (file.isFolder) {\n        return _this7.addFolder(file);\n      }\n      return _this7.addFile(file);\n    });\n    this._sharedHandler.loaderWrapper(Promise.all(promises), function () {\n      _this7.clearSelection();\n    }, function () {});\n  };\n  _proto.cancelPicking = function cancelPicking() {\n    this.clearSelection();\n    var dashboard = this.plugin.uppy.getPlugin('Dashboard');\n    if (dashboard) dashboard.hideAllPanels();\n  };\n  _proto.clearSelection = function clearSelection() {\n    this.plugin.setPluginState({\n      currentSelection: []\n    });\n  };\n  _proto.render = function render(state, viewOptions) {\n    if (viewOptions === void 0) {\n      viewOptions = {};\n    }\n    var _this$plugin$getPlugi2 = this.plugin.getPluginState(),\n      authenticated = _this$plugin$getPlugi2.authenticated,\n      didFirstRender = _this$plugin$getPlugi2.didFirstRender;\n    if (!didFirstRender) {\n      this.preFirstRender();\n    } // reload pluginState for \"loading\" attribute because it might\n    // have changed above.\n\n    if (this.plugin.getPluginState().loading) {\n      return h(CloseWrapper, {\n        onUnmount: this.clearSelection\n      }, h(LoaderView, {\n        i18n: this.plugin.uppy.i18n\n      }));\n    }\n    if (!authenticated) {\n      return h(CloseWrapper, {\n        onUnmount: this.clearSelection\n      }, h(AuthView, {\n        pluginName: this.plugin.title,\n        pluginIcon: this.plugin.icon,\n        handleAuth: this.handleAuth,\n        i18n: this.plugin.uppy.i18n,\n        i18nArray: this.plugin.uppy.i18nArray\n      }));\n    }\n    var targetViewOptions = _extends({}, this.opts, viewOptions);\n    var headerProps = {\n      showBreadcrumbs: targetViewOptions.showBreadcrumbs,\n      getFolder: this.getFolder,\n      directories: this.plugin.getPluginState().directories,\n      pluginIcon: this.plugin.icon,\n      title: this.plugin.title,\n      logout: this.logout,\n      username: this.username,\n      i18n: this.plugin.uppy.i18n\n    };\n    var browserProps = _extends({}, this.plugin.getPluginState(), {\n      username: this.username,\n      getNextFolder: this.getNextFolder,\n      getFolder: this.getFolder,\n      filterItems: this._sharedHandler.filterItems,\n      filterQuery: this.filterQuery,\n      sortByTitle: this.sortByTitle,\n      sortByDate: this.sortByDate,\n      logout: this.logout,\n      isChecked: this._sharedHandler.isChecked,\n      toggleCheckbox: this._sharedHandler.toggleCheckbox,\n      handleScroll: this.handleScroll,\n      listAllFiles: this.listAllFiles,\n      done: this.donePicking,\n      cancel: this.cancelPicking,\n      headerComponent: Header(headerProps),\n      title: this.plugin.title,\n      viewType: targetViewOptions.viewType,\n      showTitles: targetViewOptions.showTitles,\n      showFilter: targetViewOptions.showFilter,\n      showBreadcrumbs: targetViewOptions.showBreadcrumbs,\n      pluginIcon: this.plugin.icon,\n      i18n: this.plugin.uppy.i18n,\n      uppyFiles: this.plugin.uppy.getFiles(),\n      validateRestrictions: this.plugin.uppy.validateRestrictions\n    });\n    return h(CloseWrapper, {\n      onUnmount: this.clearSelection\n    }, h(Browser, browserProps));\n  };\n  return ProviderView;\n}(), _class.VERSION = \"1.12.3\", _temp);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}