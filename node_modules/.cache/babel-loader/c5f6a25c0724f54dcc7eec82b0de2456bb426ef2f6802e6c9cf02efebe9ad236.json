{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport throttle from 'lodash.throttle';\nimport BasePlugin from '@uppy/core/lib/BasePlugin.js';\nimport ServiceWorkerStore from './ServiceWorkerStore.js';\nimport IndexedDBStore from './IndexedDBStore.js';\nimport MetaDataStore from './MetaDataStore.js';\nconst packageJson = {\n  \"version\": \"3.0.2\"\n};\n/**\n * The GoldenRetriever plugin — restores selected files and resumes uploads\n * after a closed tab or a browser crash!\n *\n * Uses localStorage, IndexedDB and ServiceWorker to do its magic, read more:\n * https://uppy.io/blog/2017/07/golden-retriever/\n */\n\nexport default class GoldenRetriever extends BasePlugin {\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    this.addBlobToStores = file => {\n      if (file.isRemote) return;\n      if (this.ServiceWorkerStore) {\n        this.ServiceWorkerStore.put(file).catch(err => {\n          this.uppy.log('[GoldenRetriever] Could not store file', 'warning');\n          this.uppy.log(err);\n        });\n      }\n      this.IndexedDBStore.put(file).catch(err => {\n        this.uppy.log('[GoldenRetriever] Could not store file', 'warning');\n        this.uppy.log(err);\n      });\n    };\n    this.removeBlobFromStores = file => {\n      if (this.ServiceWorkerStore) {\n        this.ServiceWorkerStore.delete(file.id).catch(err => {\n          this.uppy.log('[GoldenRetriever] Failed to remove file', 'warning');\n          this.uppy.log(err);\n        });\n      }\n      this.IndexedDBStore.delete(file.id).catch(err => {\n        this.uppy.log('[GoldenRetriever] Failed to remove file', 'warning');\n        this.uppy.log(err);\n      });\n    };\n    this.replaceBlobInStores = file => {\n      this.removeBlobFromStores(file);\n      this.addBlobToStores(file);\n    };\n    this.handleRestoreConfirmed = () => {\n      this.uppy.log('[GoldenRetriever] Restore confirmed, proceeding...'); // start all uploads again when file blobs are restored\n\n      const _this$uppy$getState = this.uppy.getState(),\n        currentUploads = _this$uppy$getState.currentUploads;\n      if (currentUploads) {\n        this.uppy.resumeAll();\n        Object.keys(currentUploads).forEach(uploadId => {\n          this.uppy.restore(uploadId, currentUploads[uploadId]);\n        });\n      }\n      this.uppy.setState({\n        recoveredState: null\n      });\n    };\n    this.abortRestore = () => {\n      this.uppy.log('[GoldenRetriever] Aborting restore...');\n      const fileIDs = Object.keys(this.uppy.getState().files);\n      this.deleteBlobs(fileIDs).then(() => {\n        this.uppy.log(`[GoldenRetriever] Removed ${fileIDs.length} files`);\n      }).catch(err => {\n        this.uppy.log(`[GoldenRetriever] Could not remove ${fileIDs.length} files`, 'warning');\n        this.uppy.log(err);\n      });\n      this.uppy.cancelAll();\n      this.uppy.setState({\n        recoveredState: null\n      });\n      MetaDataStore.cleanup(this.uppy.opts.id);\n    };\n    this.handleComplete = _ref => {\n      let successful = _ref.successful;\n      const fileIDs = successful.map(file => file.id);\n      this.deleteBlobs(fileIDs).then(() => {\n        this.uppy.log(`[GoldenRetriever] Removed ${successful.length} files that finished uploading`);\n      }).catch(err => {\n        this.uppy.log(`[GoldenRetriever] Could not remove ${successful.length} files that finished uploading`, 'warning');\n        this.uppy.log(err);\n      });\n      this.uppy.setState({\n        recoveredState: null\n      });\n      MetaDataStore.cleanup(this.uppy.opts.id);\n    };\n    this.restoreBlobs = () => {\n      if (this.uppy.getFiles().length > 0) {\n        Promise.all([this.loadFileBlobsFromServiceWorker(), this.loadFileBlobsFromIndexedDB()]).then(resultingArrayOfObjects => {\n          const blobs = _objectSpread(_objectSpread({}, resultingArrayOfObjects[0]), resultingArrayOfObjects[1]);\n          this.onBlobsLoaded(blobs);\n        });\n      } else {\n        this.uppy.log('[GoldenRetriever] No files need to be loaded, only restoring processing state...');\n      }\n    };\n    this.type = 'debugger';\n    this.id = this.opts.id || 'GoldenRetriever';\n    this.title = 'Golden Retriever';\n    const defaultOptions = {\n      expires: 24 * 60 * 60 * 1000,\n      // 24 hours\n      serviceWorker: false\n    };\n    this.opts = _objectSpread(_objectSpread({}, defaultOptions), opts);\n    this.MetaDataStore = new MetaDataStore({\n      expires: this.opts.expires,\n      storeName: uppy.getID()\n    });\n    this.ServiceWorkerStore = null;\n    if (this.opts.serviceWorker) {\n      this.ServiceWorkerStore = new ServiceWorkerStore({\n        storeName: uppy.getID()\n      });\n    }\n    this.IndexedDBStore = new IndexedDBStore(_objectSpread(_objectSpread({\n      expires: this.opts.expires\n    }, this.opts.indexedDB || {}), {}, {\n      storeName: uppy.getID()\n    }));\n    this.saveFilesStateToLocalStorage = throttle(this.saveFilesStateToLocalStorage.bind(this), 500, {\n      leading: true,\n      trailing: true\n    });\n    this.restoreState = this.restoreState.bind(this);\n    this.loadFileBlobsFromServiceWorker = this.loadFileBlobsFromServiceWorker.bind(this);\n    this.loadFileBlobsFromIndexedDB = this.loadFileBlobsFromIndexedDB.bind(this);\n    this.onBlobsLoaded = this.onBlobsLoaded.bind(this);\n  }\n  restoreState() {\n    const savedState = this.MetaDataStore.load();\n    if (savedState) {\n      this.uppy.log('[GoldenRetriever] Recovered some state from Local Storage');\n      this.uppy.setState({\n        currentUploads: savedState.currentUploads || {},\n        files: savedState.files || {},\n        recoveredState: savedState\n      });\n      this.savedPluginData = savedState.pluginData;\n    }\n  }\n  /**\n   * Get file objects that are currently waiting: they've been selected,\n   * but aren't yet being uploaded.\n   */\n\n  getWaitingFiles() {\n    const waitingFiles = {};\n    this.uppy.getFiles().forEach(file => {\n      if (!file.progress || !file.progress.uploadStarted) {\n        waitingFiles[file.id] = file;\n      }\n    });\n    return waitingFiles;\n  }\n  /**\n   * Get file objects that are currently being uploaded. If a file has finished\n   * uploading, but the other files in the same batch have not, the finished\n   * file is also returned.\n   */\n\n  getUploadingFiles() {\n    const uploadingFiles = {};\n    const _this$uppy$getState2 = this.uppy.getState(),\n      currentUploads = _this$uppy$getState2.currentUploads;\n    if (currentUploads) {\n      const uploadIDs = Object.keys(currentUploads);\n      uploadIDs.forEach(uploadID => {\n        const filesInUpload = currentUploads[uploadID].fileIDs;\n        filesInUpload.forEach(fileID => {\n          uploadingFiles[fileID] = this.uppy.getFile(fileID);\n        });\n      });\n    }\n    return uploadingFiles;\n  }\n  saveFilesStateToLocalStorage() {\n    const filesToSave = _objectSpread(_objectSpread({}, this.getWaitingFiles()), this.getUploadingFiles()); // If all files have been removed by the user, clear recovery state\n\n    if (Object.keys(filesToSave).length === 0) {\n      if (this.uppy.getState().recoveredState !== null) {\n        this.uppy.setState({\n          recoveredState: null\n        });\n      }\n      MetaDataStore.cleanup(this.uppy.opts.id);\n      return;\n    } // We dont’t need to store file.data on local files, because the actual blob will be restored later,\n    // and we want to avoid having weird properties in the serialized object.\n    // Also adding file.isRestored to all files, since they will be restored from local storage\n\n    const filesToSaveWithoutData = {};\n    Object.keys(filesToSave).forEach(file => {\n      if (filesToSave[file].isRemote) {\n        filesToSaveWithoutData[file] = _objectSpread(_objectSpread({}, filesToSave[file]), {}, {\n          isRestored: true\n        });\n      } else {\n        filesToSaveWithoutData[file] = _objectSpread(_objectSpread({}, filesToSave[file]), {}, {\n          isRestored: true,\n          data: null,\n          preview: null\n        });\n      }\n    });\n    const pluginData = {}; // TODO Find a better way to do this?\n    // Other plugins can attach a restore:get-data listener that receives this callback.\n    // Plugins can then use this callback (sync) to provide data to be stored.\n\n    this.uppy.emit('restore:get-data', data => {\n      Object.assign(pluginData, data);\n    });\n    const _this$uppy$getState3 = this.uppy.getState(),\n      currentUploads = _this$uppy$getState3.currentUploads;\n    this.MetaDataStore.save({\n      currentUploads,\n      files: filesToSaveWithoutData,\n      pluginData\n    });\n  }\n  loadFileBlobsFromServiceWorker() {\n    if (!this.ServiceWorkerStore) {\n      return Promise.resolve({});\n    }\n    return this.ServiceWorkerStore.list().then(blobs => {\n      const numberOfFilesRecovered = Object.keys(blobs).length;\n      if (numberOfFilesRecovered > 0) {\n        this.uppy.log(`[GoldenRetriever] Successfully recovered ${numberOfFilesRecovered} blobs from Service Worker!`);\n        return blobs;\n      }\n      this.uppy.log('[GoldenRetriever] No blobs found in Service Worker, trying IndexedDB now...');\n      return {};\n    }).catch(err => {\n      this.uppy.log('[GoldenRetriever] Failed to recover blobs from Service Worker', 'warning');\n      this.uppy.log(err);\n      return {};\n    });\n  }\n  loadFileBlobsFromIndexedDB() {\n    return this.IndexedDBStore.list().then(blobs => {\n      const numberOfFilesRecovered = Object.keys(blobs).length;\n      if (numberOfFilesRecovered > 0) {\n        this.uppy.log(`[GoldenRetriever] Successfully recovered ${numberOfFilesRecovered} blobs from IndexedDB!`);\n        return blobs;\n      }\n      this.uppy.log('[GoldenRetriever] No blobs found in IndexedDB');\n      return {};\n    }).catch(err => {\n      this.uppy.log('[GoldenRetriever] Failed to recover blobs from IndexedDB', 'warning');\n      this.uppy.log(err);\n      return {};\n    });\n  }\n  onBlobsLoaded(blobs) {\n    const obsoleteBlobs = [];\n    const updatedFiles = _objectSpread({}, this.uppy.getState().files); // Loop through blobs that we can restore, add blobs to file objects\n\n    Object.keys(blobs).forEach(fileID => {\n      const originalFile = this.uppy.getFile(fileID);\n      if (!originalFile) {\n        obsoleteBlobs.push(fileID);\n        return;\n      }\n      const cachedData = blobs[fileID];\n      const updatedFileData = {\n        data: cachedData,\n        isRestored: true,\n        isGhost: false\n      };\n      updatedFiles[fileID] = _objectSpread(_objectSpread({}, originalFile), updatedFileData);\n    }); // Loop through files that we can’t restore fully — we only have meta, not blobs,\n    // set .isGhost on them, also set isRestored to all files\n\n    Object.keys(updatedFiles).forEach(fileID => {\n      if (updatedFiles[fileID].data === null) {\n        updatedFiles[fileID] = _objectSpread(_objectSpread({}, updatedFiles[fileID]), {}, {\n          isGhost: true\n        });\n      }\n    });\n    this.uppy.setState({\n      files: updatedFiles\n    });\n    this.uppy.emit('restored', this.savedPluginData);\n    if (obsoleteBlobs.length) {\n      this.deleteBlobs(obsoleteBlobs).then(() => {\n        this.uppy.log(`[GoldenRetriever] Cleaned up ${obsoleteBlobs.length} old files`);\n      }).catch(err => {\n        this.uppy.log(`[GoldenRetriever] Could not clean up ${obsoleteBlobs.length} old files`, 'warning');\n        this.uppy.log(err);\n      });\n    }\n  }\n  deleteBlobs(fileIDs) {\n    const promises = [];\n    fileIDs.forEach(id => {\n      if (this.ServiceWorkerStore) {\n        promises.push(this.ServiceWorkerStore.delete(id));\n      }\n      if (this.IndexedDBStore) {\n        promises.push(this.IndexedDBStore.delete(id));\n      }\n    });\n    return Promise.all(promises);\n  }\n  install() {\n    this.restoreState();\n    this.restoreBlobs();\n    this.uppy.on('file-added', this.addBlobToStores);\n    this.uppy.on('file-editor:complete', this.replaceBlobInStores);\n    this.uppy.on('file-removed', this.removeBlobFromStores); // TODO: the `state-update` is bad practise. It fires on any state change in Uppy\n    // or any state change in any of the plugins. We should to able to only listen\n    // for the state changes we need, somehow.\n\n    this.uppy.on('state-update', this.saveFilesStateToLocalStorage);\n    this.uppy.on('restore-confirmed', this.handleRestoreConfirmed);\n    this.uppy.on('restore-canceled', this.abortRestore);\n    this.uppy.on('complete', this.handleComplete);\n  }\n  uninstall() {\n    this.uppy.off('file-added', this.addBlobToStores);\n    this.uppy.off('file-editor:complete', this.replaceBlobInStores);\n    this.uppy.off('file-removed', this.removeBlobFromStores);\n    this.uppy.off('state-update', this.saveFilesStateToLocalStorage);\n    this.uppy.off('restore-confirmed', this.handleRestoreConfirmed);\n    this.uppy.off('restore-canceled', this.abortRestore);\n    this.uppy.off('complete', this.handleComplete);\n  }\n}\nGoldenRetriever.VERSION = packageJson.version;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}