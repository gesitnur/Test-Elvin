{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport { nanoid } from 'nanoid/non-secure';\nimport { Provider, RequestClient, Socket } from '@uppy/companion-client';\nimport emitSocketProgress from '@uppy/utils/lib/emitSocketProgress';\nimport getSocketHost from '@uppy/utils/lib/getSocketHost';\nimport EventTracker from '@uppy/utils/lib/EventTracker';\nimport ProgressTimeout from '@uppy/utils/lib/ProgressTimeout';\nimport ErrorWithCause from '@uppy/utils/lib/ErrorWithCause';\nimport NetworkError from '@uppy/utils/lib/NetworkError';\nimport isNetworkError from '@uppy/utils/lib/isNetworkError';\nimport { internalRateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue'; // See XHRUpload\n\nfunction buildResponseError(xhr, error) {\n  if (isNetworkError(xhr)) return new NetworkError(error, xhr);\n  const err = new ErrorWithCause('Upload error', {\n    cause: error\n  });\n  err.request = xhr;\n  return err;\n} // See XHRUpload\n\nfunction setTypeInBlob(file) {\n  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n  return dataWithUpdatedType;\n}\nfunction addMetadata(formData, meta, opts) {\n  const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields // Send along all fields by default.\n  : Object.keys(meta);\n  allowedMetaFields.forEach(item => {\n    formData.append(item, meta[item]);\n  });\n}\nfunction createFormDataUpload(file, opts) {\n  const formPost = new FormData();\n  addMetadata(formPost, file.meta, opts);\n  const dataWithUpdatedType = setTypeInBlob(file);\n  if (file.name) {\n    formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n  } else {\n    formPost.append(opts.fieldName, dataWithUpdatedType);\n  }\n  return formPost;\n}\nconst createBareUpload = file => file.data;\nvar _queueRequestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueRequestSocketToken\");\nvar _getOptions = /*#__PURE__*/_classPrivateFieldLooseKey(\"getOptions\");\nvar _addEventHandlerForFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"addEventHandlerForFile\");\nvar _addEventHandlerIfFileStillExists = /*#__PURE__*/_classPrivateFieldLooseKey(\"addEventHandlerIfFileStillExists\");\nvar _uploadLocalFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploadLocalFile\");\nvar _requestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestSocketToken\");\nvar _uploadRemoteFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"uploadRemoteFile\");\nexport default class MiniXHRUpload {\n  constructor(_uppy, _opts) {\n    Object.defineProperty(this, _uploadRemoteFile, {\n      value: _uploadRemoteFile2\n    });\n    Object.defineProperty(this, _uploadLocalFile, {\n      value: _uploadLocalFile2\n    });\n    Object.defineProperty(this, _addEventHandlerIfFileStillExists, {\n      value: _addEventHandlerIfFileStillExists2\n    });\n    Object.defineProperty(this, _addEventHandlerForFile, {\n      value: _addEventHandlerForFile2\n    });\n    Object.defineProperty(this, _getOptions, {\n      value: _getOptions2\n    });\n    Object.defineProperty(this, _queueRequestSocketToken, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _requestSocketToken, {\n      writable: true,\n      value: async file => {\n        const opts = _classPrivateFieldLooseBase(this, _getOptions)[_getOptions](file);\n        const Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n        const client = new Client(this.uppy, file.remote.providerOptions);\n        const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields // Send along all fields by default.\n        : Object.keys(file.meta);\n        if (file.tus) {\n          // Install file-specific upload overrides.\n          Object.assign(opts, file.tus);\n        }\n        const res = await client.post(file.remote.url, _objectSpread(_objectSpread({}, file.remote.body), {}, {\n          protocol: 'multipart',\n          endpoint: opts.endpoint,\n          size: file.data.size,\n          fieldname: opts.fieldName,\n          metadata: Object.fromEntries(allowedMetaFields.map(name => [name, file.meta[name]])),\n          httpMethod: opts.method,\n          useFormData: opts.formData,\n          headers: opts.headers\n        }));\n        return res.token;\n      }\n    });\n    this.uppy = _uppy;\n    this.opts = _objectSpread({\n      validateStatus(status) {\n        return status >= 200 && status < 300;\n      }\n    }, _opts);\n    this.requests = _opts[internalRateLimitedQueue];\n    this.uploaderEvents = Object.create(null);\n    this.i18n = _opts.i18n;\n    _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken] = this.requests.wrapPromiseFunction(_classPrivateFieldLooseBase(this, _requestSocketToken)[_requestSocketToken], {\n      priority: -1\n    });\n  }\n  uploadFile(id, current, total) {\n    const file = this.uppy.getFile(id);\n    if (file.error) {\n      throw new Error(file.error);\n    } else if (file.isRemote) {\n      return _classPrivateFieldLooseBase(this, _uploadRemoteFile)[_uploadRemoteFile](file, current, total);\n    }\n    return _classPrivateFieldLooseBase(this, _uploadLocalFile)[_uploadLocalFile](file, current, total);\n  }\n  connectToServerSocket(file) {\n    return new Promise((resolve, reject) => {\n      const opts = _classPrivateFieldLooseBase(this, _getOptions)[_getOptions](file);\n      const token = file.serverToken;\n      const host = getSocketHost(file.remote.companionUrl);\n      let socket;\n      const createSocket = () => {\n        if (socket != null) return;\n        socket = new Socket({\n          target: `${host}/api/${token}`\n        });\n        socket.on('progress', progressData => emitSocketProgress(this, progressData, file));\n        socket.on('success', data => {\n          const body = opts.getResponseData(data.response.responseText, data.response);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: data.response.status,\n            body,\n            uploadURL,\n            bytesUploaded: data.bytesUploaded\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          socket.close();\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n          return resolve();\n        });\n        socket.on('error', errData => {\n          const resp = errData.response;\n          const error = resp ? opts.getResponseError(resp.responseText, resp) : new ErrorWithCause(errData.error.message, {\n            cause: errData.error\n          });\n          this.uppy.emit('upload-error', file, error);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n          reject(error);\n        });\n      };\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest = this.requests.run(() => {\n        if (file.isPaused) {\n          var _socket;\n          (_socket = socket) == null ? void 0 : _socket.send('pause', {});\n        } else {\n          createSocket();\n        }\n        return () => socket.close();\n      });\n      _classPrivateFieldLooseBase(this, _addEventHandlerForFile)[_addEventHandlerForFile]('file-removed', file.id, () => {\n        var _socket2;\n        (_socket2 = socket) == null ? void 0 : _socket2.send('cancel', {});\n        queuedRequest.abort();\n        resolve(`upload ${file.id} was removed`);\n      });\n      _classPrivateFieldLooseBase(this, _addEventHandlerIfFileStillExists)[_addEventHandlerIfFileStillExists]('cancel-all', file.id, function (_temp) {\n        let _ref = _temp === void 0 ? {} : _temp,\n          reason = _ref.reason;\n        if (reason === 'user') {\n          var _socket3;\n          (_socket3 = socket) == null ? void 0 : _socket3.send('cancel', {});\n          queuedRequest.abort();\n        }\n        resolve(`upload ${file.id} was canceled`);\n      });\n      const onRetryRequest = () => {\n        if (socket == null) {\n          queuedRequest.abort();\n        } else {\n          socket.send('pause', {});\n          queuedRequest.done();\n        }\n        queuedRequest = this.requests.run(() => {\n          if (!file.isPaused) {\n            if (socket == null) {\n              createSocket();\n            } else {\n              socket.send('resume', {});\n            }\n          }\n          return () => socket.close();\n        });\n      };\n      _classPrivateFieldLooseBase(this, _addEventHandlerForFile)[_addEventHandlerForFile]('upload-retry', file.id, onRetryRequest);\n      _classPrivateFieldLooseBase(this, _addEventHandlerIfFileStillExists)[_addEventHandlerIfFileStillExists]('retry-all', file.id, onRetryRequest);\n    }).catch(err => {\n      this.uppy.emit('upload-error', file, err);\n      return Promise.reject(err);\n    });\n  }\n}\nfunction _getOptions2(file) {\n  var _file$xhrUpload;\n  const uppy = this.uppy;\n  const overrides = uppy.getState().xhrUpload;\n  const opts = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.opts), overrides || {}), file.xhrUpload || {}), {}, {\n    headers: _objectSpread(_objectSpread(_objectSpread({}, this.opts.headers), overrides == null ? void 0 : overrides.headers), (_file$xhrUpload = file.xhrUpload) == null ? void 0 : _file$xhrUpload.headers)\n  });\n  return opts;\n}\nfunction _addEventHandlerForFile2(eventName, fileID, eventHandler) {\n  this.uploaderEvents[fileID].on(eventName, fileOrID => {\n    var _fileOrID$id;\n\n    // TODO (major): refactor Uppy events to consistently send file objects (or consistently IDs)\n    // We created a generic `addEventListenerForFile` but not all events\n    // use file IDs, some use files, so we need to do this weird check.\n    const id = (_fileOrID$id = fileOrID == null ? void 0 : fileOrID.id) != null ? _fileOrID$id : fileOrID;\n    if (fileID === id) eventHandler();\n  });\n}\nfunction _addEventHandlerIfFileStillExists2(eventName, fileID, eventHandler) {\n  var _this = this;\n  this.uploaderEvents[fileID].on(eventName, function () {\n    if (_this.uppy.getFile(fileID)) eventHandler(...arguments);\n  });\n}\nfunction _uploadLocalFile2(file, current, total) {\n  const opts = _classPrivateFieldLooseBase(this, _getOptions)[_getOptions](file);\n  this.uppy.log(`uploading ${current} of ${total}`);\n  return new Promise((resolve, reject) => {\n    // This is done in index.js in the S3 plugin.\n    // this.uppy.emit('upload-started', file)\n    const data = opts.formData ? createFormDataUpload(file, opts) : createBareUpload(file, opts);\n    const xhr = new XMLHttpRequest();\n    this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n    const timer = new ProgressTimeout(opts.timeout, () => {\n      xhr.abort(); // eslint-disable-next-line no-use-before-define\n\n      queuedRequest.done();\n      const error = new Error(this.i18n('timedOut', {\n        seconds: Math.ceil(opts.timeout / 1000)\n      }));\n      this.uppy.emit('upload-error', file, error);\n      reject(error);\n    });\n    const id = nanoid();\n    xhr.upload.addEventListener('loadstart', () => {\n      this.uppy.log(`[AwsS3/XHRUpload] ${id} started`);\n    });\n    xhr.upload.addEventListener('progress', ev => {\n      this.uppy.log(`[AwsS3/XHRUpload] ${id} progress: ${ev.loaded} / ${ev.total}`); // Begin checking for timeouts when progress starts, instead of loading,\n      // to avoid timing out requests on browser concurrency queue\n\n      timer.progress();\n      if (ev.lengthComputable) {\n        this.uppy.emit('upload-progress', file, {\n          uploader: this,\n          bytesUploaded: ev.loaded,\n          bytesTotal: ev.total\n        });\n      }\n    });\n    xhr.addEventListener('load', ev => {\n      this.uppy.log(`[AwsS3/XHRUpload] ${id} finished`);\n      timer.done(); // eslint-disable-next-line no-use-before-define\n\n      queuedRequest.done();\n      if (this.uploaderEvents[file.id]) {\n        this.uploaderEvents[file.id].remove();\n        this.uploaderEvents[file.id] = null;\n      }\n      if (opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n        const body = opts.getResponseData(xhr.responseText, xhr);\n        const uploadURL = body[opts.responseUrlFieldName];\n        const uploadResp = {\n          status: ev.target.status,\n          body,\n          uploadURL\n        };\n        this.uppy.emit('upload-success', file, uploadResp);\n        if (uploadURL) {\n          this.uppy.log(`Download ${file.name} from ${uploadURL}`);\n        }\n        return resolve(file);\n      }\n      const body = opts.getResponseData(xhr.responseText, xhr);\n      const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n      const response = {\n        status: ev.target.status,\n        body\n      };\n      this.uppy.emit('upload-error', file, error, response);\n      return reject(error);\n    });\n    xhr.addEventListener('error', () => {\n      this.uppy.log(`[AwsS3/XHRUpload] ${id} errored`);\n      timer.done(); // eslint-disable-next-line no-use-before-define\n\n      queuedRequest.done();\n      if (this.uploaderEvents[file.id]) {\n        this.uploaderEvents[file.id].remove();\n        this.uploaderEvents[file.id] = null;\n      }\n      const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n      this.uppy.emit('upload-error', file, error);\n      return reject(error);\n    });\n    xhr.open(opts.method.toUpperCase(), opts.endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n    // before `open()` is called. It’s important to set withCredentials\n    // to a boolean, otherwise React Native crashes\n\n    xhr.withCredentials = Boolean(opts.withCredentials);\n    if (opts.responseType !== '') {\n      xhr.responseType = opts.responseType;\n    }\n    Object.keys(opts.headers).forEach(header => {\n      xhr.setRequestHeader(header, opts.headers[header]);\n    });\n    const queuedRequest = this.requests.run(() => {\n      xhr.send(data);\n      return () => {\n        // eslint-disable-next-line no-use-before-define\n        timer.done();\n        xhr.abort();\n      };\n    }, {\n      priority: 1\n    });\n    _classPrivateFieldLooseBase(this, _addEventHandlerForFile)[_addEventHandlerForFile]('file-removed', file.id, () => {\n      queuedRequest.abort();\n      reject(new Error('File removed'));\n    });\n    _classPrivateFieldLooseBase(this, _addEventHandlerIfFileStillExists)[_addEventHandlerIfFileStillExists]('cancel-all', file.id, function (_temp2) {\n      let _ref2 = _temp2 === void 0 ? {} : _temp2,\n        reason = _ref2.reason;\n      if (reason === 'user') {\n        queuedRequest.abort();\n      }\n      reject(new Error('Upload cancelled'));\n    });\n  });\n}\nasync function _uploadRemoteFile2(file) {\n  // TODO: we could rewrite this to use server-sent events instead of creating WebSockets.\n  try {\n    if (file.serverToken) {\n      return this.connectToServerSocket(file);\n    }\n    const serverToken = await _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken](file);\n    if (!this.uppy.getState().files[file.id]) return undefined;\n    this.uppy.setFileState(file.id, {\n      serverToken\n    });\n    return this.connectToServerSocket(this.uppy.getFile(file.id));\n  } catch (err) {\n    this.uppy.emit('upload-error', file, err);\n    throw err;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}