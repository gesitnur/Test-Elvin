{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport { BasePlugin } from '@uppy/core';\nimport { RateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue';\nimport getFileNameAndExtension from '@uppy/utils/lib/getFileNameAndExtension';\nimport prettierBytes from '@transloadit/prettier-bytes';\nimport CompressorJS from 'compressorjs/dist/compressor.common.js';\nimport locale from './locale.js';\nvar _RateLimitedQueue = /*#__PURE__*/_classPrivateFieldLooseKey(\"RateLimitedQueue\");\nexport default class Compressor extends BasePlugin {\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    Object.defineProperty(this, _RateLimitedQueue, {\n      writable: true,\n      value: void 0\n    });\n    this.id = this.opts.id || 'Compressor';\n    this.type = 'modifier';\n    this.defaultLocale = locale;\n    const defaultOptions = {\n      quality: 0.6,\n      limit: 10\n    };\n    this.opts = _objectSpread(_objectSpread({}, defaultOptions), opts);\n    _classPrivateFieldLooseBase(this, _RateLimitedQueue)[_RateLimitedQueue] = new RateLimitedQueue(this.opts.limit);\n    this.i18nInit();\n    this.prepareUpload = this.prepareUpload.bind(this);\n    this.compress = this.compress.bind(this);\n  }\n  compress(blob) {\n    return new Promise((resolve, reject) => {\n      /* eslint-disable no-new */\n      new CompressorJS(blob, _objectSpread(_objectSpread({}, this.opts), {}, {\n        success: resolve,\n        error: reject\n      }));\n    });\n  }\n  async prepareUpload(fileIDs) {\n    let totalCompressedSize = 0;\n    const compressedFiles = [];\n    const compressAndApplyResult = _classPrivateFieldLooseBase(this, _RateLimitedQueue)[_RateLimitedQueue].wrapPromiseFunction(async file => {\n      try {\n        const compressedBlob = await this.compress(file.data);\n        const compressedSavingsSize = file.data.size - compressedBlob.size;\n        this.uppy.log(`[Image Compressor] Image ${file.id} compressed by ${prettierBytes(compressedSavingsSize)}`);\n        totalCompressedSize += compressedSavingsSize;\n        const name = compressedBlob.name,\n          type = compressedBlob.type,\n          size = compressedBlob.size;\n        const extension = name && getFileNameAndExtension(name).extension;\n        this.uppy.setFileState(file.id, _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, name && {\n          name\n        }), extension && {\n          extension\n        }), type && {\n          type\n        }), size && {\n          size\n        }), {}, {\n          data: compressedBlob\n        }));\n        this.uppy.setFileMeta(file.id, {\n          type\n        });\n        compressedFiles.push(file);\n      } catch (err) {\n        this.uppy.log(`[Image Compressor] Failed to compress ${file.id}:`, 'warning');\n        this.uppy.log(err, 'warning');\n      }\n    });\n    const promises = fileIDs.map(fileID => {\n      const file = this.uppy.getFile(fileID);\n      this.uppy.emit('preprocess-progress', file, {\n        mode: 'indeterminate',\n        message: this.i18n('compressingImages')\n      });\n      if (file.isRemote) {\n        return Promise.resolve();\n      } // Some browsers (Firefox) add blobs with empty file type, when files are\n      // added from a folder. Uppy auto-detects type from extension, but leaves the original blob intact.\n      // However, Compressor.js failes when file has no type, so we set it here\n\n      if (!file.data.type) {\n        file.data = file.data.slice(0, file.data.size, file.type);\n      }\n      if (!file.type.startsWith('image/')) {\n        return Promise.resolve();\n      }\n      return compressAndApplyResult(file);\n    }); // Why emit `preprocess-complete` for all files at once, instead of\n    // above when each is processed?\n    // Because it leads to StatusBar showing a weird “upload 6 files” button,\n    // while waiting for all the files to complete pre-processing.\n\n    await Promise.all(promises);\n    this.uppy.emit('compressor:complete', compressedFiles); // Only show informer if Compressor mananged to save at least a kilobyte\n\n    if (totalCompressedSize > 1024) {\n      this.uppy.info(this.i18n('compressedX', {\n        size: prettierBytes(totalCompressedSize)\n      }), 'info');\n    }\n    for (const fileID of fileIDs) {\n      const file = this.uppy.getFile(fileID);\n      this.uppy.emit('preprocess-complete', file);\n    }\n  }\n  install() {\n    this.uppy.addPreProcessor(this.prepareUpload);\n  }\n  uninstall() {\n    this.uppy.removePreProcessor(this.prepareUpload);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}