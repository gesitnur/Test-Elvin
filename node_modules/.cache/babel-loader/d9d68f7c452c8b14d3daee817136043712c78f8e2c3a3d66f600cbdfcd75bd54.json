{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar cuid = require('cuid');\nvar _require = require('@uppy/companion-client'),\n  Provider = _require.Provider,\n  RequestClient = _require.RequestClient,\n  Socket = _require.Socket;\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\nvar ProgressTimeout = require('@uppy/utils/lib/ProgressTimeout');\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\nvar isNetworkError = require('@uppy/utils/lib/isNetworkError'); // See XHRUpload\n\nfunction buildResponseError(xhr, error) {\n  // No error message\n  if (!error) error = new Error('Upload error'); // Got an error message string\n\n  if (typeof error === 'string') error = new Error(error); // Got something else\n\n  if (!(error instanceof Error)) {\n    error = _extends(new Error('Upload error'), {\n      data: error\n    });\n  }\n  if (isNetworkError(xhr)) {\n    error = new NetworkError(error, xhr);\n    return error;\n  }\n  error.request = xhr;\n  return error;\n} // See XHRUpload\n\nfunction setTypeInBlob(file) {\n  var dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n  return dataWithUpdatedType;\n}\nmodule.exports = /*#__PURE__*/function () {\n  function MiniXHRUpload(uppy, opts) {\n    this.uppy = uppy;\n    this.opts = _extends({\n      validateStatus: function validateStatus(status, responseText, response) {\n        return status >= 200 && status < 300;\n      }\n    }, opts);\n    this.requests = opts.__queue;\n    this.uploaderEvents = Object.create(null);\n    this.i18n = opts.i18n;\n  }\n  var _proto = MiniXHRUpload.prototype;\n  _proto._getOptions = function _getOptions(file) {\n    var uppy = this.uppy;\n    var overrides = uppy.getState().xhrUpload;\n    var opts = _extends({}, this.opts, overrides || {}, file.xhrUpload || {}, {\n      headers: {}\n    });\n    _extends(opts.headers, this.opts.headers);\n    if (overrides) {\n      _extends(opts.headers, overrides.headers);\n    }\n    if (file.xhrUpload) {\n      _extends(opts.headers, file.xhrUpload.headers);\n    }\n    return opts;\n  };\n  _proto.uploadFile = function uploadFile(id, current, total) {\n    var file = this.uppy.getFile(id);\n    if (file.error) {\n      throw new Error(file.error);\n    } else if (file.isRemote) {\n      return this._uploadRemoteFile(file, current, total);\n    }\n    return this._uploadLocalFile(file, current, total);\n  };\n  _proto._addMetadata = function _addMetadata(formData, meta, opts) {\n    var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n    : Object.keys(meta);\n    metaFields.forEach(function (item) {\n      formData.append(item, meta[item]);\n    });\n  };\n  _proto._createFormDataUpload = function _createFormDataUpload(file, opts) {\n    var formPost = new FormData();\n    this._addMetadata(formPost, file.meta, opts);\n    var dataWithUpdatedType = setTypeInBlob(file);\n    if (file.name) {\n      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n    } else {\n      formPost.append(opts.fieldName, dataWithUpdatedType);\n    }\n    return formPost;\n  };\n  _proto._createBareUpload = function _createBareUpload(file, opts) {\n    return file.data;\n  };\n  _proto._onFileRemoved = function _onFileRemoved(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  };\n  _proto._onRetry = function _onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  };\n  _proto._onRetryAll = function _onRetryAll(fileID, cb) {\n    var _this = this;\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto._onCancelAll = function _onCancelAll(fileID, cb) {\n    var _this2 = this;\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this2.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto._uploadLocalFile = function _uploadLocalFile(file, current, total) {\n    var _this3 = this;\n    var opts = this._getOptions(file);\n    this.uppy.log(\"uploading \" + current + \" of \" + total);\n    return new Promise(function (resolve, reject) {\n      // This is done in index.js in the S3 plugin.\n      // this.uppy.emit('upload-started', file)\n      var data = opts.formData ? _this3._createFormDataUpload(file, opts) : _this3._createBareUpload(file, opts);\n      var xhr = new XMLHttpRequest();\n      _this3.uploaderEvents[file.id] = new EventTracker(_this3.uppy);\n      var timer = new ProgressTimeout(opts.timeout, function () {\n        xhr.abort();\n        queuedRequest.done();\n        var error = new Error(_this3.i18n('timedOut', {\n          seconds: Math.ceil(opts.timeout / 1000)\n        }));\n        _this3.uppy.emit('upload-error', file, error);\n        reject(error);\n      });\n      var id = cuid();\n      xhr.upload.addEventListener('loadstart', function (ev) {\n        _this3.uppy.log(\"[AwsS3/XHRUpload] \" + id + \" started\");\n      });\n      xhr.upload.addEventListener('progress', function (ev) {\n        _this3.uppy.log(\"[AwsS3/XHRUpload] \" + id + \" progress: \" + ev.loaded + \" / \" + ev.total); // Begin checking for timeouts when progress starts, instead of loading,\n        // to avoid timing out requests on browser concurrency queue\n\n        timer.progress();\n        if (ev.lengthComputable) {\n          _this3.uppy.emit('upload-progress', file, {\n            uploader: _this3,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        }\n      });\n      xhr.addEventListener('load', function (ev) {\n        _this3.uppy.log(\"[AwsS3/XHRUpload] \" + id + \" finished\");\n        timer.done();\n        queuedRequest.done();\n        if (_this3.uploaderEvents[file.id]) {\n          _this3.uploaderEvents[file.id].remove();\n          _this3.uploaderEvents[file.id] = null;\n        }\n        if (opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n          var _body = opts.getResponseData(xhr.responseText, xhr);\n          var uploadURL = _body[opts.responseUrlFieldName];\n          var uploadResp = {\n            status: ev.target.status,\n            body: _body,\n            uploadURL: uploadURL\n          };\n          _this3.uppy.emit('upload-success', file, uploadResp);\n          if (uploadURL) {\n            _this3.uppy.log(\"Download \" + file.name + \" from \" + uploadURL);\n          }\n          return resolve(file);\n        }\n        var body = opts.getResponseData(xhr.responseText, xhr);\n        var error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        var response = {\n          status: ev.target.status,\n          body: body\n        };\n        _this3.uppy.emit('upload-error', file, error, response);\n        return reject(error);\n      });\n      xhr.addEventListener('error', function (ev) {\n        _this3.uppy.log(\"[AwsS3/XHRUpload] \" + id + \" errored\");\n        timer.done();\n        queuedRequest.done();\n        if (_this3.uploaderEvents[file.id]) {\n          _this3.uploaderEvents[file.id].remove();\n          _this3.uploaderEvents[file.id] = null;\n        }\n        var error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        _this3.uppy.emit('upload-error', file, error);\n        return reject(error);\n      });\n      xhr.open(opts.method.toUpperCase(), opts.endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = opts.withCredentials;\n      if (opts.responseType !== '') {\n        xhr.responseType = opts.responseType;\n      }\n      Object.keys(opts.headers).forEach(function (header) {\n        xhr.setRequestHeader(header, opts.headers[header]);\n      });\n      var queuedRequest = _this3.requests.run(function () {\n        xhr.send(data);\n        return function () {\n          timer.done();\n          xhr.abort();\n        };\n      }, {\n        priority: 1\n      });\n      _this3._onFileRemoved(file.id, function () {\n        queuedRequest.abort();\n        reject(new Error('File removed'));\n      });\n      _this3._onCancelAll(file.id, function () {\n        queuedRequest.abort();\n        reject(new Error('Upload cancelled'));\n      });\n    });\n  };\n  _proto._uploadRemoteFile = function _uploadRemoteFile(file, current, total) {\n    var _this4 = this;\n    var opts = this._getOptions(file);\n    return new Promise(function (resolve, reject) {\n      // This is done in index.js in the S3 plugin.\n      // this.uppy.emit('upload-started', file)\n      var fields = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n      : Object.keys(file.meta);\n      metaFields.forEach(function (name) {\n        fields[name] = file.meta[name];\n      });\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this4.uppy, file.remote.providerOptions);\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        endpoint: opts.endpoint,\n        size: file.data.size,\n        fieldname: opts.fieldName,\n        metadata: fields,\n        httpMethod: opts.method,\n        useFormData: opts.formData,\n        headers: opts.headers\n      })).then(function (res) {\n        var token = res.token;\n        var host = getSocketHost(file.remote.companionUrl);\n        var socket = new Socket({\n          target: host + \"/api/\" + token,\n          autoOpen: false\n        });\n        _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n        _this4._onFileRemoved(file.id, function () {\n          socket.send('pause', {});\n          queuedRequest.abort();\n          resolve(\"upload \" + file.id + \" was removed\");\n        });\n        _this4._onCancelAll(file.id, function () {\n          socket.send('pause', {});\n          queuedRequest.abort();\n          resolve(\"upload \" + file.id + \" was canceled\");\n        });\n        _this4._onRetry(file.id, function () {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        });\n        _this4._onRetryAll(file.id, function () {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        });\n        socket.on('progress', function (progressData) {\n          return emitSocketProgress(_this4, progressData, file);\n        });\n        socket.on('success', function (data) {\n          var body = opts.getResponseData(data.response.responseText, data.response);\n          var uploadURL = body[opts.responseUrlFieldName];\n          var uploadResp = {\n            status: data.response.status,\n            body: body,\n            uploadURL: uploadURL,\n            bytesUploaded: data.bytesUploaded\n          };\n          _this4.uppy.emit('upload-success', file, uploadResp);\n          queuedRequest.done();\n          if (_this4.uploaderEvents[file.id]) {\n            _this4.uploaderEvents[file.id].remove();\n            _this4.uploaderEvents[file.id] = null;\n          }\n          return resolve();\n        });\n        socket.on('error', function (errData) {\n          var resp = errData.response;\n          var error = resp ? opts.getResponseError(resp.responseText, resp) : _extends(new Error(errData.error.message), {\n            cause: errData.error\n          });\n          _this4.uppy.emit('upload-error', file, error);\n          queuedRequest.done();\n          if (_this4.uploaderEvents[file.id]) {\n            _this4.uploaderEvents[file.id].remove();\n            _this4.uploaderEvents[file.id] = null;\n          }\n          reject(error);\n        });\n        var queuedRequest = _this4.requests.run(function () {\n          socket.open();\n          if (file.isPaused) {\n            socket.send('pause', {});\n          }\n          return function () {\n            return socket.close();\n          };\n        });\n      }).catch(function (err) {\n        _this4.uppy.emit('upload-error', file, err);\n        reject(err);\n      });\n    });\n  };\n  return MiniXHRUpload;\n}();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}