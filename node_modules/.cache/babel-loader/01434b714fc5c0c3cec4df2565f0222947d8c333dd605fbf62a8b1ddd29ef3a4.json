{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar NODE_LIST_CLASSES = {\n  '[object HTMLCollection]': true,\n  '[object NodeList]': true,\n  '[object RadioNodeList]': true\n}; // .type values for elements which can appear in .elements and should be ignored\n\nvar IGNORED_ELEMENT_TYPES = {\n  'button': true,\n  'fieldset': true,\n  'reset': true,\n  'submit': true\n};\nvar CHECKED_INPUT_TYPES = {\n  'checkbox': true,\n  'radio': true\n};\nvar TRIM_RE = /^\\s+|\\s+$/g;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n/**\n * @param {HTMLFormElement} form\n * @param {Object} [options]\n * @return {Object.<string,boolean|string|string[]>} an object containing\n *   submittable value(s) held in the form's .elements collection, with\n *   properties named as per element names or ids.\n */\n\nexport default function getFormData(form, options) {\n  if (!form) {\n    throw new Error(\"A form is required by getFormData, was given form=\" + form);\n  }\n  options = _extends({\n    includeDisabled: false,\n    trim: false\n  }, options);\n  var data = {};\n  var elementName;\n  var elementNames = [];\n  var elementNameLookup = {}; // Get unique submittable element names for the form\n\n  for (var i = 0, l = form.elements.length; i < l; i++) {\n    var element = form.elements[i];\n    if (IGNORED_ELEMENT_TYPES[element.type] || element.disabled && !options.includeDisabled) {\n      continue;\n    }\n    elementName = element.name || element.id;\n    if (elementName && !elementNameLookup[elementName]) {\n      elementNames.push(elementName);\n      elementNameLookup[elementName] = true;\n    }\n  } // Extract element data name-by-name for consistent handling of special cases\n  // around elements which contain multiple inputs.\n\n  for (var _i = 0, _l = elementNames.length; _i < _l; _i++) {\n    elementName = elementNames[_i];\n    var value = getFieldData(form, elementName, options);\n    if (value != null) {\n      data[elementName] = value;\n    }\n  }\n  return data;\n}\n/**\n * @param {HTMLFormElement} form\n * @param {string} fieldName\n * @param {Object} [options]\n * @return {?(boolean|string|string[]|File|File[])} submittable value(s) in the\n *   form for a  named element from its .elements collection, or null if there\n *   was no element with that name, or the element had no submittable value(s).\n */\n\nexport function getFieldData(form, fieldName, options) {\n  if (!form) {\n    throw new Error(\"A form is required by getFieldData, was given form=\" + form);\n  }\n  if (!fieldName && toString.call(fieldName) !== '[object String]') {\n    throw new Error(\"A field name is required by getFieldData, was given fieldName=\" + fieldName);\n  }\n  options = _extends({\n    includeDisabled: false,\n    trim: false\n  }, options);\n  var element = form.elements[fieldName];\n  if (!element || element.disabled && !options.includeDisabled) {\n    return null;\n  }\n  if (!NODE_LIST_CLASSES[toString.call(element)]) {\n    return getFormElementValue(element, options.trim);\n  } // Deal with multiple form controls which have the same name\n\n  var data = [];\n  var allRadios = true;\n  for (var i = 0, l = element.length; i < l; i++) {\n    if (element[i].disabled && !options.includeDisabled) {\n      continue;\n    }\n    if (allRadios && element[i].type !== 'radio') {\n      allRadios = false;\n    }\n    var value = getFormElementValue(element[i], options.trim);\n    if (value != null) {\n      data = data.concat(value);\n    }\n  } // Special case for an element with multiple same-named inputs which were all\n  // radio buttons: if there was a selected value, only return the value.\n\n  if (allRadios && data.length === 1) {\n    return data[0];\n  }\n  return data.length > 0 ? data : null;\n}\n/**\n * @param {HTMLElement} element a form element.\n * @param {boolean} [trim] should values for text entry inputs be trimmed?\n * @return {?(boolean|string|string[]|File|File[])} the element's submittable\n *   value(s), or null if it had none.\n */\n\nfunction getFormElementValue(element, trim) {\n  var value = null;\n  var type = element.type;\n  if (type === 'select-one') {\n    if (element.options.length) {\n      value = element.options[element.selectedIndex].value;\n    }\n    return value;\n  }\n  if (type === 'select-multiple') {\n    value = [];\n    for (var i = 0, l = element.options.length; i < l; i++) {\n      if (element.options[i].selected) {\n        value.push(element.options[i].value);\n      }\n    }\n    if (value.length === 0) {\n      value = null;\n    }\n    return value;\n  } // If a file input doesn't have a files attribute, fall through to using its\n  // value attribute.\n\n  if (type === 'file' && 'files' in element) {\n    if (element.multiple) {\n      value = slice.call(element.files);\n      if (value.length === 0) {\n        value = null;\n      }\n    } else {\n      // Should be null if not present, according to the spec\n      value = element.files[0];\n    }\n    return value;\n  }\n  if (!CHECKED_INPUT_TYPES[type]) {\n    value = trim ? element.value.replace(TRIM_RE, '') : element.value;\n  } else if (element.checked) {\n    if (type === 'checkbox' && !element.hasAttribute('value')) {\n      value = true;\n    } else {\n      value = element.value;\n    }\n  }\n  return value;\n} // For UMD build access to getFieldData\n\ngetFormData.getFieldData = getFieldData;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}