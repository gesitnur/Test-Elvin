{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define(\"exifr\", [\"exports\"], t) : t((e = \"undefined\" != typeof globalThis ? globalThis : e || self).exifr = {});\n}(this, function (e) {\n  \"use strict\";\n\n  function t(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function n(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var r = t[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n    }\n  }\n  function r(e, t, r) {\n    return t && n(e.prototype, t), r && n(e, r), e;\n  }\n  function i(e, t, n) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = n, e;\n  }\n  function a(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    });\n    var n = [\"prototype\", \"__proto__\", \"caller\", \"arguments\", \"length\", \"name\"];\n    Object.getOwnPropertyNames(t).forEach(function (r) {\n      -1 === n.indexOf(r) && e[r] !== t[r] && (e[r] = t[r]);\n    }), t && u(e, t);\n  }\n  function s(e) {\n    return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n  function u(e, t) {\n    return (u = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n  function o() {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n    try {\n      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }\n  function f(e, t, n) {\n    return (f = o() ? Reflect.construct : function (e, t, n) {\n      var r = [null];\n      r.push.apply(r, t);\n      var i = new (Function.bind.apply(e, r))();\n      return n && u(i, n.prototype), i;\n    }).apply(null, arguments);\n  }\n  function c(e) {\n    var t = \"function\" == typeof Map ? new Map() : void 0;\n    return (c = function (e) {\n      if (null === e || (n = e, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return e;\n      var n;\n      if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n      if (void 0 !== t) {\n        if (t.has(e)) return t.get(e);\n        t.set(e, r);\n      }\n      function r() {\n        return f(e, arguments, s(this).constructor);\n      }\n      return r.prototype = Object.create(e.prototype, {\n        constructor: {\n          value: r,\n          enumerable: !1,\n          writable: !0,\n          configurable: !0\n        }\n      }), u(r, e);\n    })(e);\n  }\n  function h(e) {\n    if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return e;\n  }\n  function l(e, t) {\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? h(e) : t;\n  }\n  function d(e) {\n    var t = o();\n    return function () {\n      var n,\n        r = s(e);\n      if (t) {\n        var i = s(this).constructor;\n        n = Reflect.construct(r, arguments, i);\n      } else n = r.apply(this, arguments);\n      return l(this, n);\n    };\n  }\n  function v(e, t, n) {\n    return (v = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, n) {\n      var r = function (e, t) {\n        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = s(e)););\n        return e;\n      }(e, t);\n      if (r) {\n        var i = Object.getOwnPropertyDescriptor(r, t);\n        return i.get ? i.get.call(n) : i.value;\n      }\n    })(e, t, n || e);\n  }\n  var p = Object.values || function (e) {\n      var t = [];\n      for (var n in e) t.push(e[n]);\n      return t;\n    },\n    y = Object.entries || function (e) {\n      var t = [];\n      for (var n in e) t.push([n, e[n]]);\n      return t;\n    },\n    g = Object.assign || function (e) {\n      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];\n      return n.forEach(function (t) {\n        for (var n in t) e[n] = t[n];\n      }), e;\n    },\n    k = Object.fromEntries || function (e) {\n      var t = {};\n      return m(e).forEach(function (e) {\n        var n = e[0],\n          r = e[1];\n        t[n] = r;\n      }), t;\n    },\n    m = Array.from || function (e) {\n      if (e instanceof P) {\n        var t = [];\n        return e.forEach(function (e, n) {\n          return t.push([n, e]);\n        }), t;\n      }\n      return Array.prototype.slice.call(e);\n    };\n  function b(e) {\n    return -1 !== this.indexOf(e);\n  }\n  Array.prototype.includes || (Array.prototype.includes = b), String.prototype.includes || (String.prototype.includes = b), String.prototype.startsWith || (String.prototype.startsWith = function (e) {\n    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    return this.substring(t, t + e.length) === e;\n  }), String.prototype.endsWith || (String.prototype.endsWith = function (e) {\n    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;\n    return this.substring(t - e.length, t) === e;\n  });\n  var A = \"undefined\" != typeof self ? self : global,\n    w = A.fetch || function (e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      return new Promise(function (n, r) {\n        var i = new XMLHttpRequest();\n        if (i.open(\"get\", e, !0), i.responseType = \"arraybuffer\", i.onerror = r, t.headers) for (var a in t.headers) i.setRequestHeader(a, t.headers[a]);\n        i.onload = function () {\n          n({\n            ok: i.status >= 200 && i.status < 300,\n            status: i.status,\n            arrayBuffer: function () {\n              return Promise.resolve(i.response);\n            }\n          });\n        }, i.send(null);\n      });\n    },\n    O = function (e) {\n      var t = [];\n      if (Object.defineProperties(t, {\n        size: {\n          get: function () {\n            return this.length;\n          }\n        },\n        has: {\n          value: function (e) {\n            return -1 !== this.indexOf(e);\n          }\n        },\n        add: {\n          value: function (e) {\n            this.has(e) || this.push(e);\n          }\n        },\n        delete: {\n          value: function (e) {\n            if (this.has(e)) {\n              var t = this.indexOf(e);\n              this.splice(t, 1);\n            }\n          }\n        }\n      }), Array.isArray(e)) for (var n = 0; n < e.length; n++) t.add(e[n]);\n      return t;\n    },\n    S = function (e) {\n      return new P(e);\n    },\n    P = void 0 !== A.Map && void 0 !== A.Map.prototype.keys ? A.Map : function () {\n      function e(n) {\n        if (t(this, e), this.clear(), n) for (var r = 0; r < n.length; r++) this.set(n[r][0], n[r][1]);\n      }\n      return r(e, [{\n        key: \"clear\",\n        value: function () {\n          this._map = {}, this._keys = [];\n        }\n      }, {\n        key: \"size\",\n        get: function () {\n          return this._keys.length;\n        }\n      }, {\n        key: \"get\",\n        value: function (e) {\n          return this._map[\"map_\" + e];\n        }\n      }, {\n        key: \"set\",\n        value: function (e, t) {\n          return this._map[\"map_\" + e] = t, this._keys.indexOf(e) < 0 && this._keys.push(e), this;\n        }\n      }, {\n        key: \"has\",\n        value: function (e) {\n          return this._keys.indexOf(e) >= 0;\n        }\n      }, {\n        key: \"delete\",\n        value: function (e) {\n          var t = this._keys.indexOf(e);\n          return !(t < 0) && (delete this._map[\"map_\" + e], this._keys.splice(t, 1), !0);\n        }\n      }, {\n        key: \"keys\",\n        value: function () {\n          return this._keys.slice(0);\n        }\n      }, {\n        key: \"values\",\n        value: function () {\n          var e = this;\n          return this._keys.map(function (t) {\n            return e.get(t);\n          });\n        }\n      }, {\n        key: \"entries\",\n        value: function () {\n          var e = this;\n          return this._keys.map(function (t) {\n            return [t, e.get(t)];\n          });\n        }\n      }, {\n        key: \"forEach\",\n        value: function (e, t) {\n          for (var n = 0; n < this._keys.length; n++) e.call(t, this._map[\"map_\" + this._keys[n]], this._keys[n], this);\n        }\n      }]), e;\n    }(),\n    U = \"undefined\" != typeof self ? self : global,\n    x = \"undefined\" != typeof navigator,\n    C = x && \"undefined\" == typeof HTMLImageElement,\n    B = !(\"undefined\" == typeof global || \"undefined\" == typeof process || !process.versions || !process.versions.node),\n    j = U.Buffer,\n    _ = !!j;\n  var V = function (e) {\n    return void 0 !== e;\n  };\n  function I(e) {\n    return void 0 === e || (e instanceof P ? 0 === e.size : 0 === p(e).filter(V).length);\n  }\n  function L(e) {\n    var t = new Error(e);\n    throw delete t.stack, t;\n  }\n  function T(e) {\n    var t = function (e) {\n      var t = 0;\n      return e.ifd0.enabled && (t += 1024), e.exif.enabled && (t += 2048), e.makerNote && (t += 2048), e.userComment && (t += 1024), e.gps.enabled && (t += 512), e.interop.enabled && (t += 100), e.ifd1.enabled && (t += 1024), t + 2048;\n    }(e);\n    return e.jfif.enabled && (t += 50), e.xmp.enabled && (t += 2e4), e.iptc.enabled && (t += 14e3), e.icc.enabled && (t += 6e3), t;\n  }\n  var z = function (e) {\n      return String.fromCharCode.apply(null, e);\n    },\n    F = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf-8\") : void 0;\n  function E(e) {\n    return F ? F.decode(e) : _ ? Buffer.from(e).toString(\"utf8\") : decodeURIComponent(escape(z(e)));\n  }\n  var D = function () {\n    function e(n) {\n      var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n        i = arguments.length > 2 ? arguments[2] : void 0,\n        a = arguments.length > 3 ? arguments[3] : void 0;\n      if (t(this, e), \"boolean\" == typeof a && (this.le = a), Array.isArray(n) && (n = new Uint8Array(n)), 0 === n) this.byteOffset = 0, this.byteLength = 0;else if (n instanceof ArrayBuffer) {\n        void 0 === i && (i = n.byteLength - r);\n        var s = new DataView(n, r, i);\n        this._swapDataView(s);\n      } else if (n instanceof Uint8Array || n instanceof DataView || n instanceof e) {\n        void 0 === i && (i = n.byteLength - r), (r += n.byteOffset) + i > n.byteOffset + n.byteLength && L(\"Creating view outside of available memory in ArrayBuffer\");\n        var u = new DataView(n.buffer, r, i);\n        this._swapDataView(u);\n      } else if (\"number\" == typeof n) {\n        var o = new DataView(new ArrayBuffer(n));\n        this._swapDataView(o);\n      } else L(\"Invalid input argument for BufferView: \" + n);\n    }\n    return r(e, [{\n      key: \"_swapArrayBuffer\",\n      value: function (e) {\n        this._swapDataView(new DataView(e));\n      }\n    }, {\n      key: \"_swapBuffer\",\n      value: function (e) {\n        this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength));\n      }\n    }, {\n      key: \"_swapDataView\",\n      value: function (e) {\n        this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength;\n      }\n    }, {\n      key: \"_lengthToEnd\",\n      value: function (e) {\n        return this.byteLength - e;\n      }\n    }, {\n      key: \"set\",\n      value: function (t, n) {\n        var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e;\n        t instanceof DataView || t instanceof e ? t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t instanceof ArrayBuffer && (t = new Uint8Array(t)), t instanceof Uint8Array || L(\"BufferView.set(): Invalid data argument.\");\n        var i = this.toUint8();\n        return i.set(t, n), new r(this, n, t.byteLength);\n      }\n    }, {\n      key: \"subarray\",\n      value: function (t, n) {\n        return new e(this, t, n = n || this._lengthToEnd(t));\n      }\n    }, {\n      key: \"toUint8\",\n      value: function () {\n        return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);\n      }\n    }, {\n      key: \"getUint8Array\",\n      value: function (e, t) {\n        return new Uint8Array(this.buffer, this.byteOffset + e, t);\n      }\n    }, {\n      key: \"getString\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength,\n          n = this.getUint8Array(e, t);\n        return E(n);\n      }\n    }, {\n      key: \"getLatin1String\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength,\n          n = this.getUint8Array(e, t);\n        return z(n);\n      }\n    }, {\n      key: \"getUnicodeString\",\n      value: function () {\n        for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength, n = [], r = 0; r < t && e + r < this.byteLength; r += 2) n.push(this.getUint16(e + r));\n        return z(n);\n      }\n    }, {\n      key: \"getInt8\",\n      value: function (e) {\n        return this.dataView.getInt8(e);\n      }\n    }, {\n      key: \"getUint8\",\n      value: function (e) {\n        return this.dataView.getUint8(e);\n      }\n    }, {\n      key: \"getInt16\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getInt16(e, t);\n      }\n    }, {\n      key: \"getInt32\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getInt32(e, t);\n      }\n    }, {\n      key: \"getUint16\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getUint16(e, t);\n      }\n    }, {\n      key: \"getUint32\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getUint32(e, t);\n      }\n    }, {\n      key: \"getFloat32\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat32(e, t);\n      }\n    }, {\n      key: \"getFloat64\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat64(e, t);\n      }\n    }, {\n      key: \"getFloat\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat32(e, t);\n      }\n    }, {\n      key: \"getDouble\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.le;\n        return this.dataView.getFloat64(e, t);\n      }\n    }, {\n      key: \"getUintBytes\",\n      value: function (e, t, n) {\n        switch (t) {\n          case 1:\n            return this.getUint8(e, n);\n          case 2:\n            return this.getUint16(e, n);\n          case 4:\n            return this.getUint32(e, n);\n          case 8:\n            return this.getUint64 && this.getUint64(e, n);\n        }\n      }\n    }, {\n      key: \"getUint\",\n      value: function (e, t, n) {\n        switch (t) {\n          case 8:\n            return this.getUint8(e, n);\n          case 16:\n            return this.getUint16(e, n);\n          case 32:\n            return this.getUint32(e, n);\n          case 64:\n            return this.getUint64 && this.getUint64(e, n);\n        }\n      }\n    }, {\n      key: \"toString\",\n      value: function (e) {\n        return this.dataView.toString(e, this.constructor.name);\n      }\n    }, {\n      key: \"ensureChunk\",\n      value: function () {}\n    }], [{\n      key: \"from\",\n      value: function (t, n) {\n        return t instanceof this && t.le === n ? t : new e(t, void 0, void 0, n);\n      }\n    }]), e;\n  }();\n  function R(e, t) {\n    L(\"\".concat(e, \" '\").concat(t, \"' was not loaded, try using full build of exifr.\"));\n  }\n  var N = function (e) {\n      a(i, e);\n      var n = d(i);\n      function i(e) {\n        var r;\n        return t(this, i), (r = n.call(this)).kind = e, r;\n      }\n      return r(i, [{\n        key: \"get\",\n        value: function (e, t) {\n          return this.has(e) || R(this.kind, e), t && (e in t || function (e, t) {\n            L(\"Unknown \".concat(e, \" '\").concat(t, \"'.\"));\n          }(this.kind, e), t[e].enabled || R(this.kind, e)), v(s(i.prototype), \"get\", this).call(this, e);\n        }\n      }, {\n        key: \"keyList\",\n        value: function () {\n          return m(this.keys());\n        }\n      }]), i;\n    }(c(P)),\n    M = new N(\"file parser\"),\n    W = new N(\"segment parser\"),\n    K = new N(\"file reader\");\n  function H(e) {\n    return function () {\n      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];\n      try {\n        return Promise.resolve(e.apply(this, t));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n  }\n  function X(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n  var Y = H(function (e) {\n      return new Promise(function (t, n) {\n        var r = new FileReader();\n        r.onloadend = function () {\n          return t(r.result || new ArrayBuffer());\n        }, r.onerror = n, r.readAsArrayBuffer(e);\n      });\n    }),\n    G = H(function (e) {\n      return w(e).then(function (e) {\n        return e.arrayBuffer();\n      });\n    }),\n    J = H(function (e, t) {\n      return X(t(e), function (e) {\n        return new D(e);\n      });\n    }),\n    q = H(function (e, t, n) {\n      var r = new (K.get(n))(e, t);\n      return X(r.read(), function () {\n        return r;\n      });\n    }),\n    Q = H(function (e, t, n, r) {\n      return K.has(n) ? q(e, t, n) : r ? J(e, r) : (L(\"Parser \".concat(n, \" is not loaded\")), X());\n    }),\n    Z = \"Invalid input argument\";\n  function $(e, t) {\n    return (n = e).startsWith(\"data:\") || n.length > 1e4 ? q(e, t, \"base64\") : x ? Q(e, t, \"url\", G) : B ? q(e, t, \"fs\") : void L(Z);\n    var n;\n  }\n  var ee = function (e) {\n    a(i, e);\n    var n = d(i);\n    function i() {\n      return t(this, i), n.apply(this, arguments);\n    }\n    return r(i, [{\n      key: \"tagKeys\",\n      get: function () {\n        return this.allKeys || (this.allKeys = m(this.keys())), this.allKeys;\n      }\n    }, {\n      key: \"tagValues\",\n      get: function () {\n        return this.allValues || (this.allValues = m(this.values())), this.allValues;\n      }\n    }]), i;\n  }(c(P));\n  function te(e, t, n) {\n    var r = new ee(),\n      i = n;\n    Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = m(i));\n    for (var a = 0; a < i.length; a++) {\n      var s = i[a],\n        u = s[0],\n        o = s[1];\n      r.set(u, o);\n    }\n    if (Array.isArray(t)) {\n      var f = t;\n      Array.isArray(f) || (\"function\" == typeof f.entries && (f = f.entries()), f = m(f));\n      for (var c = 0; c < f.length; c++) {\n        var h = f[c];\n        e.set(h, r);\n      }\n    } else e.set(t, r);\n    return r;\n  }\n  function ne(e, t, n) {\n    var r,\n      i = e.get(t),\n      a = n;\n    Array.isArray(a) || (\"function\" == typeof a.entries && (a = a.entries()), a = m(a));\n    for (var s = 0; s < a.length; s++) r = a[s], i.set(r[0], r[1]);\n  }\n  var re = S(),\n    ie = S(),\n    ae = S(),\n    se = 37500,\n    ue = 37510,\n    oe = 33723,\n    fe = 34675,\n    ce = 34665,\n    he = 34853,\n    le = 40965,\n    de = [\"chunked\", \"firstChunkSize\", \"firstChunkSizeNode\", \"firstChunkSizeBrowser\", \"chunkSize\", \"chunkLimit\"],\n    ve = [\"jfif\", \"xmp\", \"icc\", \"iptc\", \"ihdr\"],\n    pe = [\"tiff\"].concat(ve),\n    ye = [\"ifd0\", \"ifd1\", \"exif\", \"gps\", \"interop\"],\n    ge = [].concat(pe, ye),\n    ke = [\"makerNote\", \"userComment\"],\n    me = [\"translateKeys\", \"translateValues\", \"reviveValues\", \"multiSegment\"],\n    be = [].concat(me, [\"sanitize\", \"mergeOutput\", \"silentErrors\"]),\n    Ae = function () {\n      function e() {\n        t(this, e);\n      }\n      return r(e, [{\n        key: \"translate\",\n        get: function () {\n          return this.translateKeys || this.translateValues || this.reviveValues;\n        }\n      }]), e;\n    }(),\n    we = function (e) {\n      a(s, e);\n      var n = d(s);\n      function s(e, r, a, u) {\n        var o;\n        if (t(this, s), i(h(o = n.call(this)), \"enabled\", !1), i(h(o), \"skip\", O()), i(h(o), \"pick\", O()), i(h(o), \"deps\", O()), i(h(o), \"translateKeys\", !1), i(h(o), \"translateValues\", !1), i(h(o), \"reviveValues\", !1), o.key = e, o.enabled = r, o.parse = o.enabled, o.applyInheritables(u), o.canBeFiltered = ye.includes(e), o.canBeFiltered && (o.dict = re.get(e)), void 0 !== a) if (Array.isArray(a)) o.parse = o.enabled = !0, o.canBeFiltered && a.length > 0 && o.translateTagSet(a, o.pick);else if (\"object\" == typeof a) {\n          if (o.enabled = !0, o.parse = !1 !== a.parse, o.canBeFiltered) {\n            var f = a.pick,\n              c = a.skip;\n            f && f.length > 0 && o.translateTagSet(f, o.pick), c && c.length > 0 && o.translateTagSet(c, o.skip);\n          }\n          o.applyInheritables(a);\n        } else !0 === a || !1 === a ? o.parse = o.enabled = a : L(\"Invalid options argument: \".concat(a));\n        return o;\n      }\n      return r(s, [{\n        key: \"needed\",\n        get: function () {\n          return this.enabled || this.deps.size > 0;\n        }\n      }, {\n        key: \"applyInheritables\",\n        value: function (e) {\n          var t,\n            n,\n            r = me;\n          Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = m(r));\n          for (var i = 0; i < r.length; i++) void 0 !== (n = e[t = r[i]]) && (this[t] = n);\n        }\n      }, {\n        key: \"translateTagSet\",\n        value: function (e, t) {\n          if (this.dict) {\n            var n,\n              r,\n              i = this.dict,\n              a = i.tagKeys,\n              s = i.tagValues,\n              u = e;\n            Array.isArray(u) || (\"function\" == typeof u.entries && (u = u.entries()), u = m(u));\n            for (var o = 0; o < u.length; o++) \"string\" == typeof (n = u[o]) ? (-1 === (r = s.indexOf(n)) && (r = a.indexOf(Number(n))), -1 !== r && t.add(Number(a[r]))) : t.add(n);\n          } else {\n            var f = e;\n            Array.isArray(f) || (\"function\" == typeof f.entries && (f = f.entries()), f = m(f));\n            for (var c = 0; c < f.length; c++) {\n              var h = f[c];\n              t.add(h);\n            }\n          }\n        }\n      }, {\n        key: \"finalizeFilters\",\n        value: function () {\n          !this.enabled && this.deps.size > 0 ? (this.enabled = !0, Ce(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && Ce(this.pick, this.deps);\n        }\n      }]), s;\n    }(Ae),\n    Oe = {\n      jfif: !1,\n      tiff: !0,\n      xmp: !1,\n      icc: !1,\n      iptc: !1,\n      ifd0: !0,\n      ifd1: !1,\n      exif: !0,\n      gps: !0,\n      interop: !1,\n      ihdr: void 0,\n      makerNote: !1,\n      userComment: !1,\n      multiSegment: !1,\n      skip: [],\n      pick: [],\n      translateKeys: !0,\n      translateValues: !0,\n      reviveValues: !0,\n      sanitize: !0,\n      mergeOutput: !0,\n      silentErrors: !0,\n      chunked: !0,\n      firstChunkSize: void 0,\n      firstChunkSizeNode: 512,\n      firstChunkSizeBrowser: 65536,\n      chunkSize: 65536,\n      chunkLimit: 5\n    },\n    Se = S(),\n    Pe = function (e) {\n      a(i, e);\n      var n = d(i);\n      function i(e) {\n        var r;\n        return t(this, i), r = n.call(this), !0 === e ? r.setupFromTrue() : void 0 === e ? r.setupFromUndefined() : Array.isArray(e) ? r.setupFromArray(e) : \"object\" == typeof e ? r.setupFromObject(e) : L(\"Invalid options argument \".concat(e)), void 0 === r.firstChunkSize && (r.firstChunkSize = x ? r.firstChunkSizeBrowser : r.firstChunkSizeNode), r.mergeOutput && (r.ifd1.enabled = !1), r.filterNestedSegmentTags(), r.traverseTiffDependencyTree(), r.checkLoadedPlugins(), r;\n      }\n      return r(i, [{\n        key: \"setupFromUndefined\",\n        value: function () {\n          var e,\n            t = de;\n          Array.isArray(t) || (\"function\" == typeof t.entries && (t = t.entries()), t = m(t));\n          for (var n = 0; n < t.length; n++) this[e = t[n]] = Oe[e];\n          var r = be;\n          Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = m(r));\n          for (var i = 0; i < r.length; i++) this[e = r[i]] = Oe[e];\n          var a = ke;\n          Array.isArray(a) || (\"function\" == typeof a.entries && (a = a.entries()), a = m(a));\n          for (var s = 0; s < a.length; s++) this[e = a[s]] = Oe[e];\n          var u = ge;\n          Array.isArray(u) || (\"function\" == typeof u.entries && (u = u.entries()), u = m(u));\n          for (var o = 0; o < u.length; o++) this[e = u[o]] = new we(e, Oe[e], void 0, this);\n        }\n      }, {\n        key: \"setupFromTrue\",\n        value: function () {\n          var e,\n            t = de;\n          Array.isArray(t) || (\"function\" == typeof t.entries && (t = t.entries()), t = m(t));\n          for (var n = 0; n < t.length; n++) this[e = t[n]] = Oe[e];\n          var r = be;\n          Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = m(r));\n          for (var i = 0; i < r.length; i++) this[e = r[i]] = Oe[e];\n          var a = ke;\n          Array.isArray(a) || (\"function\" == typeof a.entries && (a = a.entries()), a = m(a));\n          for (var s = 0; s < a.length; s++) this[e = a[s]] = !0;\n          var u = ge;\n          Array.isArray(u) || (\"function\" == typeof u.entries && (u = u.entries()), u = m(u));\n          for (var o = 0; o < u.length; o++) this[e = u[o]] = new we(e, !0, void 0, this);\n        }\n      }, {\n        key: \"setupFromArray\",\n        value: function (e) {\n          var t,\n            n = de;\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n          for (var r = 0; r < n.length; r++) this[t = n[r]] = Oe[t];\n          var i = be;\n          Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = m(i));\n          for (var a = 0; a < i.length; a++) this[t = i[a]] = Oe[t];\n          var s = ke;\n          Array.isArray(s) || (\"function\" == typeof s.entries && (s = s.entries()), s = m(s));\n          for (var u = 0; u < s.length; u++) this[t = s[u]] = Oe[t];\n          var o = ge;\n          Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = m(o));\n          for (var f = 0; f < o.length; f++) this[t = o[f]] = new we(t, !1, void 0, this);\n          this.setupGlobalFilters(e, void 0, ye);\n        }\n      }, {\n        key: \"setupFromObject\",\n        value: function (e) {\n          var t;\n          ye.ifd0 = ye.ifd0 || ye.image, ye.ifd1 = ye.ifd1 || ye.thumbnail, g(this, e);\n          var n = de;\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n          for (var r = 0; r < n.length; r++) this[t = n[r]] = xe(e[t], Oe[t]);\n          var i = be;\n          Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = m(i));\n          for (var a = 0; a < i.length; a++) this[t = i[a]] = xe(e[t], Oe[t]);\n          var s = ke;\n          Array.isArray(s) || (\"function\" == typeof s.entries && (s = s.entries()), s = m(s));\n          for (var u = 0; u < s.length; u++) this[t = s[u]] = xe(e[t], Oe[t]);\n          var o = pe;\n          Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = m(o));\n          for (var f = 0; f < o.length; f++) this[t = o[f]] = new we(t, Oe[t], e[t], this);\n          var c = ye;\n          Array.isArray(c) || (\"function\" == typeof c.entries && (c = c.entries()), c = m(c));\n          for (var h = 0; h < c.length; h++) this[t = c[h]] = new we(t, Oe[t], e[t], this.tiff);\n          this.setupGlobalFilters(e.pick, e.skip, ye, ge), !0 === e.tiff ? this.batchEnableWithBool(ye, !0) : !1 === e.tiff ? this.batchEnableWithUserValue(ye, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, ye) : \"object\" == typeof e.tiff && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, ye);\n        }\n      }, {\n        key: \"batchEnableWithBool\",\n        value: function (e, t) {\n          var n = e;\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n          for (var r = 0; r < n.length; r++) {\n            this[n[r]].enabled = t;\n          }\n        }\n      }, {\n        key: \"batchEnableWithUserValue\",\n        value: function (e, t) {\n          var n = e;\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n          for (var r = 0; r < n.length; r++) {\n            var i = n[r],\n              a = t[i];\n            this[i].enabled = !1 !== a && void 0 !== a;\n          }\n        }\n      }, {\n        key: \"setupGlobalFilters\",\n        value: function (e, t, n) {\n          var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : n;\n          if (e && e.length) {\n            var i = r;\n            Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = m(i));\n            for (var a = 0; a < i.length; a++) {\n              var s = i[a];\n              this[s].enabled = !1;\n            }\n            var u = Ue(e, n),\n              o = u;\n            Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = m(o));\n            for (var f = 0; f < o.length; f++) {\n              var c = o[f],\n                h = c[0],\n                l = c[1];\n              Ce(this[h].pick, l), this[h].enabled = !0;\n            }\n          } else if (t && t.length) {\n            var d = Ue(t, n),\n              v = d;\n            Array.isArray(v) || (\"function\" == typeof v.entries && (v = v.entries()), v = m(v));\n            for (var p = 0; p < v.length; p++) {\n              var y = v[p],\n                g = y[0],\n                k = y[1];\n              Ce(this[g].skip, k);\n            }\n          }\n        }\n      }, {\n        key: \"filterNestedSegmentTags\",\n        value: function () {\n          var e = this.ifd0,\n            t = this.exif,\n            n = this.xmp,\n            r = this.iptc,\n            i = this.icc;\n          this.makerNote ? t.deps.add(se) : t.skip.add(se), this.userComment ? t.deps.add(ue) : t.skip.add(ue), n.enabled || e.skip.add(700), r.enabled || e.skip.add(oe), i.enabled || e.skip.add(fe);\n        }\n      }, {\n        key: \"traverseTiffDependencyTree\",\n        value: function () {\n          var e = this,\n            t = this.ifd0,\n            n = this.exif,\n            r = this.gps;\n          this.interop.needed && (n.deps.add(le), t.deps.add(le)), n.needed && t.deps.add(ce), r.needed && t.deps.add(he), this.tiff.enabled = ye.some(function (t) {\n            return !0 === e[t].enabled;\n          }) || this.makerNote || this.userComment;\n          var i = ye;\n          Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = m(i));\n          for (var a = 0; a < i.length; a++) {\n            this[i[a]].finalizeFilters();\n          }\n        }\n      }, {\n        key: \"onlyTiff\",\n        get: function () {\n          var e = this;\n          return !ve.map(function (t) {\n            return e[t].enabled;\n          }).some(function (e) {\n            return !0 === e;\n          }) && this.tiff.enabled;\n        }\n      }, {\n        key: \"checkLoadedPlugins\",\n        value: function () {\n          var e = pe;\n          Array.isArray(e) || (\"function\" == typeof e.entries && (e = e.entries()), e = m(e));\n          for (var t = 0; t < e.length; t++) {\n            var n = e[t];\n            this[n].enabled && !W.has(n) && R(\"segment parser\", n);\n          }\n        }\n      }], [{\n        key: \"useCached\",\n        value: function (e) {\n          var t = Se.get(e);\n          return void 0 !== t || (t = new this(e), Se.set(e, t)), t;\n        }\n      }]), i;\n    }(Ae);\n  function Ue(e, t) {\n    var n,\n      r,\n      i,\n      a = [],\n      s = t;\n    Array.isArray(s) || (\"function\" == typeof s.entries && (s = s.entries()), s = m(s));\n    for (var u = 0; u < s.length; u++) {\n      r = s[u], n = [];\n      var o = re.get(r);\n      Array.isArray(o) || (\"function\" == typeof o.entries && (o = o.entries()), o = m(o));\n      for (var f = 0; f < o.length; f++) i = o[f], (e.includes(i[0]) || e.includes(i[1])) && n.push(i[0]);\n      n.length && a.push([r, n]);\n    }\n    return a;\n  }\n  function xe(e, t) {\n    return void 0 !== e ? e : void 0 !== t ? t : void 0;\n  }\n  function Ce(e, t) {\n    var n = t;\n    Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n    for (var r = 0; r < n.length; r++) {\n      var i = n[r];\n      e.add(i);\n    }\n  }\n  function Be(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n  function je() {}\n  function _e(e, t) {\n    if (!t) return e && e.then ? e.then(je) : Promise.resolve();\n  }\n  function Ve(e, t) {\n    var n = e();\n    return n && n.then ? n.then(t) : t(n);\n  }\n  i(Pe, \"default\", Oe);\n  var Ie = function () {\n    function e(n) {\n      t(this, e), i(this, \"parsers\", {}), this.options = Pe.useCached(n);\n    }\n    return r(e, [{\n      key: \"setup\",\n      value: function () {\n        if (!this.fileParser) {\n          var e = this.file,\n            t = e.getUint16(0),\n            n = M;\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n          for (var r = 0; r < n.length; r++) {\n            var i = n[r],\n              a = i[0],\n              s = i[1];\n            if (s.canHandle(e, t)) return this.fileParser = new s(this.options, this.file, this.parsers), e[a] = !0;\n          }\n          L(\"Unknown file format\");\n        }\n      }\n    }, {\n      key: \"read\",\n      value: function (e) {\n        try {\n          var t = this;\n          return Be(function (e, t) {\n            return \"string\" == typeof e ? $(e, t) : x && !C && e instanceof HTMLImageElement ? $(e.src, t) : e instanceof Uint8Array || e instanceof ArrayBuffer || e instanceof DataView ? new D(e) : x && e instanceof Blob ? Q(e, t, \"blob\", Y) : void L(Z);\n          }(e, t.options), function (e) {\n            t.file = e;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parse\",\n      value: function () {\n        try {\n          var e = this;\n          e.setup();\n          var t = {},\n            n = [];\n          return Ve(function () {\n            return e.options.silentErrors ? Be(e.doParse(t, n).catch(function (e) {\n              return n.push(e);\n            }), function () {\n              n.push.apply(n, e.fileParser.errors);\n            }) : _e(e.doParse(t, n));\n          }, function () {\n            return e.file.close && e.file.close(), e.options.silentErrors && n.length > 0 && (t.errors = n), I(r = t) ? void 0 : r;\n            var r;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"doParse\",\n      value: function (e, t) {\n        try {\n          var n = this;\n          return Be(n.fileParser.parse(), function () {\n            var r,\n              i = p(n.parsers).map((r = function (t) {\n                return Be(t.parse(), function (n) {\n                  t.assignToOutput(e, n);\n                });\n              }, function () {\n                for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];\n                try {\n                  return Promise.resolve(r.apply(this, e));\n                } catch (e) {\n                  return Promise.reject(e);\n                }\n              }));\n            if (n.options.silentErrors) {\n              var a = function (e) {\n                return t.push(e);\n              };\n              i = i.map(function (e) {\n                return e.catch(a);\n              });\n            }\n            return _e(Promise.all(i));\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"extractThumbnail\",\n      value: function () {\n        try {\n          var e = this;\n          e.setup();\n          var t,\n            n = e.options,\n            r = e.file,\n            i = W.get(\"tiff\", n);\n          return Ve(function () {\n            if (!r.tiff) return function (e) {\n              var t = e();\n              if (t && t.then) return t.then(je);\n            }(function () {\n              if (r.jpeg) return Be(e.fileParser.getOrFindSegment(\"tiff\"), function (e) {\n                t = e;\n              });\n            });\n            t = {\n              start: 0,\n              type: \"tiff\"\n            };\n          }, function () {\n            if (void 0 !== t) return Be(e.fileParser.ensureSegmentChunk(t), function (t) {\n              return Be((e.parsers.tiff = new i(t, n, r)).extractThumbnail(), function (e) {\n                return r.close && r.close(), e;\n              });\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }]), e;\n  }();\n  var Le,\n    Te = (Le = function (e, t) {\n      var n,\n        r,\n        i,\n        a = new Ie(t);\n      return n = a.read(e), r = function () {\n        return a.parse();\n      }, i ? r ? r(n) : n : (n && n.then || (n = Promise.resolve(n)), r ? n.then(r) : n);\n    }, function () {\n      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];\n      try {\n        return Promise.resolve(Le.apply(this, e));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }),\n    ze = Object.freeze({\n      __proto__: null,\n      parse: Te,\n      Exifr: Ie,\n      fileParsers: M,\n      segmentParsers: W,\n      fileReaders: K,\n      tagKeys: re,\n      tagValues: ie,\n      tagRevivers: ae,\n      createDictionary: te,\n      extendDictionary: ne,\n      fetchUrlAsArrayBuffer: G,\n      readBlobAsArrayBuffer: Y,\n      chunkedProps: de,\n      otherSegments: ve,\n      segments: pe,\n      tiffBlocks: ye,\n      segmentsAndBlocks: ge,\n      tiffExtractables: ke,\n      inheritables: me,\n      allFormatters: be,\n      Options: Pe\n    });\n  function Fe() {}\n  var Ee = function () {\n      function e(n, r, a) {\n        var s = this;\n        t(this, e), i(this, \"errors\", []), i(this, \"ensureSegmentChunk\", function (e) {\n          return function () {\n            for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];\n            try {\n              return Promise.resolve(e.apply(this, t));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          };\n        }(function (e) {\n          var t,\n            n,\n            r,\n            i = e.start,\n            a = e.size || 65536;\n          return t = function () {\n            if (s.file.chunked) return function (e) {\n              var t = e();\n              if (t && t.then) return t.then(Fe);\n            }(function () {\n              if (!s.file.available(i, a)) return function (e) {\n                if (e && e.then) return e.then(Fe);\n              }(function (e, t) {\n                try {\n                  var n = e();\n                } catch (e) {\n                  return t(e);\n                }\n                return n && n.then ? n.then(void 0, t) : n;\n              }(function () {\n                return t = s.file.readChunk(i, a), n = function (t) {\n                  e.chunk = t;\n                }, r ? n ? n(t) : t : (t && t.then || (t = Promise.resolve(t)), n ? t.then(n) : t);\n                var t, n, r;\n              }, function (t) {\n                L(\"Couldn't read segment: \".concat(JSON.stringify(e), \". \").concat(t.message));\n              }));\n              e.chunk = s.file.subarray(i, a);\n            });\n            s.file.byteLength > i + a ? e.chunk = s.file.subarray(i, a) : void 0 === e.size ? e.chunk = s.file.subarray(i) : L(\"Segment unreachable: \" + JSON.stringify(e));\n          }, n = function () {\n            return e.chunk;\n          }, (r = t()) && r.then ? r.then(n) : n(r);\n        })), this.extendOptions && this.extendOptions(n), this.options = n, this.file = r, this.parsers = a;\n      }\n      return r(e, [{\n        key: \"injectSegment\",\n        value: function (e, t) {\n          this.options[e].enabled && this.createParser(e, t);\n        }\n      }, {\n        key: \"createParser\",\n        value: function (e, t) {\n          var n = new (W.get(e))(t, this.options, this.file);\n          return this.parsers[e] = n;\n        }\n      }, {\n        key: \"createParsers\",\n        value: function (e) {\n          var t = e;\n          Array.isArray(t) || (\"function\" == typeof t.entries && (t = t.entries()), t = m(t));\n          for (var n = 0; n < t.length; n++) {\n            var r = t[n],\n              i = r.type,\n              a = r.chunk,\n              s = this.options[i];\n            if (s && s.enabled) {\n              var u = this.parsers[i];\n              u && u.append || u || this.createParser(i, a);\n            }\n          }\n        }\n      }, {\n        key: \"readSegments\",\n        value: function (e) {\n          try {\n            var t = e.map(this.ensureSegmentChunk);\n            return function (e, t) {\n              if (!t) return e && e.then ? e.then(Fe) : Promise.resolve();\n            }(Promise.all(t));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n      }]), e;\n    }(),\n    De = function () {\n      function e(n) {\n        var r = this,\n          a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          s = arguments.length > 2 ? arguments[2] : void 0;\n        t(this, e), i(this, \"errors\", []), i(this, \"raw\", S()), i(this, \"handleError\", function (e) {\n          if (!r.options.silentErrors) throw e;\n          r.errors.push(e.message);\n        }), this.chunk = this.normalizeInput(n), this.file = s, this.type = this.constructor.type, this.globalOptions = this.options = a, this.localOptions = a[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;\n      }\n      return r(e, [{\n        key: \"normalizeInput\",\n        value: function (e) {\n          return e instanceof D ? e : new D(e);\n        }\n      }, {\n        key: \"translate\",\n        value: function () {\n          this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));\n        }\n      }, {\n        key: \"output\",\n        get: function () {\n          return this.translated ? this.translated : this.raw ? k(this.raw) : void 0;\n        }\n      }, {\n        key: \"translateBlock\",\n        value: function (e, t) {\n          var n = ae.get(t),\n            r = ie.get(t),\n            i = re.get(t),\n            a = this.options[t],\n            s = a.reviveValues && !!n,\n            u = a.translateValues && !!r,\n            o = a.translateKeys && !!i,\n            f = {},\n            c = e;\n          Array.isArray(c) || (\"function\" == typeof c.entries && (c = c.entries()), c = m(c));\n          for (var h = 0; h < c.length; h++) {\n            var l = c[h],\n              d = l[0],\n              v = l[1];\n            s && n.has(d) ? v = n.get(d)(v) : u && r.has(d) && (v = this.translateValue(v, r.get(d))), o && i.has(d) && (d = i.get(d) || d), f[d] = v;\n          }\n          return f;\n        }\n      }, {\n        key: \"translateValue\",\n        value: function (e, t) {\n          return t[e] || t.DEFAULT || e;\n        }\n      }, {\n        key: \"assignToOutput\",\n        value: function (e, t) {\n          this.assignObjectToOutput(e, this.constructor.type, t);\n        }\n      }, {\n        key: \"assignObjectToOutput\",\n        value: function (e, t, n) {\n          if (this.globalOptions.mergeOutput) return g(e, n);\n          e[t] ? g(e[t], n) : e[t] = n;\n        }\n      }], [{\n        key: \"findPosition\",\n        value: function (e, t) {\n          var n = e.getUint16(t + 2) + 2,\n            r = \"function\" == typeof this.headerLength ? this.headerLength(e, t, n) : this.headerLength,\n            i = t + r,\n            a = n - r;\n          return {\n            offset: t,\n            length: n,\n            headerLength: r,\n            start: i,\n            size: a,\n            end: i + a\n          };\n        }\n      }, {\n        key: \"parse\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n            n = new Pe(i({}, this.type, t)),\n            r = new this(e, n);\n          return r.parse();\n        }\n      }]), e;\n    }();\n  function Re(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n  i(De, \"headerLength\", 4), i(De, \"type\", void 0), i(De, \"multiSegment\", !1), i(De, \"canHandle\", function () {\n    return !1;\n  });\n  function Ne() {}\n  function Me(e, t) {\n    if (!t) return e && e.then ? e.then(Ne) : Promise.resolve();\n  }\n  function We(e) {\n    var t = e();\n    if (t && t.then) return t.then(Ne);\n  }\n  function Ke(e, t) {\n    var n = e();\n    return n && n.then ? n.then(t) : t(n);\n  }\n  function He(e, t, n) {\n    if (!e.s) {\n      if (n instanceof Xe) {\n        if (!n.s) return void (n.o = He.bind(null, e, t));\n        1 & t && (t = n.s), n = n.v;\n      }\n      if (n && n.then) return void n.then(He.bind(null, e, t), He.bind(null, e, 2));\n      e.s = t, e.v = n;\n      var r = e.o;\n      r && r(e);\n    }\n  }\n  var Xe = function () {\n    function e() {}\n    return e.prototype.then = function (t, n) {\n      var r = new e(),\n        i = this.s;\n      if (i) {\n        var a = 1 & i ? t : n;\n        if (a) {\n          try {\n            He(r, 1, a(this.v));\n          } catch (e) {\n            He(r, 2, e);\n          }\n          return r;\n        }\n        return this;\n      }\n      return this.o = function (e) {\n        try {\n          var i = e.v;\n          1 & e.s ? He(r, 1, t ? t(i) : i) : n ? He(r, 1, n(i)) : He(r, 2, i);\n        } catch (e) {\n          He(r, 2, e);\n        }\n      }, r;\n    }, e;\n  }();\n  function Ye(e) {\n    return e instanceof Xe && 1 & e.s;\n  }\n  function Ge(e, t, n) {\n    for (var r;;) {\n      var i = e();\n      if (Ye(i) && (i = i.v), !i) return a;\n      if (i.then) {\n        r = 0;\n        break;\n      }\n      var a = n();\n      if (a && a.then) {\n        if (!Ye(a)) {\n          r = 1;\n          break;\n        }\n        a = a.s;\n      }\n      if (t) {\n        var s = t();\n        if (s && s.then && !Ye(s)) {\n          r = 2;\n          break;\n        }\n      }\n    }\n    var u = new Xe(),\n      o = He.bind(null, u, 2);\n    return (0 === r ? i.then(c) : 1 === r ? a.then(f) : s.then(h)).then(void 0, o), u;\n    function f(r) {\n      a = r;\n      do {\n        if (t && (s = t()) && s.then && !Ye(s)) return void s.then(h).then(void 0, o);\n        if (!(i = e()) || Ye(i) && !i.v) return void He(u, 1, a);\n        if (i.then) return void i.then(c).then(void 0, o);\n        Ye(a = n()) && (a = a.v);\n      } while (!a || !a.then);\n      a.then(f).then(void 0, o);\n    }\n    function c(e) {\n      e ? (a = n()) && a.then ? a.then(f).then(void 0, o) : f(a) : He(u, 1, a);\n    }\n    function h() {\n      (i = e()) ? i.then ? i.then(c).then(void 0, o) : c(i) : He(u, 1, a);\n    }\n  }\n  function Je(e) {\n    return 192 === e || 194 === e || 196 === e || 219 === e || 221 === e || 218 === e || 254 === e;\n  }\n  function qe(e) {\n    return e >= 224 && e <= 239;\n  }\n  function Qe(e, t, n) {\n    var r = W;\n    Array.isArray(r) || (\"function\" == typeof r.entries && (r = r.entries()), r = m(r));\n    for (var i = 0; i < r.length; i++) {\n      var a = r[i],\n        s = a[0];\n      if (a[1].canHandle(e, t, n)) return s;\n    }\n  }\n  var Ze = function (e) {\n    a(s, e);\n    var n = d(s);\n    function s() {\n      var e;\n      t(this, s);\n      for (var r = arguments.length, a = new Array(r), u = 0; u < r; u++) a[u] = arguments[u];\n      return i(h(e = n.call.apply(n, [this].concat(a))), \"appSegments\", []), i(h(e), \"jpegSegments\", []), i(h(e), \"unknownSegments\", []), e;\n    }\n    return r(s, [{\n      key: \"parse\",\n      value: function () {\n        try {\n          var e = this;\n          return Re(e.findAppSegments(), function () {\n            return Re(e.readSegments(e.appSegments), function () {\n              e.mergeMultiSegments(), e.createParsers(e.mergedAppSegments || e.appSegments);\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"setupSegmentFinderArgs\",\n      value: function (e) {\n        var t = this;\n        !0 === e ? (this.findAll = !0, this.wanted = O(W.keyList())) : (e = void 0 === e ? W.keyList().filter(function (e) {\n          return t.options[e].enabled;\n        }) : e.filter(function (e) {\n          return t.options[e].enabled && W.has(e);\n        }), this.findAll = !1, this.remaining = O(e), this.wanted = O(e)), this.unfinishedMultiSegment = !1;\n      }\n    }, {\n      key: \"findAppSegments\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,\n          t = arguments.length > 1 ? arguments[1] : void 0;\n        try {\n          var n = this;\n          n.setupSegmentFinderArgs(t);\n          var r = n.file,\n            i = n.findAll,\n            a = n.wanted,\n            s = n.remaining;\n          return Ke(function () {\n            if (!i && n.file.chunked) return i = m(a).some(function (e) {\n              var t = W.get(e),\n                r = n.options[e];\n              return t.multiSegment && r.multiSegment;\n            }), We(function () {\n              if (i) return Me(n.file.readWhole());\n            });\n          }, function () {\n            var t = !1;\n            if (e = n.findAppSegmentsInRange(e, r.byteLength), !n.options.onlyTiff) return function () {\n              if (r.chunked) {\n                var i = !1;\n                return Ge(function () {\n                  return !t && s.size > 0 && !i && (!!r.canReadNextChunk || !!n.unfinishedMultiSegment);\n                }, void 0, function () {\n                  var a = r.nextChunkOffset,\n                    s = n.appSegments.some(function (e) {\n                      return !n.file.available(e.offset || e.start, e.length || e.size);\n                    });\n                  return Ke(function () {\n                    return e > a && !s ? Re(r.readNextChunk(e), function (e) {\n                      i = !e;\n                    }) : Re(r.readNextChunk(a), function (e) {\n                      i = !e;\n                    });\n                  }, function () {\n                    void 0 === (e = n.findAppSegmentsInRange(e, r.byteLength)) && (t = !0);\n                  });\n                });\n              }\n            }();\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"findAppSegmentsInRange\",\n      value: function (e, t) {\n        t -= 2;\n        for (var n, r, i, a, s, u, o = this.file, f = this.findAll, c = this.wanted, h = this.remaining, l = this.options; e < t; e++) if (255 === o.getUint8(e)) if (qe(n = o.getUint8(e + 1))) {\n          if (r = o.getUint16(e + 2), (i = Qe(o, e, r)) && c.has(i) && (s = (a = W.get(i)).findPosition(o, e), u = l[i], s.type = i, this.appSegments.push(s), !f && (a.multiSegment && u.multiSegment ? (this.unfinishedMultiSegment = s.chunkNumber < s.chunkCount, this.unfinishedMultiSegment || h.delete(i)) : h.delete(i), 0 === h.size))) break;\n          l.recordUnknownSegments && ((s = De.findPosition(o, e)).marker = n, this.unknownSegments.push(s)), e += r + 1;\n        } else if (Je(n)) {\n          if (r = o.getUint16(e + 2), 218 === n && !1 !== l.stopAfterSos) return;\n          l.recordJpegSegments && this.jpegSegments.push({\n            offset: e,\n            length: r,\n            marker: n\n          }), e += r + 1;\n        }\n        return e;\n      }\n    }, {\n      key: \"mergeMultiSegments\",\n      value: function () {\n        var e = this;\n        if (this.appSegments.some(function (e) {\n          return e.multiSegment;\n        })) {\n          var t = function (e, t) {\n            for (var n, r, i, a = S(), s = 0; s < e.length; s++) r = (n = e[s])[t], a.has(r) ? i = a.get(r) : a.set(r, i = []), i.push(n);\n            return m(a);\n          }(this.appSegments, \"type\");\n          this.mergedAppSegments = t.map(function (t) {\n            var n = t[0],\n              r = t[1],\n              i = W.get(n, e.options);\n            return i.handleMultiSegments ? {\n              type: n,\n              chunk: i.handleMultiSegments(r)\n            } : r[0];\n          });\n        }\n      }\n    }, {\n      key: \"getSegment\",\n      value: function (e) {\n        return this.appSegments.find(function (t) {\n          return t.type === e;\n        });\n      }\n    }, {\n      key: \"getOrFindSegment\",\n      value: function (e) {\n        try {\n          var t = this,\n            n = t.getSegment(e);\n          return Ke(function () {\n            if (void 0 === n) return Re(t.findAppSegments(0, [e]), function () {\n              n = t.getSegment(e);\n            });\n          }, function () {\n            return n;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }], [{\n      key: \"canHandle\",\n      value: function (e, t) {\n        return 65496 === t;\n      }\n    }]), s;\n  }(Ee);\n  function $e() {}\n  i(Ze, \"type\", \"jpeg\"), M.set(\"jpeg\", Ze);\n  function et(e, t) {\n    if (!t) return e && e.then ? e.then($e) : Promise.resolve();\n  }\n  function tt(e, t) {\n    var n = e();\n    return n && n.then ? n.then(t) : t(n);\n  }\n  var nt = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];\n  var rt = function (e) {\n    a(i, e);\n    var n = d(i);\n    function i() {\n      return t(this, i), n.apply(this, arguments);\n    }\n    return r(i, [{\n      key: \"parse\",\n      value: function () {\n        try {\n          var e = this;\n          e.parseHeader();\n          var t = e.options;\n          return tt(function () {\n            if (t.ifd0.enabled) return et(e.parseIfd0Block());\n          }, function () {\n            return tt(function () {\n              if (t.exif.enabled) return et(e.safeParse(\"parseExifBlock\"));\n            }, function () {\n              return tt(function () {\n                if (t.gps.enabled) return et(e.safeParse(\"parseGpsBlock\"));\n              }, function () {\n                return tt(function () {\n                  if (t.interop.enabled) return et(e.safeParse(\"parseInteropBlock\"));\n                }, function () {\n                  return tt(function () {\n                    if (t.ifd1.enabled) return et(e.safeParse(\"parseThumbnailBlock\"));\n                  }, function () {\n                    return e.createOutput();\n                  });\n                });\n              });\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"safeParse\",\n      value: function (e) {\n        var t = this[e]();\n        return void 0 !== t.catch && (t = t.catch(this.handleError)), t;\n      }\n    }, {\n      key: \"findIfd0Offset\",\n      value: function () {\n        void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));\n      }\n    }, {\n      key: \"findIfd1Offset\",\n      value: function () {\n        if (void 0 === this.ifd1Offset) {\n          this.findIfd0Offset();\n          var e = this.chunk.getUint16(this.ifd0Offset),\n            t = this.ifd0Offset + 2 + 12 * e;\n          this.ifd1Offset = this.chunk.getUint32(t);\n        }\n      }\n    }, {\n      key: \"parseBlock\",\n      value: function (e, t) {\n        var n = S();\n        return this[t] = n, this.parseTags(e, t, n), n;\n      }\n    }, {\n      key: \"parseIfd0Block\",\n      value: function () {\n        try {\n          var e = this;\n          if (e.ifd0) return;\n          var t = e.file;\n          return e.findIfd0Offset(), e.ifd0Offset < 8 && L(\"Malformed EXIF data\"), !t.chunked && e.ifd0Offset > t.byteLength && L(\"IFD0 offset points to outside of file.\\nthis.ifd0Offset: \".concat(e.ifd0Offset, \", file.byteLength: \").concat(t.byteLength)), tt(function () {\n            if (t.tiff) return et(t.ensureChunk(e.ifd0Offset, T(e.options)));\n          }, function () {\n            var t = e.parseBlock(e.ifd0Offset, \"ifd0\");\n            if (0 !== t.size) return e.exifOffset = t.get(ce), e.interopOffset = t.get(le), e.gpsOffset = t.get(he), e.xmp = t.get(700), e.iptc = t.get(oe), e.icc = t.get(fe), e.options.sanitize && (t.delete(ce), t.delete(le), t.delete(he), t.delete(700), t.delete(oe), t.delete(fe)), t;\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parseExifBlock\",\n      value: function () {\n        try {\n          var e = this;\n          if (e.exif) return;\n          return tt(function () {\n            if (!e.ifd0) return et(e.parseIfd0Block());\n          }, function () {\n            if (void 0 !== e.exifOffset) return tt(function () {\n              if (e.file.tiff) return et(e.file.ensureChunk(e.exifOffset, T(e.options)));\n            }, function () {\n              var t = e.parseBlock(e.exifOffset, \"exif\");\n              return e.interopOffset || (e.interopOffset = t.get(le)), e.makerNote = t.get(se), e.userComment = t.get(ue), e.options.sanitize && (t.delete(le), t.delete(se), t.delete(ue)), e.unpack(t, 41728), e.unpack(t, 41729), t;\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"unpack\",\n      value: function (e, t) {\n        var n = e.get(t);\n        n && 1 === n.length && e.set(t, n[0]);\n      }\n    }, {\n      key: \"parseGpsBlock\",\n      value: function () {\n        try {\n          var e = this;\n          if (e.gps) return;\n          return tt(function () {\n            if (!e.ifd0) return et(e.parseIfd0Block());\n          }, function () {\n            if (void 0 !== e.gpsOffset) {\n              var t = e.parseBlock(e.gpsOffset, \"gps\");\n              return t && t.has(2) && t.has(4) && (t.set(\"latitude\", it.apply(void 0, t.get(2).concat([t.get(1)]))), t.set(\"longitude\", it.apply(void 0, t.get(4).concat([t.get(3)])))), t;\n            }\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parseInteropBlock\",\n      value: function () {\n        try {\n          var e = this;\n          if (e.interop) return;\n          return tt(function () {\n            if (!e.ifd0) return et(e.parseIfd0Block());\n          }, function () {\n            return tt(function () {\n              if (void 0 === e.interopOffset && !e.exif) return et(e.parseExifBlock());\n            }, function () {\n              if (void 0 !== e.interopOffset) return e.parseBlock(e.interopOffset, \"interop\");\n            });\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"parseThumbnailBlock\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n        try {\n          var t = this;\n          if (t.ifd1 || t.ifd1Parsed) return;\n          if (t.options.mergeOutput && !e) return;\n          return t.findIfd1Offset(), t.ifd1Offset > 0 && (t.parseBlock(t.ifd1Offset, \"ifd1\"), t.ifd1Parsed = !0), t.ifd1;\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"extractThumbnail\",\n      value: function () {\n        try {\n          var e = this;\n          return e.headerParsed || e.parseHeader(), tt(function () {\n            if (!e.ifd1Parsed) return et(e.parseThumbnailBlock(!0));\n          }, function () {\n            if (void 0 !== e.ifd1) {\n              var t = e.ifd1.get(513),\n                n = e.ifd1.get(514);\n              return e.chunk.getUint8Array(t, n);\n            }\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"image\",\n      get: function () {\n        return this.ifd0;\n      }\n    }, {\n      key: \"thumbnail\",\n      get: function () {\n        return this.ifd1;\n      }\n    }, {\n      key: \"createOutput\",\n      value: function () {\n        var e,\n          t,\n          n,\n          r = {},\n          i = ye;\n        Array.isArray(i) || (\"function\" == typeof i.entries && (i = i.entries()), i = m(i));\n        for (var a = 0; a < i.length; a++) if (!I(e = this[t = i[a]])) if (n = this.canTranslate ? this.translateBlock(e, t) : k(e), this.options.mergeOutput) {\n          if (\"ifd1\" === t) continue;\n          g(r, n);\n        } else r[t] = n;\n        return this.makerNote && (r.makerNote = this.makerNote), this.userComment && (r.userComment = this.userComment), r;\n      }\n    }, {\n      key: \"assignToOutput\",\n      value: function (e, t) {\n        if (this.globalOptions.mergeOutput) g(e, t);else {\n          var n = y(t);\n          Array.isArray(n) || (\"function\" == typeof n.entries && (n = n.entries()), n = m(n));\n          for (var r = 0; r < n.length; r++) {\n            var i = n[r],\n              a = i[0],\n              s = i[1];\n            this.assignObjectToOutput(e, a, s);\n          }\n        }\n      }\n    }], [{\n      key: \"canHandle\",\n      value: function (e, t) {\n        return 225 === e.getUint8(t + 1) && 1165519206 === e.getUint32(t + 4) && 0 === e.getUint16(t + 8);\n      }\n    }]), i;\n  }(function (e) {\n    a(i, e);\n    var n = d(i);\n    function i() {\n      return t(this, i), n.apply(this, arguments);\n    }\n    return r(i, [{\n      key: \"parseHeader\",\n      value: function () {\n        var e = this.chunk.getUint16();\n        18761 === e ? this.le = !0 : 19789 === e && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0;\n      }\n    }, {\n      key: \"parseTags\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : S(),\n          r = this.options[t],\n          i = r.pick,\n          a = r.skip,\n          s = (i = O(i)).size > 0,\n          u = 0 === a.size,\n          o = this.chunk.getUint16(e);\n        e += 2;\n        for (var f = 0; f < o; f++) {\n          var c = this.chunk.getUint16(e);\n          if (s) {\n            if (i.has(c) && (n.set(c, this.parseTag(e, c, t)), i.delete(c), 0 === i.size)) break;\n          } else !u && a.has(c) || n.set(c, this.parseTag(e, c, t));\n          e += 12;\n        }\n        return n;\n      }\n    }, {\n      key: \"parseTag\",\n      value: function (e, t, n) {\n        var r,\n          i = this.chunk,\n          a = i.getUint16(e + 2),\n          s = i.getUint32(e + 4),\n          u = nt[a];\n        if (u * s <= 4 ? e += 8 : e = i.getUint32(e + 8), (a < 1 || a > 13) && L(\"Invalid TIFF value type. block: \".concat(n.toUpperCase(), \", tag: \").concat(t.toString(16), \", type: \").concat(a, \", offset \").concat(e)), e > i.byteLength && L(\"Invalid TIFF value offset. block: \".concat(n.toUpperCase(), \", tag: \").concat(t.toString(16), \", type: \").concat(a, \", offset \").concat(e, \" is outside of chunk size \").concat(i.byteLength)), 1 === a) return i.getUint8Array(e, s);\n        if (2 === a) return \"\" === (r = function (e) {\n          for (; e.endsWith(\"\\0\");) e = e.slice(0, -1);\n          return e;\n        }(r = i.getString(e, s)).trim()) ? void 0 : r;\n        if (7 === a) return i.getUint8Array(e, s);\n        if (1 === s) return this.parseTagValue(a, e);\n        for (var o = new (function (e) {\n            switch (e) {\n              case 1:\n                return Uint8Array;\n              case 3:\n                return Uint16Array;\n              case 4:\n                return Uint32Array;\n              case 5:\n                return Array;\n              case 6:\n                return Int8Array;\n              case 8:\n                return Int16Array;\n              case 9:\n                return Int32Array;\n              case 10:\n                return Array;\n              case 11:\n                return Float32Array;\n              case 12:\n                return Float64Array;\n              default:\n                return Array;\n            }\n          }(a))(s), f = u, c = 0; c < s; c++) o[c] = this.parseTagValue(a, e), e += f;\n        return o;\n      }\n    }, {\n      key: \"parseTagValue\",\n      value: function (e, t) {\n        var n = this.chunk;\n        switch (e) {\n          case 1:\n            return n.getUint8(t);\n          case 3:\n            return n.getUint16(t);\n          case 4:\n            return n.getUint32(t);\n          case 5:\n            return n.getUint32(t) / n.getUint32(t + 4);\n          case 6:\n            return n.getInt8(t);\n          case 8:\n            return n.getInt16(t);\n          case 9:\n            return n.getInt32(t);\n          case 10:\n            return n.getInt32(t) / n.getInt32(t + 4);\n          case 11:\n            return n.getFloat(t);\n          case 12:\n            return n.getDouble(t);\n          case 13:\n            return n.getUint32(t);\n          default:\n            L(\"Invalid tiff type \".concat(e));\n        }\n      }\n    }]), i;\n  }(De));\n  function it(e, t, n, r) {\n    var i = e + t / 60 + n / 3600;\n    return \"S\" !== r && \"W\" !== r || (i *= -1), i;\n  }\n  i(rt, \"type\", \"tiff\"), i(rt, \"headerLength\", 10), W.set(\"tiff\", rt);\n  var at = Object.freeze({\n    __proto__: null,\n    default: ze,\n    Exifr: Ie,\n    fileParsers: M,\n    segmentParsers: W,\n    fileReaders: K,\n    tagKeys: re,\n    tagValues: ie,\n    tagRevivers: ae,\n    createDictionary: te,\n    extendDictionary: ne,\n    fetchUrlAsArrayBuffer: G,\n    readBlobAsArrayBuffer: Y,\n    chunkedProps: de,\n    otherSegments: ve,\n    segments: pe,\n    tiffBlocks: ye,\n    segmentsAndBlocks: ge,\n    tiffExtractables: ke,\n    inheritables: me,\n    allFormatters: be,\n    Options: Pe,\n    parse: Te\n  });\n  function st(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n  function ut(e) {\n    return function () {\n      for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];\n      try {\n        return Promise.resolve(e.apply(this, t));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    };\n  }\n  var ot = ut(function (e) {\n      var t = new Ie(vt);\n      return st(t.read(e), function () {\n        return st(t.parse(), function (e) {\n          if (e && e.ifd0) return e.ifd0[274];\n        });\n      });\n    }),\n    ft = ut(function (e) {\n      var t = new Ie(dt);\n      return st(t.read(e), function () {\n        return st(t.parse(), function (e) {\n          if (e && e.gps) {\n            var t = e.gps;\n            return {\n              latitude: t.latitude,\n              longitude: t.longitude\n            };\n          }\n        });\n      });\n    }),\n    ct = ut(function (e) {\n      return st(this.thumbnail(e), function (e) {\n        if (void 0 !== e) {\n          var t = new Blob([e]);\n          return URL.createObjectURL(t);\n        }\n      });\n    }),\n    ht = ut(function (e) {\n      var t = new Ie(pt);\n      return st(t.read(e), function () {\n        return st(t.extractThumbnail(), function (e) {\n          return e && _ ? j.from(e) : e;\n        });\n      });\n    }),\n    lt = {\n      ifd0: !1,\n      ifd1: !1,\n      exif: !1,\n      gps: !1,\n      interop: !1,\n      sanitize: !1,\n      reviveValues: !0,\n      translateKeys: !1,\n      translateValues: !1,\n      mergeOutput: !1\n    },\n    dt = g({}, lt, {\n      firstChunkSize: 4e4,\n      gps: [1, 2, 3, 4]\n    }),\n    vt = g({}, lt, {\n      firstChunkSize: 4e4,\n      ifd0: [274]\n    }),\n    pt = g({}, lt, {\n      tiff: !1,\n      ifd1: !0,\n      mergeOutput: !1\n    }),\n    yt = Object.freeze({\n      1: {\n        dimensionSwapped: !1,\n        scaleX: 1,\n        scaleY: 1,\n        deg: 0,\n        rad: 0\n      },\n      2: {\n        dimensionSwapped: !1,\n        scaleX: -1,\n        scaleY: 1,\n        deg: 0,\n        rad: 0\n      },\n      3: {\n        dimensionSwapped: !1,\n        scaleX: 1,\n        scaleY: 1,\n        deg: 180,\n        rad: 180 * Math.PI / 180\n      },\n      4: {\n        dimensionSwapped: !1,\n        scaleX: -1,\n        scaleY: 1,\n        deg: 180,\n        rad: 180 * Math.PI / 180\n      },\n      5: {\n        dimensionSwapped: !0,\n        scaleX: 1,\n        scaleY: -1,\n        deg: 90,\n        rad: 90 * Math.PI / 180\n      },\n      6: {\n        dimensionSwapped: !0,\n        scaleX: 1,\n        scaleY: 1,\n        deg: 90,\n        rad: 90 * Math.PI / 180\n      },\n      7: {\n        dimensionSwapped: !0,\n        scaleX: 1,\n        scaleY: -1,\n        deg: 270,\n        rad: 270 * Math.PI / 180\n      },\n      8: {\n        dimensionSwapped: !0,\n        scaleX: 1,\n        scaleY: 1,\n        deg: 270,\n        rad: 270 * Math.PI / 180\n      }\n    });\n  if (e.rotateCanvas = !0, e.rotateCss = !0, \"object\" == typeof navigator) {\n    var gt = navigator.userAgent;\n    if (gt.includes(\"iPad\") || gt.includes(\"iPhone\")) {\n      var kt = gt.match(/OS (\\d+)_(\\d+)/);\n      if (kt) {\n        var mt = kt[1],\n          bt = kt[2],\n          At = Number(mt) + .1 * Number(bt);\n        e.rotateCanvas = At < 13.4, e.rotateCss = !1;\n      }\n    } else if (gt.includes(\"OS X 10\")) {\n      var wt = gt.match(/OS X 10[_.](\\d+)/)[1];\n      e.rotateCanvas = e.rotateCss = Number(wt) < 15;\n    }\n    if (gt.includes(\"Chrome/\")) {\n      var Ot = gt.match(/Chrome\\/(\\d+)/)[1];\n      e.rotateCanvas = e.rotateCss = Number(Ot) < 81;\n    } else if (gt.includes(\"Firefox/\")) {\n      var St = gt.match(/Firefox\\/(\\d+)/)[1];\n      e.rotateCanvas = e.rotateCss = Number(St) < 77;\n    }\n  }\n  function Pt() {}\n  var Ut = function (e) {\n      a(u, e);\n      var n = d(u);\n      function u() {\n        var e;\n        t(this, u);\n        for (var r = arguments.length, a = new Array(r), s = 0; s < r; s++) a[s] = arguments[s];\n        return i(h(e = n.call.apply(n, [this].concat(a))), \"ranges\", new xt()), 0 !== e.byteLength && e.ranges.add(0, e.byteLength), e;\n      }\n      return r(u, [{\n        key: \"_tryExtend\",\n        value: function (e, t, n) {\n          if (0 === e && 0 === this.byteLength && n) {\n            var r = new DataView(n.buffer || n, n.byteOffset, n.byteLength);\n            this._swapDataView(r);\n          } else {\n            var i = e + t;\n            if (i > this.byteLength) {\n              var a = this._extend(i).dataView;\n              this._swapDataView(a);\n            }\n          }\n        }\n      }, {\n        key: \"_extend\",\n        value: function (e) {\n          var t;\n          t = _ ? j.allocUnsafe(e) : new Uint8Array(e);\n          var n = new DataView(t.buffer, t.byteOffset, t.byteLength);\n          return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), {\n            uintView: t,\n            dataView: n\n          };\n        }\n      }, {\n        key: \"subarray\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n          return t = t || this._lengthToEnd(e), n && this._tryExtend(e, t), this.ranges.add(e, t), v(s(u.prototype), \"subarray\", this).call(this, e, t);\n        }\n      }, {\n        key: \"set\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n          n && this._tryExtend(t, e.byteLength, e);\n          var r = v(s(u.prototype), \"set\", this).call(this, e, t);\n          return this.ranges.add(t, r.byteLength), r;\n        }\n      }, {\n        key: \"ensureChunk\",\n        value: function (e, t) {\n          try {\n            var n = this;\n            if (!n.chunked) return;\n            if (n.ranges.available(e, t)) return;\n            return function (e, t) {\n              if (!t) return e && e.then ? e.then(Pt) : Promise.resolve();\n            }(n.readChunk(e, t));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n      }, {\n        key: \"available\",\n        value: function (e, t) {\n          return this.ranges.available(e, t);\n        }\n      }]), u;\n    }(D),\n    xt = function () {\n      function e() {\n        t(this, e), i(this, \"list\", []);\n      }\n      return r(e, [{\n        key: \"length\",\n        get: function () {\n          return this.list.length;\n        }\n      }, {\n        key: \"add\",\n        value: function (e, t) {\n          var n = e + t,\n            r = this.list.filter(function (t) {\n              return Ct(e, t.offset, n) || Ct(e, t.end, n);\n            });\n          if (r.length > 0) {\n            e = Math.min.apply(Math, [e].concat(r.map(function (e) {\n              return e.offset;\n            }))), t = (n = Math.max.apply(Math, [n].concat(r.map(function (e) {\n              return e.end;\n            })))) - e;\n            var i = r.shift();\n            i.offset = e, i.length = t, i.end = n, this.list = this.list.filter(function (e) {\n              return !r.includes(e);\n            });\n          } else this.list.push({\n            offset: e,\n            length: t,\n            end: n\n          });\n        }\n      }, {\n        key: \"available\",\n        value: function (e, t) {\n          var n = e + t;\n          return this.list.some(function (t) {\n            return t.offset <= e && n <= t.end;\n          });\n        }\n      }]), e;\n    }();\n  function Ct(e, t, n) {\n    return e <= t && t <= n;\n  }\n  function Bt() {}\n  function jt(e, t) {\n    if (!t) return e && e.then ? e.then(Bt) : Promise.resolve();\n  }\n  function _t(e, t, n) {\n    return n ? t ? t(e) : e : (e && e.then || (e = Promise.resolve(e)), t ? e.then(t) : e);\n  }\n  var Vt = function (e) {\n    a(i, e);\n    var n = d(i);\n    function i() {\n      return t(this, i), n.apply(this, arguments);\n    }\n    return r(i, [{\n      key: \"readWhole\",\n      value: function () {\n        try {\n          var e = this;\n          return e.chunked = !1, _t(Y(e.input), function (t) {\n            e._swapArrayBuffer(t);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readChunked\",\n      value: function () {\n        return this.chunked = !0, this.size = this.input.size, v(s(i.prototype), \"readChunked\", this).call(this);\n      }\n    }, {\n      key: \"_readChunk\",\n      value: function (e, t) {\n        try {\n          var n = this,\n            r = t ? e + t : void 0,\n            i = n.input.slice(e, r);\n          return _t(Y(i), function (t) {\n            return n.set(t, e, !0);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }]), i;\n  }(function (e) {\n    a(s, e);\n    var n = d(s);\n    function s(e, r) {\n      var a;\n      return t(this, s), i(h(a = n.call(this, 0)), \"chunksRead\", 0), a.input = e, a.options = r, a;\n    }\n    return r(s, [{\n      key: \"readWhole\",\n      value: function () {\n        try {\n          var e = this;\n          return e.chunked = !1, jt(e.readChunk(e.nextChunkOffset));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readChunked\",\n      value: function () {\n        try {\n          var e = this;\n          return e.chunked = !0, jt(e.readChunk(0, e.options.firstChunkSize));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"readNextChunk\",\n      value: function (e) {\n        try {\n          var t = this;\n          if (void 0 === e && (e = t.nextChunkOffset), t.fullyRead) return t.chunksRead++, !1;\n          var n = t.options.chunkSize;\n          return r = t.readChunk(e, n), i = function (e) {\n            return !!e && e.byteLength === n;\n          }, a ? i ? i(r) : r : (r && r.then || (r = Promise.resolve(r)), i ? r.then(i) : r);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n        var r, i, a;\n      }\n    }, {\n      key: \"readChunk\",\n      value: function (e, t) {\n        try {\n          var n = this;\n          if (n.chunksRead++, 0 === (t = n.safeWrapAddress(e, t))) return;\n          return n._readChunk(e, t);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n    }, {\n      key: \"safeWrapAddress\",\n      value: function (e, t) {\n        return void 0 !== this.size && e + t > this.size ? Math.max(0, this.size - e) : t;\n      }\n    }, {\n      key: \"nextChunkOffset\",\n      get: function () {\n        if (0 !== this.ranges.list.length) return this.ranges.list[0].length;\n      }\n    }, {\n      key: \"canReadNextChunk\",\n      get: function () {\n        return this.chunksRead < this.options.chunkLimit;\n      }\n    }, {\n      key: \"fullyRead\",\n      get: function () {\n        return void 0 !== this.size && this.nextChunkOffset === this.size;\n      }\n    }, {\n      key: \"read\",\n      value: function () {\n        return this.options.chunked ? this.readChunked() : this.readWhole();\n      }\n    }, {\n      key: \"close\",\n      value: function () {}\n    }]), s;\n  }(Ut));\n  K.set(\"blob\", Vt), e.Exifr = Ie, e.Options = Pe, e.allFormatters = be, e.chunkedProps = de, e.createDictionary = te, e.default = at, e.disableAllOptions = lt, e.extendDictionary = ne, e.fetchUrlAsArrayBuffer = G, e.fileParsers = M, e.fileReaders = K, e.gps = ft, e.gpsOnlyOptions = dt, e.inheritables = me, e.orientation = ot, e.orientationOnlyOptions = vt, e.otherSegments = ve, e.parse = Te, e.readBlobAsArrayBuffer = Y, e.rotation = function (t) {\n    return st(ot(t), function (t) {\n      return g({\n        canvas: e.rotateCanvas,\n        css: e.rotateCss\n      }, yt[t]);\n    });\n  }, e.rotations = yt, e.segmentParsers = W, e.segments = pe, e.segmentsAndBlocks = ge, e.tagKeys = re, e.tagRevivers = ae, e.tagValues = ie, e.thumbnail = ht, e.thumbnailOnlyOptions = pt, e.thumbnailUrl = ct, e.tiffBlocks = ye, e.tiffExtractables = ke, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}