{"ast":null,"code":"(function () {\n  // Get the html from the data attribute and insert the new fields on the container\n  // \"event\" is the click event of the link created by the rails helper\n  window.addVanillaNestedFields = function (element) {\n    if (!element.classList.contains('vanilla-nested-add')) element = element.closest('.vanilla-nested-add');\n    const data = element.dataset;\n    const container = document.querySelector(data.containerSelector);\n    const newHtml = data.html.replace(/_idx_placeholder_/g, Date.now());\n\n    // insert and store reference\n    let inserted;\n    switch (data.methodForInsert) {\n      case 'append':\n        container.insertAdjacentHTML('beforeend', newHtml);\n        inserted = container.lastElementChild;\n        break;\n      case 'prepend':\n        container.insertAdjacentHTML('afterbegin', newHtml);\n        inserted = container.firstElementChild;\n        break;\n    }\n\n    // add a class to show it was added dynamically\n    inserted.classList.add('added-by-vanilla-nested');\n    _dispatchEvent(container, 'vanilla-nested:fields-added', element, {\n      added: inserted\n    });\n\n    // dispatch an event if we reached the limit configured on the model\n    if (data.limit) {\n      let nestedElements = container.querySelectorAll('[name$=\"[_destroy]\"][value=\"0\"]').length;\n      if (nestedElements >= data.limit) _dispatchEvent(container, 'vanilla-nested:fields-limit-reached', element);\n    }\n  };\n\n  // Removes the fields or hides them until the undo timer times out\n  // \"event\" is the click event of the link created by the rails helper\n  window.removeVanillaNestedFields = function (element) {\n    if (!element.classList.contains('vanilla-nested-remove')) element = element.closest('.vanilla-nested-remove');\n    const data = element.dataset;\n    let wrapper = element.parentElement;\n    const sel = data.fieldsWrapperSelector;\n    if (sel) wrapper = element.closest(sel);\n    if (data.undoTimeout) {\n      hideFieldsWithUndo(wrapper, element);\n      _dispatchEvent(wrapper, 'vanilla-nested:fields-hidden', element);\n    } else {\n      hideWrapper(wrapper);\n      unhideFields(wrapper);\n      _dispatchEvent(wrapper, 'vanilla-nested:fields-removed', element);\n    }\n    wrapper.querySelector('[name$=\"[_destroy]\"]').value = '1';\n  };\n\n  // Hides an element, mainly the wrapper of a group of fields\n  // \"wrapper\" is the wrapper of the link to remove fields\n  function hideWrapper(wrapper) {\n    if (wrapper.classList.contains('added-by-vanilla-nested')) {\n      wrapper.remove();\n    } else {\n      const destroyInput = wrapper.querySelector('[name$=\"[_destroy]\"');\n      wrapper.innerHTML = '';\n      wrapper.insertAdjacentElement('afterbegin', destroyInput);\n    }\n  }\n\n  // Unhides the children given a fields wrapper\n  // \"wrapper\" is the wrapper of the link to remove fields\n  function unhideFields(wrapper) {\n    [...wrapper.children].forEach(child => {\n      if (child.dataset.hasAttributeStyle) {\n        child.style.display = child.dataset.originalDisplay;\n      } else {\n        child.removeAttribute(\"style\");\n      }\n    });\n  }\n\n  // Hides an element and adds an \"undo\" link to unhide it\n  // \"wrapper\" is the wrapper to hide\n  // \"element\" is the link to remove the wrapper\n  function hideFieldsWithUndo(wrapper, element) {\n    [...wrapper.children].forEach(child => {\n      // store original style for after undo\n      if (child.getAttribute(\"style\")) {\n        child.dataset.hasAttributeStyle = true;\n        child.dataset.originalDisplay = child.style.display;\n      }\n      child.style.display = 'none';\n    });\n\n    // add the 'undo' link with it's callback\n    const undoLink = _createUndoWithElementsData(element.dataset);\n    wrapper.appendChild(undoLink);\n    const _onUndoClicked = function (e) {\n      e.preventDefault();\n      clearTimeout(timer);\n      unhideFields(wrapper);\n      wrapper.querySelector('[name$=\"[_destroy]\"]').value = '0';\n      _dispatchEvent(wrapper, 'vanilla-nested:fields-hidden-undo', undoLink);\n      undoLink.remove();\n    };\n    undoLink.addEventListener('click', _onUndoClicked);\n\n    // start the timer\n    const _onTimerCompleted = function () {\n      hideWrapper(wrapper);\n      unhideFields(wrapper);\n      _dispatchEvent(wrapper, 'vanilla-nested:fields-removed', undoLink);\n      undoLink.remove();\n    };\n    let ms = element.dataset.undoTimeout;\n    let timer = setTimeout(_onTimerCompleted, ms);\n  }\n  function _dispatchEvent(element, eventName, triggeredBy, details) {\n    if (!details) details = {};\n    details.triggeredBy = triggeredBy;\n    let event = new CustomEvent(eventName, {\n      bubbles: true,\n      detail: details\n    });\n    element.dispatchEvent(event);\n  }\n  function _createUndoWithElementsData(data) {\n    const undo = document.createElement('A');\n    undo.classList.add('vanilla-nested-undo');\n    const classes = data.undoLinkClasses;\n    if (classes) undo.classList.add(...classes.split(' '));\n    undo.innerText = data.undoText;\n    return undo;\n  }\n  function initVanillaNested() {\n    document.addEventListener('click', ev => {\n      const addVanillaNested = ev.target.classList.contains('vanilla-nested-add') || ev.target.closest('.vanilla-nested-add');\n      if (addVanillaNested) {\n        ev.preventDefault();\n        addVanillaNestedFields(ev.target);\n      }\n    });\n    document.addEventListener('click', ev => {\n      const removeVanillaNested = ev.target.classList.contains('vanilla-nested-remove') || ev.target.closest('.vanilla-nested-remove');\n      if (removeVanillaNested) {\n        ev.preventDefault();\n        removeVanillaNestedFields(ev.target);\n      }\n    });\n  }\n  let vanillaNestedInitialized = false;\n  const initOnce = () => {\n    if (!vanillaNestedInitialized) {\n      vanillaNestedInitialized = true;\n      initVanillaNested();\n    }\n  };\n  if ([\"complete\", \"interactive\"].includes(document.readyState)) {\n    // if DOMContentLoaded was already fired\n    initOnce();\n  } else {\n    // else wait for it\n    document.addEventListener(\"DOMContentLoaded\", () => initOnce());\n  }\n})();","map":null,"metadata":{},"sourceType":"module"}