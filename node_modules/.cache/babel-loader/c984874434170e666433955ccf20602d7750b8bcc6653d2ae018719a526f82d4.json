{"ast":null,"code":"var _class, _temp;\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar _require = require('@uppy/core'),\n  Plugin = _require.Plugin;\nvar cuid = require('cuid');\nvar Translator = require('@uppy/utils/lib/Translator');\nvar _require2 = require('@uppy/companion-client'),\n  Provider = _require2.Provider,\n  RequestClient = _require2.RequestClient,\n  Socket = _require2.Socket;\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\nvar settle = require('@uppy/utils/lib/settle');\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\nvar ProgressTimeout = require('@uppy/utils/lib/ProgressTimeout');\nvar RateLimitedQueue = require('@uppy/utils/lib/RateLimitedQueue');\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\nvar isNetworkError = require('@uppy/utils/lib/isNetworkError');\nfunction buildResponseError(xhr, error) {\n  // No error message\n  if (!error) error = new Error('Upload error'); // Got an error message string\n\n  if (typeof error === 'string') error = new Error(error); // Got something else\n\n  if (!(error instanceof Error)) {\n    error = _extends(new Error('Upload error'), {\n      data: error\n    });\n  }\n  if (isNetworkError(xhr)) {\n    error = new NetworkError(error, xhr);\n    return error;\n  }\n  error.request = xhr;\n  return error;\n}\n/**\n * Set `data.type` in the blob to `file.meta.type`,\n * because we might have detected a more accurate file type in Uppy\n * https://stackoverflow.com/a/50875615\n *\n * @param {object} file File object with `data`, `size` and `meta` properties\n * @returns {object} blob updated with the new `type` set from `file.meta.type`\n */\n\nfunction setTypeInBlob(file) {\n  var dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n  return dataWithUpdatedType;\n}\nmodule.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {\n  _inheritsLoose(XHRUpload, _Plugin);\n  function XHRUpload(uppy, opts) {\n    var _this;\n    _this = _Plugin.call(this, uppy, opts) || this;\n    _this.type = 'uploader';\n    _this.id = _this.opts.id || 'XHRUpload';\n    _this.title = 'XHRUpload';\n    _this.defaultLocale = {\n      strings: {\n        timedOut: 'Upload stalled for %{seconds} seconds, aborting.'\n      }\n    }; // Default options\n\n    var defaultOptions = {\n      formData: true,\n      fieldName: 'files[]',\n      method: 'post',\n      metaFields: null,\n      responseUrlFieldName: 'url',\n      bundle: false,\n      headers: {},\n      timeout: 30 * 1000,\n      limit: 0,\n      withCredentials: false,\n      responseType: '',\n      /**\n       * @typedef respObj\n       * @property {string} responseText\n       * @property {number} status\n       * @property {string} statusText\n       * @property {object.<string, string>} headers\n       *\n       * @param {string} responseText the response body string\n       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)\n       */\n      getResponseData: function getResponseData(responseText, response) {\n        var parsedResponse = {};\n        try {\n          parsedResponse = JSON.parse(responseText);\n        } catch (err) {\n          console.log(err);\n        }\n        return parsedResponse;\n      },\n      /**\n       *\n       * @param {string} responseText the response body string\n       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)\n       */\n      getResponseError: function getResponseError(responseText, response) {\n        var error = new Error('Upload error');\n        if (isNetworkError(response)) {\n          error = new NetworkError(error, response);\n        }\n        return error;\n      },\n      /**\n       * Check if the response from the upload endpoint indicates that the upload was successful.\n       *\n       * @param {number} status the response status code\n       * @param {string} responseText the response body string\n       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)\n       */\n      validateStatus: function validateStatus(status, responseText, response) {\n        return status >= 200 && status < 300;\n      }\n    };\n    _this.opts = _extends({}, defaultOptions, opts);\n    _this.i18nInit();\n    _this.handleUpload = _this.handleUpload.bind(_assertThisInitialized(_this)); // Simultaneous upload limiting is shared across all uploads with this plugin.\n    // __queue is for internal Uppy use only!\n\n    if (_this.opts.__queue instanceof RateLimitedQueue) {\n      _this.requests = _this.opts.__queue;\n    } else {\n      _this.requests = new RateLimitedQueue(_this.opts.limit);\n    }\n    if (_this.opts.bundle && !_this.opts.formData) {\n      throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n    }\n    _this.uploaderEvents = Object.create(null);\n    return _this;\n  }\n  var _proto = XHRUpload.prototype;\n  _proto.setOptions = function setOptions(newOpts) {\n    _Plugin.prototype.setOptions.call(this, newOpts);\n    this.i18nInit();\n  };\n  _proto.i18nInit = function i18nInit() {\n    this.translator = new Translator([this.defaultLocale, this.uppy.locale, this.opts.locale]);\n    this.i18n = this.translator.translate.bind(this.translator);\n    this.setPluginState(); // so that UI re-renders and we see the updated locale\n  };\n\n  _proto.getOptions = function getOptions(file) {\n    var overrides = this.uppy.getState().xhrUpload;\n    var headers = this.opts.headers;\n    var opts = _extends({}, this.opts, overrides || {}, file.xhrUpload || {}, {\n      headers: {}\n    }); // Support for `headers` as a function, only in the XHRUpload settings.\n    // Options set by other plugins in Uppy state or on the files themselves are still merged in afterward.\n    //\n    // ```js\n    // headers: (file) => ({ expires: file.meta.expires })\n    // ```\n\n    if (typeof headers === 'function') {\n      opts.headers = headers(file);\n    } else {\n      _extends(opts.headers, this.opts.headers);\n    }\n    if (overrides) {\n      _extends(opts.headers, overrides.headers);\n    }\n    if (file.xhrUpload) {\n      _extends(opts.headers, file.xhrUpload.headers);\n    }\n    return opts;\n  };\n  _proto.addMetadata = function addMetadata(formData, meta, opts) {\n    var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n    : Object.keys(meta);\n    metaFields.forEach(function (item) {\n      formData.append(item, meta[item]);\n    });\n  };\n  _proto.createFormDataUpload = function createFormDataUpload(file, opts) {\n    var formPost = new FormData();\n    this.addMetadata(formPost, file.meta, opts);\n    var dataWithUpdatedType = setTypeInBlob(file);\n    if (file.name) {\n      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n    } else {\n      formPost.append(opts.fieldName, dataWithUpdatedType);\n    }\n    return formPost;\n  };\n  _proto.createBundledUpload = function createBundledUpload(files, opts) {\n    var _this2 = this;\n    var formPost = new FormData();\n    var _this$uppy$getState = this.uppy.getState(),\n      meta = _this$uppy$getState.meta;\n    this.addMetadata(formPost, meta, opts);\n    files.forEach(function (file) {\n      var opts = _this2.getOptions(file);\n      var dataWithUpdatedType = setTypeInBlob(file);\n      if (file.name) {\n        formPost.append(opts.fieldName, dataWithUpdatedType, file.name);\n      } else {\n        formPost.append(opts.fieldName, dataWithUpdatedType);\n      }\n    });\n    return formPost;\n  };\n  _proto.createBareUpload = function createBareUpload(file, opts) {\n    return file.data;\n  };\n  _proto.upload = function upload(file, current, total) {\n    var _this3 = this;\n    var opts = this.getOptions(file);\n    this.uppy.log(\"uploading \" + current + \" of \" + total);\n    return new Promise(function (resolve, reject) {\n      _this3.uppy.emit('upload-started', file);\n      var data = opts.formData ? _this3.createFormDataUpload(file, opts) : _this3.createBareUpload(file, opts);\n      var xhr = new XMLHttpRequest();\n      _this3.uploaderEvents[file.id] = new EventTracker(_this3.uppy);\n      var timer = new ProgressTimeout(opts.timeout, function () {\n        xhr.abort();\n        queuedRequest.done();\n        var error = new Error(_this3.i18n('timedOut', {\n          seconds: Math.ceil(opts.timeout / 1000)\n        }));\n        _this3.uppy.emit('upload-error', file, error);\n        reject(error);\n      });\n      var id = cuid();\n      xhr.upload.addEventListener('loadstart', function (ev) {\n        _this3.uppy.log(\"[XHRUpload] \" + id + \" started\");\n      });\n      xhr.upload.addEventListener('progress', function (ev) {\n        _this3.uppy.log(\"[XHRUpload] \" + id + \" progress: \" + ev.loaded + \" / \" + ev.total); // Begin checking for timeouts when progress starts, instead of loading,\n        // to avoid timing out requests on browser concurrency queue\n\n        timer.progress();\n        if (ev.lengthComputable) {\n          _this3.uppy.emit('upload-progress', file, {\n            uploader: _this3,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        }\n      });\n      xhr.addEventListener('load', function (ev) {\n        _this3.uppy.log(\"[XHRUpload] \" + id + \" finished\");\n        timer.done();\n        queuedRequest.done();\n        if (_this3.uploaderEvents[file.id]) {\n          _this3.uploaderEvents[file.id].remove();\n          _this3.uploaderEvents[file.id] = null;\n        }\n        if (opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n          var _body = opts.getResponseData(xhr.responseText, xhr);\n          var uploadURL = _body[opts.responseUrlFieldName];\n          var uploadResp = {\n            status: ev.target.status,\n            body: _body,\n            uploadURL: uploadURL\n          };\n          _this3.uppy.emit('upload-success', file, uploadResp);\n          if (uploadURL) {\n            _this3.uppy.log(\"Download \" + file.name + \" from \" + uploadURL);\n          }\n          return resolve(file);\n        }\n        var body = opts.getResponseData(xhr.responseText, xhr);\n        var error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        var response = {\n          status: ev.target.status,\n          body: body\n        };\n        _this3.uppy.emit('upload-error', file, error, response);\n        return reject(error);\n      });\n      xhr.addEventListener('error', function (ev) {\n        _this3.uppy.log(\"[XHRUpload] \" + id + \" errored\");\n        timer.done();\n        queuedRequest.done();\n        if (_this3.uploaderEvents[file.id]) {\n          _this3.uploaderEvents[file.id].remove();\n          _this3.uploaderEvents[file.id] = null;\n        }\n        var error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        _this3.uppy.emit('upload-error', file, error);\n        return reject(error);\n      });\n      xhr.open(opts.method.toUpperCase(), opts.endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = opts.withCredentials;\n      if (opts.responseType !== '') {\n        xhr.responseType = opts.responseType;\n      }\n      var queuedRequest = _this3.requests.run(function () {\n        // When using an authentication system like JWT, the bearer token goes as a header. This\n        // header needs to be fresh each time the token is refreshed so computing and setting the\n        // headers just before the upload starts enables this kind of authentication to work properly.\n        // Otherwise, half-way through the list of uploads the token could be stale and the upload would fail.\n        var currentOpts = _this3.getOptions(file);\n        Object.keys(currentOpts.headers).forEach(function (header) {\n          xhr.setRequestHeader(header, currentOpts.headers[header]);\n        });\n        xhr.send(data);\n        return function () {\n          timer.done();\n          xhr.abort();\n        };\n      });\n      _this3.onFileRemove(file.id, function () {\n        queuedRequest.abort();\n        reject(new Error('File removed'));\n      });\n      _this3.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n        reject(new Error('Upload cancelled'));\n      });\n    });\n  };\n  _proto.uploadRemote = function uploadRemote(file, current, total) {\n    var _this4 = this;\n    var opts = this.getOptions(file);\n    return new Promise(function (resolve, reject) {\n      _this4.uppy.emit('upload-started', file);\n      var fields = {};\n      var metaFields = Array.isArray(opts.metaFields) ? opts.metaFields // Send along all fields by default.\n      : Object.keys(file.meta);\n      metaFields.forEach(function (name) {\n        fields[name] = file.meta[name];\n      });\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this4.uppy, file.remote.providerOptions);\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        endpoint: opts.endpoint,\n        size: file.data.size,\n        fieldname: opts.fieldName,\n        metadata: fields,\n        httpMethod: opts.method,\n        useFormData: opts.formData,\n        headers: opts.headers\n      })).then(function (res) {\n        var token = res.token;\n        var host = getSocketHost(file.remote.companionUrl);\n        var socket = new Socket({\n          target: host + \"/api/\" + token,\n          autoOpen: false\n        });\n        _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n        _this4.onFileRemove(file.id, function () {\n          socket.send('pause', {});\n          queuedRequest.abort();\n          resolve(\"upload \" + file.id + \" was removed\");\n        });\n        _this4.onCancelAll(file.id, function () {\n          socket.send('pause', {});\n          queuedRequest.abort();\n          resolve(\"upload \" + file.id + \" was canceled\");\n        });\n        _this4.onRetry(file.id, function () {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        });\n        _this4.onRetryAll(file.id, function () {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        });\n        socket.on('progress', function (progressData) {\n          return emitSocketProgress(_this4, progressData, file);\n        });\n        socket.on('success', function (data) {\n          var body = opts.getResponseData(data.response.responseText, data.response);\n          var uploadURL = body[opts.responseUrlFieldName];\n          var uploadResp = {\n            status: data.response.status,\n            body: body,\n            uploadURL: uploadURL\n          };\n          _this4.uppy.emit('upload-success', file, uploadResp);\n          queuedRequest.done();\n          if (_this4.uploaderEvents[file.id]) {\n            _this4.uploaderEvents[file.id].remove();\n            _this4.uploaderEvents[file.id] = null;\n          }\n          return resolve();\n        });\n        socket.on('error', function (errData) {\n          var resp = errData.response;\n          var error = resp ? opts.getResponseError(resp.responseText, resp) : _extends(new Error(errData.error.message), {\n            cause: errData.error\n          });\n          _this4.uppy.emit('upload-error', file, error);\n          queuedRequest.done();\n          if (_this4.uploaderEvents[file.id]) {\n            _this4.uploaderEvents[file.id].remove();\n            _this4.uploaderEvents[file.id] = null;\n          }\n          reject(error);\n        });\n        var queuedRequest = _this4.requests.run(function () {\n          socket.open();\n          if (file.isPaused) {\n            socket.send('pause', {});\n          }\n          return function () {\n            return socket.close();\n          };\n        });\n      }).catch(function (err) {\n        _this4.uppy.emit('upload-error', file, err);\n        reject(err);\n      });\n    });\n  };\n  _proto.uploadBundle = function uploadBundle(files) {\n    var _this5 = this;\n    return new Promise(function (resolve, reject) {\n      var endpoint = _this5.opts.endpoint;\n      var method = _this5.opts.method;\n      var optsFromState = _this5.uppy.getState().xhrUpload;\n      var formData = _this5.createBundledUpload(files, _extends({}, _this5.opts, optsFromState || {}));\n      var xhr = new XMLHttpRequest();\n      var timer = new ProgressTimeout(_this5.opts.timeout, function () {\n        xhr.abort();\n        var error = new Error(_this5.i18n('timedOut', {\n          seconds: Math.ceil(_this5.opts.timeout / 1000)\n        }));\n        emitError(error);\n        reject(error);\n      });\n      var emitError = function emitError(error) {\n        files.forEach(function (file) {\n          _this5.uppy.emit('upload-error', file, error);\n        });\n      };\n      xhr.upload.addEventListener('loadstart', function (ev) {\n        _this5.uppy.log('[XHRUpload] started uploading bundle');\n        timer.progress();\n      });\n      xhr.upload.addEventListener('progress', function (ev) {\n        timer.progress();\n        if (!ev.lengthComputable) return;\n        files.forEach(function (file) {\n          _this5.uppy.emit('upload-progress', file, {\n            uploader: _this5,\n            bytesUploaded: ev.loaded / ev.total * file.size,\n            bytesTotal: file.size\n          });\n        });\n      });\n      xhr.addEventListener('load', function (ev) {\n        timer.done();\n        if (_this5.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n          var body = _this5.opts.getResponseData(xhr.responseText, xhr);\n          var uploadResp = {\n            status: ev.target.status,\n            body: body\n          };\n          files.forEach(function (file) {\n            _this5.uppy.emit('upload-success', file, uploadResp);\n          });\n          return resolve();\n        }\n        var error = _this5.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        error.request = xhr;\n        emitError(error);\n        return reject(error);\n      });\n      xhr.addEventListener('error', function (ev) {\n        timer.done();\n        var error = _this5.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        emitError(error);\n        return reject(error);\n      });\n      _this5.uppy.on('cancel-all', function () {\n        timer.done();\n        xhr.abort();\n      });\n      xhr.open(method.toUpperCase(), endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = _this5.opts.withCredentials;\n      if (_this5.opts.responseType !== '') {\n        xhr.responseType = _this5.opts.responseType;\n      }\n      Object.keys(_this5.opts.headers).forEach(function (header) {\n        xhr.setRequestHeader(header, _this5.opts.headers[header]);\n      });\n      xhr.send(formData);\n      files.forEach(function (file) {\n        _this5.uppy.emit('upload-started', file);\n      });\n    });\n  };\n  _proto.uploadFiles = function uploadFiles(files) {\n    var _this6 = this;\n    var promises = files.map(function (file, i) {\n      var current = parseInt(i, 10) + 1;\n      var total = files.length;\n      if (file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n      if (file.isRemote) {\n        return _this6.uploadRemote(file, current, total);\n      }\n      return _this6.upload(file, current, total);\n    });\n    return settle(promises);\n  };\n  _proto.onFileRemove = function onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  };\n  _proto.onRetry = function onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  };\n  _proto.onRetryAll = function onRetryAll(fileID, cb) {\n    var _this7 = this;\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this7.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto.onCancelAll = function onCancelAll(fileID, cb) {\n    var _this8 = this;\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this8.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto.handleUpload = function handleUpload(fileIDs) {\n    var _this9 = this;\n    if (fileIDs.length === 0) {\n      this.uppy.log('[XHRUpload] No files to upload!');\n      return Promise.resolve();\n    } // no limit configured by the user, and no RateLimitedQueue passed in by a \"parent\" plugin (basically just AwsS3) using the top secret `__queue` option\n\n    if (this.opts.limit === 0 && !this.opts.__queue) {\n      this.uppy.log('[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0', 'warning');\n    }\n    this.uppy.log('[XHRUpload] Uploading...');\n    var files = fileIDs.map(function (fileID) {\n      return _this9.uppy.getFile(fileID);\n    });\n    if (this.opts.bundle) {\n      // if bundle: true, we don’t support remote uploads\n      var isSomeFileRemote = files.some(function (file) {\n        return file.isRemote;\n      });\n      if (isSomeFileRemote) {\n        throw new Error('Can’t upload remote files when the `bundle: true` option is set');\n      }\n      if (typeof this.opts.headers === 'function') {\n        throw new TypeError('`headers` may not be a function when the `bundle: true` option is set');\n      }\n      return this.uploadBundle(files);\n    }\n    return this.uploadFiles(files).then(function () {\n      return null;\n    });\n  };\n  _proto.install = function install() {\n    if (this.opts.bundle) {\n      var _this$uppy$getState2 = this.uppy.getState(),\n        capabilities = _this$uppy$getState2.capabilities;\n      this.uppy.setState({\n        capabilities: _extends({}, capabilities, {\n          individualCancellation: false\n        })\n      });\n    }\n    this.uppy.addUploader(this.handleUpload);\n  };\n  _proto.uninstall = function uninstall() {\n    if (this.opts.bundle) {\n      var _this$uppy$getState3 = this.uppy.getState(),\n        capabilities = _this$uppy$getState3.capabilities;\n      this.uppy.setState({\n        capabilities: _extends({}, capabilities, {\n          individualCancellation: true\n        })\n      });\n    }\n    this.uppy.removeUploader(this.handleUpload);\n  };\n  return XHRUpload;\n}(Plugin), _class.VERSION = \"1.7.5\", _temp);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}