{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nvar io = requireSocketIo;\nvar Emitter = require('component-emitter');\nvar has = require('@uppy/utils/lib/hasProperty');\nvar parseUrl = require('./parseUrl');\nvar NetworkError = require('@uppy/utils/lib/NetworkError');\nvar fetchWithNetworkError = require('@uppy/utils/lib/fetchWithNetworkError'); // Lazy load socket.io to avoid a console error\n// in IE 10 when the Transloadit plugin is not used.\n// (The console.error call comes from `buffer`. I\n// think we actually don't use that part of socket.io\n// at all…)\n\nvar socketIo;\nfunction requireSocketIo() {\n  if (!socketIo) {\n    socketIo = require('socket.io-client');\n  }\n  return socketIo;\n}\nvar ASSEMBLY_UPLOADING = 'ASSEMBLY_UPLOADING';\nvar ASSEMBLY_EXECUTING = 'ASSEMBLY_EXECUTING';\nvar ASSEMBLY_COMPLETED = 'ASSEMBLY_COMPLETED';\nvar statusOrder = [ASSEMBLY_UPLOADING, ASSEMBLY_EXECUTING, ASSEMBLY_COMPLETED];\n/**\n * Check that an assembly status is equal to or larger than some desired status.\n * It checks for things that are larger so that a comparison like this works,\n * when the old assembly status is UPLOADING but the new is FINISHED:\n *\n * !isStatus(oldStatus, ASSEMBLY_EXECUTING) && isStatus(newState, ASSEMBLY_EXECUTING)\n *\n * …so that we can emit the 'executing' event even if the execution step was so\n * fast that we missed it.\n */\n\nfunction isStatus(status, test) {\n  return statusOrder.indexOf(status) >= statusOrder.indexOf(test);\n}\nvar TransloaditAssembly = /*#__PURE__*/function (_Emitter) {\n  _inheritsLoose(TransloaditAssembly, _Emitter);\n  function TransloaditAssembly(assembly) {\n    var _this;\n    _this = _Emitter.call(this) || this; // The current assembly status.\n\n    _this.status = assembly; // The socket.io connection.\n\n    _this.socket = null; // The interval timer for full status updates.\n\n    _this.pollInterval = null; // Whether this assembly has been closed (finished or errored)\n\n    _this.closed = false;\n    return _this;\n  }\n  var _proto = TransloaditAssembly.prototype;\n  _proto.connect = function connect() {\n    this._connectSocket();\n    this._beginPolling();\n  };\n  _proto._onFinished = function _onFinished() {\n    this.emit('finished');\n    this.close();\n  };\n  _proto._connectSocket = function _connectSocket() {\n    var _this2 = this;\n    var parsed = parseUrl(this.status.websocket_url);\n    var socket = io().connect(parsed.origin, {\n      transports: ['websocket'],\n      path: parsed.pathname\n    });\n    socket.on('connect', function () {\n      socket.emit('assembly_connect', {\n        id: _this2.status.assembly_id\n      });\n      _this2.emit('connect');\n    });\n    socket.on('connect_failed', function () {\n      _this2._onError(new NetworkError('Transloadit Socket.io connection error'));\n      _this2.socket = null;\n    });\n    socket.on('error', function () {\n      socket.disconnect();\n      _this2.socket = null;\n    });\n    socket.on('assembly_finished', function () {\n      _this2._onFinished();\n    });\n    socket.on('assembly_upload_finished', function (file) {\n      _this2.emit('upload', file);\n      _this2.status.uploads.push(file);\n    });\n    socket.on('assembly_uploading_finished', function () {\n      _this2.emit('executing');\n    });\n    socket.on('assembly_upload_meta_data_extracted', function () {\n      _this2.emit('metadata');\n      _this2._fetchStatus({\n        diff: false\n      });\n    });\n    socket.on('assembly_result_finished', function (stepName, result) {\n      _this2.emit('result', stepName, result);\n      if (!_this2.status.results[stepName]) {\n        _this2.status.results[stepName] = [];\n      }\n      _this2.status.results[stepName].push(result);\n    });\n    socket.on('assembly_error', function (err) {\n      _this2._onError(err); // Refetch for updated status code\n\n      _this2._fetchStatus({\n        diff: false\n      });\n    });\n    this.socket = socket;\n  };\n  _proto._onError = function _onError(err) {\n    this.emit('error', _extends(new Error(err.message), err));\n  }\n  /**\n   * Begin polling for assembly status changes. This sends a request to the\n   * assembly status endpoint every so often, if the socket is not connected.\n   * If the socket connection fails or takes a long time, we won't miss any\n   * events.\n   */;\n\n  _proto._beginPolling = function _beginPolling() {\n    var _this3 = this;\n    this.pollInterval = setInterval(function () {\n      if (!_this3.socket || !_this3.socket.connected) {\n        _this3._fetchStatus();\n      }\n    }, 2000);\n  }\n  /**\n   * Reload assembly status. Useful if the socket doesn't work.\n   *\n   * Pass `diff: false` to avoid emitting diff events, instead only emitting\n   * 'status'.\n   */;\n\n  _proto._fetchStatus = function _fetchStatus(_temp) {\n    var _this4 = this;\n    var _ref = _temp === void 0 ? {} : _temp,\n      _ref$diff = _ref.diff,\n      diff = _ref$diff === void 0 ? true : _ref$diff;\n    return fetchWithNetworkError(this.status.assembly_ssl_url).then(function (response) {\n      return response.json();\n    }).then(function (status) {\n      // Avoid updating if we closed during this request's lifetime.\n      if (_this4.closed) return;\n      _this4.emit('status', status);\n      if (diff) {\n        _this4.updateStatus(status);\n      } else {\n        _this4.status = status;\n      }\n    }).catch(function (err) {\n      return _this4._onError(err);\n    });\n  };\n  _proto.update = function update() {\n    return this._fetchStatus({\n      diff: true\n    });\n  }\n  /**\n   * Update this assembly's status with a full new object. Events will be\n   * emitted for status changes, new files, and new results.\n   *\n   * @param {object} next The new assembly status object.\n   */;\n\n  _proto.updateStatus = function updateStatus(next) {\n    this._diffStatus(this.status, next);\n    this.status = next;\n  }\n  /**\n   * Diff two assembly statuses, and emit the events necessary to go from `prev`\n   * to `next`.\n   *\n   * @param {object} prev The previous assembly status.\n   * @param {object} next The new assembly status.\n   */;\n\n  _proto._diffStatus = function _diffStatus(prev, next) {\n    var _this5 = this;\n    var prevStatus = prev.ok;\n    var nextStatus = next.ok;\n    if (next.error && !prev.error) {\n      return this._onError(next);\n    } // Desired emit order:\n    //  - executing\n    //  - (n × upload)\n    //  - metadata\n    //  - (m × result)\n    //  - finished\n    // The below checks run in this order, that way even if we jump from\n    // UPLOADING straight to FINISHED all the events are emitted as expected.\n\n    var nowExecuting = isStatus(nextStatus, ASSEMBLY_EXECUTING) && !isStatus(prevStatus, ASSEMBLY_EXECUTING);\n    if (nowExecuting) {\n      // Without WebSockets, this is our only way to tell if uploading finished.\n      // Hence, we emit this just before the 'upload's and before the 'metadata'\n      // event for the most intuitive ordering, corresponding to the _usual_\n      // ordering (if not guaranteed) that you'd get on the WebSocket.\n      this.emit('executing');\n    } // Find new uploaded files.\n\n    Object.keys(next.uploads).filter(function (upload) {\n      return !has(prev.uploads, upload);\n    }).map(function (upload) {\n      return next.uploads[upload];\n    }).forEach(function (upload) {\n      _this5.emit('upload', upload);\n    });\n    if (nowExecuting) {\n      this.emit('metadata');\n    } // Find new results.\n\n    Object.keys(next.results).forEach(function (stepName) {\n      var nextResults = next.results[stepName];\n      var prevResults = prev.results[stepName];\n      nextResults.filter(function (n) {\n        return !prevResults || !prevResults.some(function (p) {\n          return p.id === n.id;\n        });\n      }).forEach(function (result) {\n        _this5.emit('result', stepName, result);\n      });\n    });\n    if (isStatus(nextStatus, ASSEMBLY_COMPLETED) && !isStatus(prevStatus, ASSEMBLY_COMPLETED)) {\n      this.emit('finished');\n    }\n  }\n  /**\n   * Stop updating this assembly.\n   */;\n\n  _proto.close = function close() {\n    this.closed = true;\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    clearInterval(this.pollInterval);\n  };\n  return TransloaditAssembly;\n}(Emitter);\nmodule.exports = TransloaditAssembly;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}