{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport BasePlugin from '@uppy/core/lib/BasePlugin.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { Provider, RequestClient, Socket } from '@uppy/companion-client';\nimport emitSocketProgress from '@uppy/utils/lib/emitSocketProgress';\nimport getSocketHost from '@uppy/utils/lib/getSocketHost';\nimport settle from '@uppy/utils/lib/settle';\nimport EventTracker from '@uppy/utils/lib/EventTracker';\nimport ProgressTimeout from '@uppy/utils/lib/ProgressTimeout';\nimport { RateLimitedQueue, internalRateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue';\nimport NetworkError from '@uppy/utils/lib/NetworkError';\nimport isNetworkError from '@uppy/utils/lib/isNetworkError';\nconst packageJson = {\n  \"version\": \"3.0.4\"\n};\nimport locale from './locale.js';\nfunction buildResponseError(xhr, err) {\n  let error = err; // No error message\n\n  if (!error) error = new Error('Upload error'); // Got an error message string\n\n  if (typeof error === 'string') error = new Error(error); // Got something else\n\n  if (!(error instanceof Error)) {\n    error = Object.assign(new Error('Upload error'), {\n      data: error\n    });\n  }\n  if (isNetworkError(xhr)) {\n    error = new NetworkError(error, xhr);\n    return error;\n  }\n  error.request = xhr;\n  return error;\n}\n/**\n * Set `data.type` in the blob to `file.meta.type`,\n * because we might have detected a more accurate file type in Uppy\n * https://stackoverflow.com/a/50875615\n *\n * @param {object} file File object with `data`, `size` and `meta` properties\n * @returns {object} blob updated with the new `type` set from `file.meta.type`\n */\n\nfunction setTypeInBlob(file) {\n  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n  return dataWithUpdatedType;\n}\nvar _queueRequestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"queueRequestSocketToken\");\nvar _requestSocketToken = /*#__PURE__*/_classPrivateFieldLooseKey(\"requestSocketToken\");\nexport default class XHRUpload extends BasePlugin {\n  // eslint-disable-next-line global-require\n  constructor(uppy, _opts) {\n    super(uppy, _opts);\n    Object.defineProperty(this, _queueRequestSocketToken, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _requestSocketToken, {\n      writable: true,\n      value: async file => {\n        const opts = this.getOptions(file);\n        const Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n        const client = new Client(this.uppy, file.remote.providerOptions);\n        const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields // Send along all fields by default.\n        : Object.keys(file.meta);\n        const res = await client.post(file.remote.url, _objectSpread(_objectSpread({}, file.remote.body), {}, {\n          protocol: 'multipart',\n          endpoint: opts.endpoint,\n          size: file.data.size,\n          fieldname: opts.fieldName,\n          metadata: Object.fromEntries(allowedMetaFields.map(name => [name, file.meta[name]])),\n          httpMethod: opts.method,\n          useFormData: opts.formData,\n          headers: opts.headers\n        }));\n        return res.token;\n      }\n    });\n    this.type = 'uploader';\n    this.id = this.opts.id || 'XHRUpload';\n    this.title = 'XHRUpload';\n    this.defaultLocale = locale; // Default options\n\n    const defaultOptions = {\n      formData: true,\n      fieldName: _opts.bundle ? 'files[]' : 'file',\n      method: 'post',\n      allowedMetaFields: null,\n      responseUrlFieldName: 'url',\n      bundle: false,\n      headers: {},\n      timeout: 30 * 1000,\n      limit: 5,\n      withCredentials: false,\n      responseType: '',\n      /**\n       * @param {string} responseText the response body string\n       */\n      getResponseData(responseText) {\n        let parsedResponse = {};\n        try {\n          parsedResponse = JSON.parse(responseText);\n        } catch (err) {\n          uppy.log(err);\n        }\n        return parsedResponse;\n      },\n      /**\n       *\n       * @param {string} _ the response body string\n       * @param {XMLHttpRequest | respObj} response the response object (XHR or similar)\n       */\n      getResponseError(_, response) {\n        let error = new Error('Upload error');\n        if (isNetworkError(response)) {\n          error = new NetworkError(error, response);\n        }\n        return error;\n      },\n      /**\n       * Check if the response from the upload endpoint indicates that the upload was successful.\n       *\n       * @param {number} status the response status code\n       */\n      validateStatus(status) {\n        return status >= 200 && status < 300;\n      }\n    };\n    this.opts = _objectSpread(_objectSpread({}, defaultOptions), _opts);\n    this.i18nInit();\n    this.handleUpload = this.handleUpload.bind(this); // Simultaneous upload limiting is shared across all uploads with this plugin.\n\n    if (internalRateLimitedQueue in this.opts) {\n      this.requests = this.opts[internalRateLimitedQueue];\n    } else {\n      this.requests = new RateLimitedQueue(this.opts.limit);\n    }\n    if (this.opts.bundle && !this.opts.formData) {\n      throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n    }\n    if ((_opts == null ? void 0 : _opts.allowedMetaFields) === undefined && 'metaFields' in this.opts) {\n      throw new Error('The `metaFields` option has been renamed to `allowedMetaFields`.');\n    }\n    this.uploaderEvents = Object.create(null);\n    _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken] = this.requests.wrapPromiseFunction(_classPrivateFieldLooseBase(this, _requestSocketToken)[_requestSocketToken], {\n      priority: -1\n    });\n  }\n  getOptions(file) {\n    const overrides = this.uppy.getState().xhrUpload;\n    const headers = this.opts.headers;\n    const opts = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.opts), overrides || {}), file.xhrUpload || {}), {}, {\n      headers: {}\n    }); // Support for `headers` as a function, only in the XHRUpload settings.\n    // Options set by other plugins in Uppy state or on the files themselves are still merged in afterward.\n    //\n    // ```js\n    // headers: (file) => ({ expires: file.meta.expires })\n    // ```\n\n    if (typeof headers === 'function') {\n      opts.headers = headers(file);\n    } else {\n      Object.assign(opts.headers, this.opts.headers);\n    }\n    if (overrides) {\n      Object.assign(opts.headers, overrides.headers);\n    }\n    if (file.xhrUpload) {\n      Object.assign(opts.headers, file.xhrUpload.headers);\n    }\n    return opts;\n  } // eslint-disable-next-line class-methods-use-this\n\n  addMetadata(formData, meta, opts) {\n    const allowedMetaFields = Array.isArray(opts.allowedMetaFields) ? opts.allowedMetaFields : Object.keys(meta); // Send along all fields by default.\n\n    allowedMetaFields.forEach(item => {\n      formData.append(item, meta[item]);\n    });\n  }\n  createFormDataUpload(file, opts) {\n    const formPost = new FormData();\n    this.addMetadata(formPost, file.meta, opts);\n    const dataWithUpdatedType = setTypeInBlob(file);\n    if (file.name) {\n      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n    } else {\n      formPost.append(opts.fieldName, dataWithUpdatedType);\n    }\n    return formPost;\n  }\n  createBundledUpload(files, opts) {\n    const formPost = new FormData();\n    const _this$uppy$getState = this.uppy.getState(),\n      meta = _this$uppy$getState.meta;\n    this.addMetadata(formPost, meta, opts);\n    files.forEach(file => {\n      const options = this.getOptions(file);\n      const dataWithUpdatedType = setTypeInBlob(file);\n      if (file.name) {\n        formPost.append(options.fieldName, dataWithUpdatedType, file.name);\n      } else {\n        formPost.append(options.fieldName, dataWithUpdatedType);\n      }\n    });\n    return formPost;\n  }\n  upload(file, current, total) {\n    const opts = this.getOptions(file);\n    this.uppy.log(`uploading ${current} of ${total}`);\n    return new Promise((resolve, reject) => {\n      this.uppy.emit('upload-started', file);\n      const data = opts.formData ? this.createFormDataUpload(file, opts) : file.data;\n      const xhr = new XMLHttpRequest();\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest;\n      const timer = new ProgressTimeout(opts.timeout, () => {\n        xhr.abort();\n        queuedRequest.done();\n        const error = new Error(this.i18n('timedOut', {\n          seconds: Math.ceil(opts.timeout / 1000)\n        }));\n        this.uppy.emit('upload-error', file, error);\n        reject(error);\n      });\n      const id = nanoid();\n      xhr.upload.addEventListener('loadstart', () => {\n        this.uppy.log(`[XHRUpload] ${id} started`);\n      });\n      xhr.upload.addEventListener('progress', ev => {\n        this.uppy.log(`[XHRUpload] ${id} progress: ${ev.loaded} / ${ev.total}`); // Begin checking for timeouts when progress starts, instead of loading,\n        // to avoid timing out requests on browser concurrency queue\n\n        timer.progress();\n        if (ev.lengthComputable) {\n          this.uppy.emit('upload-progress', file, {\n            uploader: this,\n            bytesUploaded: ev.loaded,\n            bytesTotal: ev.total\n          });\n        }\n      });\n      xhr.addEventListener('load', () => {\n        this.uppy.log(`[XHRUpload] ${id} finished`);\n        timer.done();\n        queuedRequest.done();\n        if (this.uploaderEvents[file.id]) {\n          this.uploaderEvents[file.id].remove();\n          this.uploaderEvents[file.id] = null;\n        }\n        if (opts.validateStatus(xhr.status, xhr.responseText, xhr)) {\n          const body = opts.getResponseData(xhr.responseText, xhr);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: xhr.status,\n            body,\n            uploadURL\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n          if (uploadURL) {\n            this.uppy.log(`Download ${file.name} from ${uploadURL}`);\n          }\n          return resolve(file);\n        }\n        const body = opts.getResponseData(xhr.responseText, xhr);\n        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        const response = {\n          status: xhr.status,\n          body\n        };\n        this.uppy.emit('upload-error', file, error, response);\n        return reject(error);\n      });\n      xhr.addEventListener('error', () => {\n        this.uppy.log(`[XHRUpload] ${id} errored`);\n        timer.done();\n        queuedRequest.done();\n        if (this.uploaderEvents[file.id]) {\n          this.uploaderEvents[file.id].remove();\n          this.uploaderEvents[file.id] = null;\n        }\n        const error = buildResponseError(xhr, opts.getResponseError(xhr.responseText, xhr));\n        this.uppy.emit('upload-error', file, error);\n        return reject(error);\n      });\n      xhr.open(opts.method.toUpperCase(), opts.endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = opts.withCredentials;\n      if (opts.responseType !== '') {\n        xhr.responseType = opts.responseType;\n      }\n      queuedRequest = this.requests.run(() => {\n        this.uppy.emit('upload-started', file); // When using an authentication system like JWT, the bearer token goes as a header. This\n        // header needs to be fresh each time the token is refreshed so computing and setting the\n        // headers just before the upload starts enables this kind of authentication to work properly.\n        // Otherwise, half-way through the list of uploads the token could be stale and the upload would fail.\n\n        const currentOpts = this.getOptions(file);\n        Object.keys(currentOpts.headers).forEach(header => {\n          xhr.setRequestHeader(header, currentOpts.headers[header]);\n        });\n        xhr.send(data);\n        return () => {\n          timer.done();\n          xhr.abort();\n        };\n      });\n      this.onFileRemove(file.id, () => {\n        queuedRequest.abort();\n        reject(new Error('File removed'));\n      });\n      this.onCancelAll(file.id, _ref => {\n        let reason = _ref.reason;\n        if (reason === 'user') {\n          queuedRequest.abort();\n        }\n        reject(new Error('Upload cancelled'));\n      });\n    });\n  }\n  async uploadRemote(file) {\n    // TODO: we could rewrite this to use server-sent events instead of creating WebSockets.\n    try {\n      this.uppy.emit('upload-started', file);\n      if (file.serverToken) {\n        return this.connectToServerSocket(file);\n      }\n      const serverToken = await _classPrivateFieldLooseBase(this, _queueRequestSocketToken)[_queueRequestSocketToken](file);\n      if (!this.uppy.getState().files[file.id]) return undefined;\n      this.uppy.setFileState(file.id, {\n        serverToken\n      });\n      return this.connectToServerSocket(this.uppy.getFile(file.id));\n    } catch (err) {\n      this.uppy.emit('upload-error', file, err);\n      throw err;\n    }\n  }\n  connectToServerSocket(file) {\n    return new Promise((resolve, reject) => {\n      const opts = this.getOptions(file);\n      const token = file.serverToken;\n      const host = getSocketHost(file.remote.companionUrl);\n      let socket;\n      const createSocket = () => {\n        if (socket != null) return;\n        socket = new Socket({\n          target: `${host}/api/${token}`\n        });\n        socket.on('progress', progressData => emitSocketProgress(this, progressData, file));\n        socket.on('success', data => {\n          const body = opts.getResponseData(data.response.responseText, data.response);\n          const uploadURL = body[opts.responseUrlFieldName];\n          const uploadResp = {\n            status: data.response.status,\n            body,\n            uploadURL\n          };\n          this.uppy.emit('upload-success', file, uploadResp);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          socket.close();\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n          return resolve();\n        });\n        socket.on('error', errData => {\n          const resp = errData.response;\n          const error = resp ? opts.getResponseError(resp.responseText, resp) : Object.assign(new Error(errData.error.message), {\n            cause: errData.error\n          });\n          this.uppy.emit('upload-error', file, error);\n          queuedRequest.done(); // eslint-disable-line no-use-before-define\n\n          if (this.uploaderEvents[file.id]) {\n            this.uploaderEvents[file.id].remove();\n            this.uploaderEvents[file.id] = null;\n          }\n          reject(error);\n        });\n      };\n      this.uploaderEvents[file.id] = new EventTracker(this.uppy);\n      let queuedRequest = this.requests.run(() => {\n        if (file.isPaused) {\n          var _socket;\n          (_socket = socket) == null ? void 0 : _socket.send('pause', {});\n        } else {\n          createSocket();\n        }\n        return () => socket.close();\n      });\n      this.onFileRemove(file.id, () => {\n        var _socket2;\n        (_socket2 = socket) == null ? void 0 : _socket2.send('cancel', {});\n        queuedRequest.abort();\n        resolve(`upload ${file.id} was removed`);\n      });\n      this.onCancelAll(file.id, function (_temp) {\n        let _ref2 = _temp === void 0 ? {} : _temp,\n          reason = _ref2.reason;\n        if (reason === 'user') {\n          var _socket3;\n          (_socket3 = socket) == null ? void 0 : _socket3.send('cancel', {});\n          queuedRequest.abort();\n        }\n        resolve(`upload ${file.id} was canceled`);\n      });\n      const onRetryRequest = () => {\n        if (socket == null) {\n          queuedRequest.abort();\n        } else {\n          socket.send('pause', {});\n          queuedRequest.done();\n        }\n        queuedRequest = this.requests.run(() => {\n          if (!file.isPaused) {\n            if (socket == null) {\n              createSocket();\n            } else {\n              socket.send('resume', {});\n            }\n          }\n          return () => socket.close();\n        });\n      };\n      this.onRetry(file.id, onRetryRequest);\n      this.onRetryAll(file.id, onRetryRequest);\n    }).catch(err => {\n      this.uppy.emit('upload-error', file, err);\n      return Promise.reject(err);\n    });\n  }\n  uploadBundle(files) {\n    return new Promise((resolve, reject) => {\n      const endpoint = this.opts.endpoint;\n      const method = this.opts.method;\n      const optsFromState = this.uppy.getState().xhrUpload;\n      const formData = this.createBundledUpload(files, _objectSpread(_objectSpread({}, this.opts), optsFromState || {}));\n      const xhr = new XMLHttpRequest();\n      const emitError = error => {\n        files.forEach(file => {\n          this.uppy.emit('upload-error', file, error);\n        });\n      };\n      const timer = new ProgressTimeout(this.opts.timeout, () => {\n        xhr.abort();\n        const error = new Error(this.i18n('timedOut', {\n          seconds: Math.ceil(this.opts.timeout / 1000)\n        }));\n        emitError(error);\n        reject(error);\n      });\n      xhr.upload.addEventListener('loadstart', () => {\n        this.uppy.log('[XHRUpload] started uploading bundle');\n        timer.progress();\n      });\n      xhr.upload.addEventListener('progress', ev => {\n        timer.progress();\n        if (!ev.lengthComputable) return;\n        files.forEach(file => {\n          this.uppy.emit('upload-progress', file, {\n            uploader: this,\n            bytesUploaded: ev.loaded / ev.total * file.size,\n            bytesTotal: file.size\n          });\n        });\n      });\n      xhr.addEventListener('load', ev => {\n        timer.done();\n        if (this.opts.validateStatus(ev.target.status, xhr.responseText, xhr)) {\n          const body = this.opts.getResponseData(xhr.responseText, xhr);\n          const uploadResp = {\n            status: ev.target.status,\n            body\n          };\n          files.forEach(file => {\n            this.uppy.emit('upload-success', file, uploadResp);\n          });\n          return resolve();\n        }\n        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        error.request = xhr;\n        emitError(error);\n        return reject(error);\n      });\n      xhr.addEventListener('error', () => {\n        timer.done();\n        const error = this.opts.getResponseError(xhr.responseText, xhr) || new Error('Upload error');\n        emitError(error);\n        return reject(error);\n      });\n      this.uppy.on('cancel-all', function (_temp2) {\n        let _ref3 = _temp2 === void 0 ? {} : _temp2,\n          reason = _ref3.reason;\n        if (reason !== 'user') return;\n        timer.done();\n        xhr.abort();\n      });\n      xhr.open(method.toUpperCase(), endpoint, true); // IE10 does not allow setting `withCredentials` and `responseType`\n      // before `open()` is called.\n\n      xhr.withCredentials = this.opts.withCredentials;\n      if (this.opts.responseType !== '') {\n        xhr.responseType = this.opts.responseType;\n      }\n      Object.keys(this.opts.headers).forEach(header => {\n        xhr.setRequestHeader(header, this.opts.headers[header]);\n      });\n      xhr.send(formData);\n      files.forEach(file => {\n        this.uppy.emit('upload-started', file);\n      });\n    });\n  }\n  uploadFiles(files) {\n    const promises = files.map((file, i) => {\n      const current = parseInt(i, 10) + 1;\n      const total = files.length;\n      if (file.error) {\n        return Promise.reject(new Error(file.error));\n      }\n      if (file.isRemote) {\n        return this.uploadRemote(file, current, total);\n      }\n      return this.upload(file, current, total);\n    });\n    return settle(promises);\n  }\n  onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', file => {\n      if (fileID === file.id) cb(file.id);\n    });\n  }\n  onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', targetFileID => {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  }\n  onRetryAll(fileID, cb) {\n    this.uploaderEvents[fileID].on('retry-all', () => {\n      if (!this.uppy.getFile(fileID)) return;\n      cb();\n    });\n  }\n  onCancelAll(fileID, eventHandler) {\n    var _this = this;\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this.uppy.getFile(fileID)) return;\n      eventHandler(...arguments);\n    });\n  }\n  handleUpload(fileIDs) {\n    if (fileIDs.length === 0) {\n      this.uppy.log('[XHRUpload] No files to upload!');\n      return Promise.resolve();\n    } // No limit configured by the user, and no RateLimitedQueue passed in by a \"parent\" plugin\n    // (basically just AwsS3) using the internal symbol\n\n    if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {\n      this.uppy.log('[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0', 'warning');\n    }\n    this.uppy.log('[XHRUpload] Uploading...');\n    const files = fileIDs.map(fileID => this.uppy.getFile(fileID));\n    if (this.opts.bundle) {\n      // if bundle: true, we don’t support remote uploads\n      const isSomeFileRemote = files.some(file => file.isRemote);\n      if (isSomeFileRemote) {\n        throw new Error('Can’t upload remote files when the `bundle: true` option is set');\n      }\n      if (typeof this.opts.headers === 'function') {\n        throw new TypeError('`headers` may not be a function when the `bundle: true` option is set');\n      }\n      return this.uploadBundle(files);\n    }\n    return this.uploadFiles(files).then(() => null);\n  }\n  install() {\n    if (this.opts.bundle) {\n      const _this$uppy$getState2 = this.uppy.getState(),\n        capabilities = _this$uppy$getState2.capabilities;\n      this.uppy.setState({\n        capabilities: _objectSpread(_objectSpread({}, capabilities), {}, {\n          individualCancellation: false\n        })\n      });\n    }\n    this.uppy.addUploader(this.handleUpload);\n  }\n  uninstall() {\n    if (this.opts.bundle) {\n      const _this$uppy$getState3 = this.uppy.getState(),\n        capabilities = _this$uppy$getState3.capabilities;\n      this.uppy.setState({\n        capabilities: _objectSpread(_objectSpread({}, capabilities), {}, {\n          individualCancellation: true\n        })\n      });\n    }\n    this.uppy.removeUploader(this.handleUpload);\n  }\n}\nXHRUpload.VERSION = packageJson.version;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}