{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport { h } from 'preact';\nimport { UIPlugin } from '@uppy/core';\nimport getFileTypeExtension from '@uppy/utils/lib/getFileTypeExtension';\nimport ScreenRecIcon from \"./ScreenRecIcon.js\";\nimport RecorderScreen from \"./RecorderScreen.js\";\nconst packageJson = {\n  \"version\": \"3.0.1\"\n};\nimport locale from './locale.js'; // Check if screen capturing is supported.\n// mediaDevices is supprted on mobile Safari, getDisplayMedia is not\n\nfunction isScreenRecordingSupported() {\n  var _navigator$mediaDevic;\n  return window.MediaRecorder && ((_navigator$mediaDevic = navigator.mediaDevices) == null ? void 0 : _navigator$mediaDevic.getDisplayMedia); // eslint-disable-line compat/compat\n} // Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n\nfunction getMediaDevices() {\n  return window.MediaRecorder && navigator.mediaDevices; // eslint-disable-line compat/compat\n}\n/**\n * Screen capture\n */\n\nexport default class ScreenCapture extends UIPlugin {\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    this.mediaDevices = getMediaDevices(); // eslint-disable-next-line no-restricted-globals\n\n    this.protocol = location.protocol === 'https:' ? 'https' : 'http';\n    this.id = this.opts.id || 'ScreenCapture';\n    this.title = this.opts.title || 'Screencast';\n    this.type = 'acquirer';\n    this.icon = ScreenRecIcon;\n    this.defaultLocale = locale; // set default options\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints\n\n    const defaultOptions = {\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#Properties_of_shared_screen_tracks\n      displayMediaConstraints: {\n        video: {\n          width: 1280,\n          height: 720,\n          frameRate: {\n            ideal: 3,\n            max: 5\n          },\n          cursor: 'motion',\n          displaySurface: 'monitor'\n        }\n      },\n      // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints/audio\n      userMediaConstraints: {\n        audio: true\n      },\n      preferredVideoMimeType: 'video/webm'\n    }; // merge default options with the ones set by user\n\n    this.opts = _objectSpread(_objectSpread({}, defaultOptions), opts); // i18n\n\n    this.i18nInit(); // uppy plugin class related\n\n    this.install = this.install.bind(this);\n    this.setPluginState = this.setPluginState.bind(this);\n    this.render = this.render.bind(this); // screen capturer related\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this.startRecording = this.startRecording.bind(this);\n    this.stopRecording = this.stopRecording.bind(this);\n    this.submit = this.submit.bind(this);\n    this.streamInterrupted = this.streamInactivated.bind(this); // initialize\n\n    this.captureActive = false;\n    this.capturedMediaFile = null;\n  }\n  install() {\n    if (!isScreenRecordingSupported()) {\n      this.uppy.log('Screen recorder access is not supported', 'error');\n      return null;\n    }\n    this.setPluginState({\n      streamActive: false,\n      audioStreamActive: false\n    });\n    const target = this.opts.target;\n    if (target) {\n      this.mount(target, this);\n    }\n    return undefined;\n  }\n  uninstall() {\n    if (this.videoStream) {\n      this.stop();\n    }\n    this.unmount();\n  }\n  start() {\n    if (!this.mediaDevices) {\n      return Promise.reject(new Error('Screen recorder access not supported'));\n    }\n    this.captureActive = true;\n    this.selectAudioStreamSource();\n    return this.selectVideoStreamSource().then(res => {\n      // something happened in start -> return\n      if (res === false) {\n        // Close the Dashboard panel if plugin is installed\n        // into Dashboard (could be other parent UI plugin)\n        if (this.parent && this.parent.hideAllPanels) {\n          this.parent.hideAllPanels();\n          this.captureActive = false;\n        }\n      }\n    });\n  }\n  selectVideoStreamSource() {\n    // if active stream available, return it\n    if (this.videoStream) {\n      return new Promise(resolve => resolve(this.videoStream));\n    } // ask user to select source to record and get mediastream from that\n    // eslint-disable-next-line compat/compat\n\n    return this.mediaDevices.getDisplayMedia(this.opts.displayMediaConstraints).then(videoStream => {\n      this.videoStream = videoStream; // add event listener to stop recording if stream is interrupted\n\n      this.videoStream.addEventListener('inactive', () => {\n        this.streamInactivated();\n      });\n      this.setPluginState({\n        streamActive: true\n      });\n      return videoStream;\n    }).catch(err => {\n      this.setPluginState({\n        screenRecError: err\n      });\n      this.userDenied = true;\n      setTimeout(() => {\n        this.userDenied = false;\n      }, 1000);\n      return false;\n    });\n  }\n  selectAudioStreamSource() {\n    // if active stream available, return it\n    if (this.audioStream) {\n      return new Promise(resolve => resolve(this.audioStream));\n    } // ask user to select source to record and get mediastream from that\n    // eslint-disable-next-line compat/compat\n\n    return this.mediaDevices.getUserMedia(this.opts.userMediaConstraints).then(audioStream => {\n      this.audioStream = audioStream;\n      this.setPluginState({\n        audioStreamActive: true\n      });\n      return audioStream;\n    }).catch(err => {\n      if (err.name === 'NotAllowedError') {\n        this.uppy.info(this.i18n('micDisabled'), 'error', 5000);\n      }\n      return false;\n    });\n  }\n  startRecording() {\n    const options = {};\n    this.capturedMediaFile = null;\n    this.recordingChunks = [];\n    const preferredVideoMimeType = this.opts.preferredVideoMimeType;\n    this.selectVideoStreamSource().then(videoStream => {\n      // Attempt to use the passed preferredVideoMimeType (if any) during recording.\n      // If the browser doesn't support it, we'll fall back to the browser default instead\n      if (preferredVideoMimeType && MediaRecorder.isTypeSupported(preferredVideoMimeType) && getFileTypeExtension(preferredVideoMimeType)) {\n        options.mimeType = preferredVideoMimeType;\n      } // prepare tracks\n\n      const tracks = [videoStream.getVideoTracks()[0]]; // merge audio if exits\n\n      if (this.audioStream) {\n        tracks.push(this.audioStream.getAudioTracks()[0]);\n      } // create new stream from video and audio\n      // eslint-disable-next-line compat/compat\n\n      this.outputStream = new MediaStream(tracks); // initialize mediarecorder\n      // eslint-disable-next-line compat/compat\n\n      this.recorder = new MediaRecorder(this.outputStream, options); // push data to buffer when data available\n\n      this.recorder.addEventListener('dataavailable', event => {\n        this.recordingChunks.push(event.data);\n      }); // start recording\n\n      this.recorder.start(); // set plugin state to recording\n\n      this.setPluginState({\n        recording: true\n      });\n    }).catch(err => {\n      this.uppy.log(err, 'error');\n    });\n  }\n  streamInactivated() {\n    // get screen recorder state\n    const _this$getPluginState = _objectSpread({}, this.getPluginState()),\n      recordedVideo = _this$getPluginState.recordedVideo,\n      recording = _this$getPluginState.recording;\n    if (!recordedVideo && !recording) {\n      // Close the Dashboard panel if plugin is installed\n      // into Dashboard (could be other parent UI plugin)\n      if (this.parent && this.parent.hideAllPanels) {\n        this.parent.hideAllPanels();\n      }\n    } else if (recording) {\n      // stop recorder if it is active\n      this.uppy.log('Capture stream inactive â€” stop recording');\n      this.stopRecording();\n    }\n    this.videoStream = null;\n    this.audioStream = null;\n    this.setPluginState({\n      streamActive: false,\n      audioStreamActive: false\n    });\n  }\n  stopRecording() {\n    const stopped = new Promise(resolve => {\n      this.recorder.addEventListener('stop', () => {\n        resolve();\n      });\n      this.recorder.stop();\n    });\n    return stopped.then(() => {\n      // recording stopped\n      this.setPluginState({\n        recording: false\n      }); // get video file after recorder stopped\n\n      return this.getVideo();\n    }).then(file => {\n      // store media file\n      this.capturedMediaFile = file; // create object url for capture result preview\n\n      this.setPluginState({\n        // eslint-disable-next-line compat/compat\n        recordedVideo: URL.createObjectURL(file.data)\n      });\n    }).then(() => {\n      this.recordingChunks = null;\n      this.recorder = null;\n    }, error => {\n      this.recordingChunks = null;\n      this.recorder = null;\n      throw error;\n    });\n  }\n  submit() {\n    try {\n      // add recorded file to uppy\n      if (this.capturedMediaFile) {\n        this.uppy.addFile(this.capturedMediaFile);\n      }\n    } catch (err) {\n      // Logging the error, exept restrictions, which is handled in Core\n      if (!err.isRestriction) {\n        this.uppy.log(err, 'error');\n      }\n    }\n  }\n  stop() {\n    // flush video stream\n    if (this.videoStream) {\n      this.videoStream.getVideoTracks().forEach(track => {\n        track.stop();\n      });\n      this.videoStream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n      this.videoStream = null;\n    } // flush audio stream\n\n    if (this.audioStream) {\n      this.audioStream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n      this.audioStream.getVideoTracks().forEach(track => {\n        track.stop();\n      });\n      this.audioStream = null;\n    } // flush output stream\n\n    if (this.outputStream) {\n      this.outputStream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n      this.outputStream.getVideoTracks().forEach(track => {\n        track.stop();\n      });\n      this.outputStream = null;\n    } // remove preview video\n\n    this.setPluginState({\n      recordedVideo: null\n    });\n    this.captureActive = false;\n  }\n  getVideo() {\n    const mimeType = this.recordingChunks[0].type;\n    const fileExtension = getFileTypeExtension(mimeType);\n    if (!fileExtension) {\n      return Promise.reject(new Error(`Could not retrieve recording: Unsupported media type \"${mimeType}\"`));\n    }\n    const name = `screencap-${Date.now()}.${fileExtension}`;\n    const blob = new Blob(this.recordingChunks, {\n      type: mimeType\n    });\n    const file = {\n      source: this.id,\n      name,\n      data: new Blob([blob], {\n        type: mimeType\n      }),\n      type: mimeType\n    };\n    return Promise.resolve(file);\n  }\n  render() {\n    // get screen recorder state\n    const recorderState = this.getPluginState();\n    if (!recorderState.streamActive && !this.captureActive && !this.userDenied) {\n      this.start();\n    }\n    return h(RecorderScreen, _extends({}, recorderState, {\n      // eslint-disable-line react/jsx-props-no-spreading\n      onStartRecording: this.startRecording,\n      onStopRecording: this.stopRecording,\n      onStop: this.stop,\n      onSubmit: this.submit,\n      i18n: this.i18n,\n      stream: this.videoStream\n    }));\n  }\n}\nScreenCapture.VERSION = packageJson.version;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}