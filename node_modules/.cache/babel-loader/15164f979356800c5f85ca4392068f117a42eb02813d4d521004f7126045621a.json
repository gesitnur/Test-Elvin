{"ast":null,"code":"// Lower level API to animate any kind of svg path\n\nvar shifty = require('shifty');\nvar utils = require('./utils');\nvar Tweenable = shifty.Tweenable;\nvar EASING_ALIASES = {\n  easeIn: 'easeInCubic',\n  easeOut: 'easeOutCubic',\n  easeInOut: 'easeInOutCubic'\n};\nvar Path = function Path(path, opts) {\n  // Throw a better error if not initialized with `new` keyword\n  if (!(this instanceof Path)) {\n    throw new Error('Constructor was called without new keyword');\n  }\n\n  // Default parameters for animation\n  opts = utils.extend({\n    delay: 0,\n    duration: 800,\n    easing: 'linear',\n    from: {},\n    to: {},\n    step: function () {}\n  }, opts);\n  var element;\n  if (utils.isString(path)) {\n    element = document.querySelector(path);\n  } else {\n    element = path;\n  }\n\n  // Reveal .path as public attribute\n  this.path = element;\n  this._opts = opts;\n  this._tweenable = null;\n\n  // Set up the starting positions\n  var length = this.path.getTotalLength();\n  this.path.style.strokeDasharray = length + ' ' + length;\n  this.set(0);\n};\nPath.prototype.value = function value() {\n  var offset = this._getComputedDashOffset();\n  var length = this.path.getTotalLength();\n  var progress = 1 - offset / length;\n  // Round number to prevent returning very small number like 1e-30, which\n  // is practically 0\n  return parseFloat(progress.toFixed(6), 10);\n};\nPath.prototype.set = function set(progress) {\n  this.stop();\n  this.path.style.strokeDashoffset = this._progressToOffset(progress);\n  var step = this._opts.step;\n  if (utils.isFunction(step)) {\n    var easing = this._easing(this._opts.easing);\n    var values = this._calculateTo(progress, easing);\n    var reference = this._opts.shape || this;\n    step(values, reference, this._opts.attachment);\n  }\n};\nPath.prototype.stop = function stop() {\n  this._stopTween();\n  this.path.style.strokeDashoffset = this._getComputedDashOffset();\n};\n\n// Method introduced here:\n// http://jakearchibald.com/2013/animated-line-drawing-svg/\nPath.prototype.animate = function animate(progress, opts, cb) {\n  opts = opts || {};\n  if (utils.isFunction(opts)) {\n    cb = opts;\n    opts = {};\n  }\n  var passedOpts = utils.extend({}, opts);\n\n  // Copy default opts to new object so defaults are not modified\n  var defaultOpts = utils.extend({}, this._opts);\n  opts = utils.extend(defaultOpts, opts);\n  var shiftyEasing = this._easing(opts.easing);\n  var values = this._resolveFromAndTo(progress, shiftyEasing, passedOpts);\n  this.stop();\n\n  // Trigger a layout so styles are calculated & the browser\n  // picks up the starting position before animating\n  this.path.getBoundingClientRect();\n  var offset = this._getComputedDashOffset();\n  var newOffset = this._progressToOffset(progress);\n  var self = this;\n  this._tweenable = new Tweenable();\n  this._tweenable.tween({\n    from: utils.extend({\n      offset: offset\n    }, values.from),\n    to: utils.extend({\n      offset: newOffset\n    }, values.to),\n    duration: opts.duration,\n    delay: opts.delay,\n    easing: shiftyEasing,\n    step: function (state) {\n      self.path.style.strokeDashoffset = state.offset;\n      var reference = opts.shape || self;\n      opts.step(state, reference, opts.attachment);\n    }\n  }).then(function (state) {\n    if (utils.isFunction(cb)) {\n      cb();\n    }\n  });\n};\nPath.prototype._getComputedDashOffset = function _getComputedDashOffset() {\n  var computedStyle = window.getComputedStyle(this.path, null);\n  return parseFloat(computedStyle.getPropertyValue('stroke-dashoffset'), 10);\n};\nPath.prototype._progressToOffset = function _progressToOffset(progress) {\n  var length = this.path.getTotalLength();\n  return length - progress * length;\n};\n\n// Resolves from and to values for animation.\nPath.prototype._resolveFromAndTo = function _resolveFromAndTo(progress, easing, opts) {\n  if (opts.from && opts.to) {\n    return {\n      from: opts.from,\n      to: opts.to\n    };\n  }\n  return {\n    from: this._calculateFrom(easing),\n    to: this._calculateTo(progress, easing)\n  };\n};\n\n// Calculate `from` values from options passed at initialization\nPath.prototype._calculateFrom = function _calculateFrom(easing) {\n  return shifty.interpolate(this._opts.from, this._opts.to, this.value(), easing);\n};\n\n// Calculate `to` values from options passed at initialization\nPath.prototype._calculateTo = function _calculateTo(progress, easing) {\n  return shifty.interpolate(this._opts.from, this._opts.to, progress, easing);\n};\nPath.prototype._stopTween = function _stopTween() {\n  if (this._tweenable !== null) {\n    this._tweenable.stop();\n    this._tweenable = null;\n  }\n};\nPath.prototype._easing = function _easing(easing) {\n  if (EASING_ALIASES.hasOwnProperty(easing)) {\n    return EASING_ALIASES[easing];\n  }\n  return easing;\n};\nmodule.exports = Path;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}