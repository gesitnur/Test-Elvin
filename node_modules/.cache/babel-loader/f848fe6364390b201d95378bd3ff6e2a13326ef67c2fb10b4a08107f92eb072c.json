{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport hasProperty from '@uppy/utils/lib/hasProperty';\nimport ErrorWithCause from '@uppy/utils/lib/ErrorWithCause';\nimport { RateLimitedQueue } from '@uppy/utils/lib/RateLimitedQueue';\nimport BasePlugin from '@uppy/core/lib/BasePlugin.js';\nimport Tus from '@uppy/tus';\nimport Assembly from './Assembly.js';\nimport Client from './Client.js';\nimport AssemblyOptions, { validateParams } from './AssemblyOptions.js';\nimport AssemblyWatcher from './AssemblyWatcher.js';\nimport locale from './locale.js';\nconst packageJson = {\n  \"version\": \"3.0.2\"\n};\nfunction defaultGetAssemblyOptions(file, options) {\n  return {\n    params: options.params,\n    signature: options.signature,\n    fields: options.fields\n  };\n}\nconst sendErrorToConsole = originalErr => err => {\n  const error = new ErrorWithCause('Failed to send error to the client', {\n    cause: err\n  }); // eslint-disable-next-line no-console\n\n  console.error(error, originalErr);\n};\nconst COMPANION_URL = 'https://api2.transloadit.com/companion'; // Regex matching acceptable postMessage() origins for authentication feedback from companion.\n\nconst COMPANION_ALLOWED_HOSTS = /\\.transloadit\\.com$/; // Regex used to check if a Companion address is run by Transloadit.\n\nconst TL_COMPANION = /https?:\\/\\/api2(?:-\\w+)?\\.transloadit\\.com\\/companion/;\n/**\n * Upload files to Transloadit using Tus.\n */\n\nvar _rateLimitedQueue = /*#__PURE__*/_classPrivateFieldLooseKey(\"rateLimitedQueue\");\nvar _getClientVersion = /*#__PURE__*/_classPrivateFieldLooseKey(\"getClientVersion\");\nvar _attachAssemblyMetadata = /*#__PURE__*/_classPrivateFieldLooseKey(\"attachAssemblyMetadata\");\nvar _createAssembly = /*#__PURE__*/_classPrivateFieldLooseKey(\"createAssembly\");\nvar _createAssemblyWatcher = /*#__PURE__*/_classPrivateFieldLooseKey(\"createAssemblyWatcher\");\nvar _shouldWaitAfterUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldWaitAfterUpload\");\nvar _reserveFiles = /*#__PURE__*/_classPrivateFieldLooseKey(\"reserveFiles\");\nvar _onFileUploadURLAvailable = /*#__PURE__*/_classPrivateFieldLooseKey(\"onFileUploadURLAvailable\");\nvar _findFile = /*#__PURE__*/_classPrivateFieldLooseKey(\"findFile\");\nvar _onFileUploadComplete = /*#__PURE__*/_classPrivateFieldLooseKey(\"onFileUploadComplete\");\nvar _onResult = /*#__PURE__*/_classPrivateFieldLooseKey(\"onResult\");\nvar _onAssemblyFinished = /*#__PURE__*/_classPrivateFieldLooseKey(\"onAssemblyFinished\");\nvar _cancelAssembly = /*#__PURE__*/_classPrivateFieldLooseKey(\"cancelAssembly\");\nvar _onCancelAll = /*#__PURE__*/_classPrivateFieldLooseKey(\"onCancelAll\");\nvar _getPersistentData = /*#__PURE__*/_classPrivateFieldLooseKey(\"getPersistentData\");\nvar _onRestored = /*#__PURE__*/_classPrivateFieldLooseKey(\"onRestored\");\nvar _connectAssembly = /*#__PURE__*/_classPrivateFieldLooseKey(\"connectAssembly\");\nvar _prepareUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"prepareUpload\");\nvar _afterUpload = /*#__PURE__*/_classPrivateFieldLooseKey(\"afterUpload\");\nvar _closeAssemblyIfExists = /*#__PURE__*/_classPrivateFieldLooseKey(\"closeAssemblyIfExists\");\nvar _onError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onError\");\nvar _onTusError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onTusError\");\nexport default class Transloadit extends BasePlugin {\n  /** @deprecated use `import { COMPANION_URL } from '@uppy/transloadit'` instead. */\n\n  /** @deprecated use `import { COMPANION_ALLOWED_HOSTS } from '@uppy/transloadit'` instead. */\n  constructor(uppy, opts) {\n    var _this;\n    super(uppy, opts);\n    _this = this;\n    Object.defineProperty(this, _connectAssembly, {\n      value: _connectAssembly2\n    });\n    Object.defineProperty(this, _cancelAssembly, {\n      value: _cancelAssembly2\n    });\n    Object.defineProperty(this, _onAssemblyFinished, {\n      value: _onAssemblyFinished2\n    });\n    Object.defineProperty(this, _onResult, {\n      value: _onResult2\n    });\n    Object.defineProperty(this, _onFileUploadComplete, {\n      value: _onFileUploadComplete2\n    });\n    Object.defineProperty(this, _findFile, {\n      value: _findFile2\n    });\n    Object.defineProperty(this, _reserveFiles, {\n      value: _reserveFiles2\n    });\n    Object.defineProperty(this, _shouldWaitAfterUpload, {\n      value: _shouldWaitAfterUpload2\n    });\n    Object.defineProperty(this, _createAssemblyWatcher, {\n      value: _createAssemblyWatcher2\n    });\n    Object.defineProperty(this, _createAssembly, {\n      value: _createAssembly2\n    });\n    Object.defineProperty(this, _attachAssemblyMetadata, {\n      value: _attachAssemblyMetadata2\n    });\n    Object.defineProperty(this, _getClientVersion, {\n      value: _getClientVersion2\n    });\n    Object.defineProperty(this, _rateLimitedQueue, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _onFileUploadURLAvailable, {\n      writable: true,\n      value: rawFile => {\n        var _file$transloadit;\n        const file = this.uppy.getFile(rawFile.id);\n        if (!(file != null && (_file$transloadit = file.transloadit) != null && _file$transloadit.assembly)) {\n          return;\n        }\n        const _this$getPluginState = this.getPluginState(),\n          assemblies = _this$getPluginState.assemblies;\n        const assembly = assemblies[file.transloadit.assembly];\n        this.client.addFile(assembly, file).catch(err => {\n          this.uppy.log(err);\n          this.uppy.emit('transloadit:import-error', assembly, file.id, err);\n        });\n      }\n    });\n    Object.defineProperty(this, _onCancelAll, {\n      writable: true,\n      value: async function (_temp) {\n        let _ref3 = _temp === void 0 ? {} : _temp,\n          reason = _ref3.reason;\n        try {\n          if (reason !== 'user') return;\n          const _this$getPluginState2 = _this.getPluginState(),\n            uploadsAssemblies = _this$getPluginState2.uploadsAssemblies;\n          const assemblyIDs = Object.values(uploadsAssemblies).flat(1);\n          const assemblies = assemblyIDs.map(assemblyID => _this.getAssembly(assemblyID));\n          await Promise.all(assemblies.map(assembly => _classPrivateFieldLooseBase(_this, _cancelAssembly)[_cancelAssembly](assembly)));\n        } catch (err) {\n          _this.uppy.log(err);\n        }\n      }\n    });\n    Object.defineProperty(this, _getPersistentData, {\n      writable: true,\n      value: setData => {\n        const _this$getPluginState3 = this.getPluginState(),\n          assemblies = _this$getPluginState3.assemblies,\n          uploadsAssemblies = _this$getPluginState3.uploadsAssemblies;\n        setData({\n          [this.id]: {\n            assemblies,\n            uploadsAssemblies\n          }\n        });\n      }\n    });\n    Object.defineProperty(this, _onRestored, {\n      writable: true,\n      value: pluginData => {\n        const savedState = pluginData && pluginData[this.id] ? pluginData[this.id] : {};\n        const previousAssemblies = savedState.assemblies || {};\n        const uploadsAssemblies = savedState.uploadsAssemblies || {};\n        if (Object.keys(uploadsAssemblies).length === 0) {\n          // Nothing to restore.\n          return;\n        } // Convert loaded Assembly statuses to a Transloadit plugin state object.\n\n        const restoreState = assemblies => {\n          const files = {};\n          const results = [];\n          for (const _ref4 of Object.entries(assemblies)) {\n            var _ref5 = _slicedToArray(_ref4, 2);\n            const id = _ref5[0];\n            const status = _ref5[1];\n            status.uploads.forEach(uploadedFile => {\n              const file = _classPrivateFieldLooseBase(this, _findFile)[_findFile](uploadedFile);\n              files[uploadedFile.id] = {\n                id: file.id,\n                assembly: id,\n                uploadedFile\n              };\n            });\n            const state = this.getPluginState();\n            Object.keys(status.results).forEach(stepName => {\n              for (const result of status.results[stepName]) {\n                const file = state.files[result.original_id];\n                result.localId = file ? file.id : null;\n                results.push({\n                  id: result.id,\n                  result,\n                  stepName,\n                  assembly: id\n                });\n              }\n            });\n          }\n          this.setPluginState({\n            assemblies,\n            files,\n            results,\n            uploadsAssemblies\n          });\n        }; // Set up the Assembly instances and AssemblyWatchers for existing Assemblies.\n\n        const restoreAssemblies = () => {\n          // eslint-disable-next-line no-shadow\n          const _this$getPluginState4 = this.getPluginState(),\n            assemblies = _this$getPluginState4.assemblies,\n            uploadsAssemblies = _this$getPluginState4.uploadsAssemblies; // Set up the assembly watchers again for all the ongoing uploads.\n\n          Object.keys(uploadsAssemblies).forEach(uploadID => {\n            const assemblyIDs = uploadsAssemblies[uploadID];\n            _classPrivateFieldLooseBase(this, _createAssemblyWatcher)[_createAssemblyWatcher](assemblyIDs, uploadID);\n          });\n          const allAssemblyIDs = Object.keys(assemblies);\n          allAssemblyIDs.forEach(id => {\n            const assembly = new Assembly(assemblies[id], _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue]);\n            _classPrivateFieldLooseBase(this, _connectAssembly)[_connectAssembly](assembly);\n          });\n        }; // Force-update all Assemblies to check for missed events.\n\n        const updateAssemblies = () => {\n          const _this$getPluginState5 = this.getPluginState(),\n            assemblies = _this$getPluginState5.assemblies;\n          return Promise.all(Object.keys(assemblies).map(id => {\n            return this.activeAssemblies[id].update();\n          }));\n        }; // Restore all Assembly state.\n\n        this.restored = Promise.resolve().then(() => {\n          restoreState(previousAssemblies);\n          restoreAssemblies();\n          return updateAssemblies();\n        });\n        this.restored.then(() => {\n          this.restored = null;\n        });\n      }\n    });\n    Object.defineProperty(this, _prepareUpload, {\n      writable: true,\n      value: (fileIDs, uploadID) => {\n        const files = fileIDs.map(id => this.uppy.getFile(id));\n        const filesWithoutErrors = files.filter(file => {\n          if (!file.error) {\n            this.uppy.emit('preprocess-progress', file, {\n              mode: 'indeterminate',\n              message: this.i18n('creatingAssembly')\n            });\n            return true;\n          }\n          return false;\n        }); // eslint-disable-next-line no-shadow\n\n        const createAssembly = async _ref => {\n          let fileIDs = _ref.fileIDs,\n            options = _ref.options;\n          try {\n            const assembly = await _classPrivateFieldLooseBase(this, _createAssembly)[_createAssembly](fileIDs, uploadID, options);\n            if (this.opts.importFromUploadURLs) {\n              await _classPrivateFieldLooseBase(this, _reserveFiles)[_reserveFiles](assembly, fileIDs);\n            }\n            fileIDs.forEach(fileID => {\n              const file = this.uppy.getFile(fileID);\n              this.uppy.emit('preprocess-complete', file);\n            });\n            return assembly;\n          } catch (err) {\n            fileIDs.forEach(fileID => {\n              const file = this.uppy.getFile(fileID); // Clear preprocessing state when the Assembly could not be created,\n              // otherwise the UI gets confused about the lingering progress keys\n\n              this.uppy.emit('preprocess-complete', file);\n              this.uppy.emit('upload-error', file, err);\n            });\n            throw err;\n          }\n        };\n        const _this$getPluginState6 = this.getPluginState(),\n          uploadsAssemblies = _this$getPluginState6.uploadsAssemblies;\n        this.setPluginState({\n          uploadsAssemblies: _objectSpread(_objectSpread({}, uploadsAssemblies), {}, {\n            [uploadID]: []\n          })\n        });\n        const assemblyOptions = new AssemblyOptions(filesWithoutErrors, this.opts);\n        return assemblyOptions.build().then(assemblies => Promise.all(assemblies.map(createAssembly))).then(maybeCreatedAssemblies => {\n          const createdAssemblies = maybeCreatedAssemblies.filter(Boolean);\n          const assemblyIDs = createdAssemblies.map(assembly => assembly.status.assembly_id);\n          _classPrivateFieldLooseBase(this, _createAssemblyWatcher)[_createAssemblyWatcher](assemblyIDs, uploadID);\n          return Promise.all(createdAssemblies.map(assembly => _classPrivateFieldLooseBase(this, _connectAssembly)[_connectAssembly](assembly)));\n        }) // If something went wrong before any Assemblies could be created,\n        // clear all processing state.\n        .catch(err => {\n          filesWithoutErrors.forEach(file => {\n            this.uppy.emit('preprocess-complete', file);\n            this.uppy.emit('upload-error', file, err);\n          });\n          throw err;\n        });\n      }\n    });\n    Object.defineProperty(this, _afterUpload, {\n      writable: true,\n      value: (fileIDs, uploadID) => {\n        const files = fileIDs.map(fileID => this.uppy.getFile(fileID)); // Only use files without errors\n\n        const filteredFileIDs = files.filter(file => !file.error).map(file => file.id);\n        const state = this.getPluginState(); // If we're still restoring state, wait for that to be done.\n\n        if (this.restored) {\n          return this.restored.then(() => {\n            return _classPrivateFieldLooseBase(this, _afterUpload)[_afterUpload](filteredFileIDs, uploadID);\n          });\n        }\n        const assemblyIDs = state.uploadsAssemblies[uploadID];\n        const closeSocketConnections = () => {\n          assemblyIDs.forEach(assemblyID => {\n            const assembly = this.activeAssemblies[assemblyID];\n            assembly.close();\n            delete this.activeAssemblies[assemblyID];\n          });\n        }; // If we don't have to wait for encoding metadata or results, we can close\n        // the socket immediately and finish the upload.\n\n        if (!_classPrivateFieldLooseBase(this, _shouldWaitAfterUpload)[_shouldWaitAfterUpload]()) {\n          closeSocketConnections();\n          const assemblies = assemblyIDs.map(id => this.getAssembly(id));\n          this.uppy.addResultData(uploadID, {\n            transloadit: assemblies\n          });\n          return Promise.resolve();\n        } // If no Assemblies were created for this upload, we also do not have to wait.\n        // There's also no sockets or anything to close, so just return immediately.\n\n        if (assemblyIDs.length === 0) {\n          this.uppy.addResultData(uploadID, {\n            transloadit: []\n          });\n          return Promise.resolve();\n        }\n        const incompleteFiles = files.filter(file => !hasProperty(this.completedFiles, file.id));\n        incompleteFiles.forEach(file => {\n          this.uppy.emit('postprocess-progress', file, {\n            mode: 'indeterminate',\n            message: this.i18n('encoding')\n          });\n        });\n        const watcher = this.assemblyWatchers[uploadID];\n        return watcher.promise.then(() => {\n          closeSocketConnections();\n          const assemblies = assemblyIDs.map(id => this.getAssembly(id)); // Remove the Assembly ID list for this upload,\n          // it's no longer going to be used anywhere.\n\n          const uploadsAssemblies = _objectSpread({}, this.getPluginState().uploadsAssemblies);\n          delete uploadsAssemblies[uploadID];\n          this.setPluginState({\n            uploadsAssemblies\n          });\n          this.uppy.addResultData(uploadID, {\n            transloadit: assemblies\n          });\n        });\n      }\n    });\n    Object.defineProperty(this, _closeAssemblyIfExists, {\n      writable: true,\n      value: assemblyID => {\n        var _this$activeAssemblie;\n        (_this$activeAssemblie = this.activeAssemblies[assemblyID]) == null ? void 0 : _this$activeAssemblie.close();\n      }\n    });\n    Object.defineProperty(this, _onError, {\n      writable: true,\n      value: function (err, uploadID) {\n        if (err === void 0) {\n          err = null;\n        }\n        const state = _this.getPluginState();\n        const assemblyIDs = state.uploadsAssemblies[uploadID];\n        assemblyIDs == null ? void 0 : assemblyIDs.forEach(_classPrivateFieldLooseBase(_this, _closeAssemblyIfExists)[_closeAssemblyIfExists]);\n        _this.client.submitError(err) // if we can't report the error that sucks\n        .catch(sendErrorToConsole(err));\n      }\n    });\n    Object.defineProperty(this, _onTusError, {\n      writable: true,\n      value: (file, err) => {\n        var _file$transloadit2, _err$message;\n        _classPrivateFieldLooseBase(this, _closeAssemblyIfExists)[_closeAssemblyIfExists](file == null ? void 0 : (_file$transloadit2 = file.transloadit) == null ? void 0 : _file$transloadit2.assembly);\n        if (err != null && (_err$message = err.message) != null && _err$message.startsWith('tus: ')) {\n          var _err$originalRequest, _err$originalRequest$;\n          const endpoint = (_err$originalRequest = err.originalRequest) == null ? void 0 : (_err$originalRequest$ = _err$originalRequest.getUnderlyingObject()) == null ? void 0 : _err$originalRequest$.responseURL;\n          this.client.submitError(err, {\n            endpoint,\n            type: 'TUS_ERROR'\n          }) // if we can't report the error that sucks\n          .catch(sendErrorToConsole(err));\n        }\n      }\n    });\n    this.type = 'uploader';\n    this.id = this.opts.id || 'Transloadit';\n    this.title = 'Transloadit';\n    this.defaultLocale = locale;\n    const defaultOptions = {\n      service: 'https://api2.transloadit.com',\n      errorReporting: true,\n      waitForEncoding: false,\n      waitForMetadata: false,\n      alwaysRunAssembly: false,\n      importFromUploadURLs: false,\n      signature: null,\n      params: null,\n      fields: {},\n      getAssemblyOptions: defaultGetAssemblyOptions,\n      limit: 20,\n      retryDelays: [7000, 10000, 15000, 20000]\n    };\n    this.opts = _objectSpread(_objectSpread({}, defaultOptions), opts);\n    _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue] = new RateLimitedQueue(this.opts.limit);\n    this.i18nInit();\n    const hasCustomAssemblyOptions = this.opts.getAssemblyOptions !== defaultOptions.getAssemblyOptions;\n    if (this.opts.params) {\n      validateParams(this.opts.params);\n    } else if (!hasCustomAssemblyOptions) {\n      // Throw the same error that we'd throw if the `params` returned from a\n      // `getAssemblyOptions()` function is null.\n      validateParams(null);\n    }\n    this.client = new Client({\n      service: this.opts.service,\n      client: _classPrivateFieldLooseBase(this, _getClientVersion)[_getClientVersion](),\n      errorReporting: this.opts.errorReporting,\n      rateLimitedQueue: _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue]\n    }); // Contains Assembly instances for in-progress Assemblies.\n\n    this.activeAssemblies = {}; // Contains a mapping of uploadID to AssemblyWatcher\n\n    this.assemblyWatchers = {}; // Contains a file IDs that have completed postprocessing before the upload\n    // they belong to has entered the postprocess stage.\n\n    this.completedFiles = Object.create(null);\n  }\n  install() {\n    this.uppy.addPreProcessor(_classPrivateFieldLooseBase(this, _prepareUpload)[_prepareUpload]);\n    this.uppy.addPostProcessor(_classPrivateFieldLooseBase(this, _afterUpload)[_afterUpload]); // We may need to close socket.io connections on error.\n\n    this.uppy.on('error', _classPrivateFieldLooseBase(this, _onError)[_onError]); // Handle cancellation.\n\n    this.uppy.on('cancel-all', _classPrivateFieldLooseBase(this, _onCancelAll)[_onCancelAll]); // For error reporting.\n\n    this.uppy.on('upload-error', _classPrivateFieldLooseBase(this, _onTusError)[_onTusError]);\n    if (this.opts.importFromUploadURLs) {\n      // No uploader needed when importing; instead we take the upload URL from an existing uploader.\n      this.uppy.on('upload-success', _classPrivateFieldLooseBase(this, _onFileUploadURLAvailable)[_onFileUploadURLAvailable]);\n    } else {\n      this.uppy.use(Tus, {\n        // Disable tus-js-client fingerprinting, otherwise uploading the same file at different times\n        // will upload to an outdated Assembly, and we won't get socket events for it.\n        //\n        // To resume a Transloadit upload, we need to reconnect to the websocket, and the state that's\n        // required to do that is not saved by tus-js-client's fingerprinting. We need the tus URL,\n        // the Assembly URL, and the WebSocket URL, at least. We also need to know _all_ the files that\n        // were added to the Assembly, so we can properly complete it. All that state is handled by\n        // Golden Retriever. So, Golden Retriever is required to do resumability with the Transloadit plugin,\n        // and we disable Tus's default resume implementation to prevent bad behaviours.\n        storeFingerprintForResuming: false,\n        // Disable Companion's retry optimisation; we need to change the endpoint on retry\n        // so it can't just reuse the same tus.Upload instance server-side.\n        useFastRemoteRetry: false,\n        // Only send Assembly metadata to the tus endpoint.\n        allowedMetaFields: ['assembly_url', 'filename', 'fieldname'],\n        // Pass the limit option to @uppy/tus\n        limit: this.opts.limit,\n        rateLimitedQueue: _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue],\n        retryDelays: this.opts.retryDelays\n      });\n    }\n    this.uppy.on('restore:get-data', _classPrivateFieldLooseBase(this, _getPersistentData)[_getPersistentData]);\n    this.uppy.on('restored', _classPrivateFieldLooseBase(this, _onRestored)[_onRestored]);\n    this.setPluginState({\n      // Contains Assembly status objects, indexed by their ID.\n      assemblies: {},\n      // Contains arrays of Assembly IDs, indexed by the upload ID that they belong to.\n      uploadsAssemblies: {},\n      // Contains file data from Transloadit, indexed by their Transloadit-assigned ID.\n      files: {},\n      // Contains result data from Transloadit.\n      results: []\n    }); // We cannot cancel individual files because Assemblies tend to contain many files.\n\n    const _this$uppy$getState = this.uppy.getState(),\n      capabilities = _this$uppy$getState.capabilities;\n    this.uppy.setState({\n      capabilities: _objectSpread(_objectSpread({}, capabilities), {}, {\n        individualCancellation: false\n      })\n    });\n  }\n  uninstall() {\n    this.uppy.removePreProcessor(_classPrivateFieldLooseBase(this, _prepareUpload)[_prepareUpload]);\n    this.uppy.removePostProcessor(_classPrivateFieldLooseBase(this, _afterUpload)[_afterUpload]);\n    this.uppy.off('error', _classPrivateFieldLooseBase(this, _onError)[_onError]);\n    if (this.opts.importFromUploadURLs) {\n      this.uppy.off('upload-success', _classPrivateFieldLooseBase(this, _onFileUploadURLAvailable)[_onFileUploadURLAvailable]);\n    }\n    const _this$uppy$getState2 = this.uppy.getState(),\n      capabilities = _this$uppy$getState2.capabilities;\n    this.uppy.setState({\n      capabilities: _objectSpread(_objectSpread({}, capabilities), {}, {\n        individualCancellation: true\n      })\n    });\n  }\n  getAssembly(id) {\n    const _this$getPluginState7 = this.getPluginState(),\n      assemblies = _this$getPluginState7.assemblies;\n    return assemblies[id];\n  }\n  getAssemblyFiles(assemblyID) {\n    return this.uppy.getFiles().filter(file => {\n      var _file$transloadit3;\n      return (file == null ? void 0 : (_file$transloadit3 = file.transloadit) == null ? void 0 : _file$transloadit3.assembly) === assemblyID;\n    });\n  }\n}\nfunction _getClientVersion2() {\n  const list = [`uppy-core:${this.uppy.constructor.VERSION}`, `uppy-transloadit:${this.constructor.VERSION}`, `uppy-tus:${Tus.VERSION}`];\n  const addPluginVersion = (pluginName, versionName) => {\n    const plugin = this.uppy.getPlugin(pluginName);\n    if (plugin) {\n      list.push(`${versionName}:${plugin.constructor.VERSION}`);\n    }\n  };\n  if (this.opts.importFromUploadURLs) {\n    addPluginVersion('XHRUpload', 'uppy-xhr-upload');\n    addPluginVersion('AwsS3', 'uppy-aws-s3');\n    addPluginVersion('AwsS3Multipart', 'uppy-aws-s3-multipart');\n  }\n  addPluginVersion('Dropbox', 'uppy-dropbox');\n  addPluginVersion('Box', 'uppy-box');\n  addPluginVersion('Facebook', 'uppy-facebook');\n  addPluginVersion('GoogleDrive', 'uppy-google-drive');\n  addPluginVersion('Instagram', 'uppy-instagram');\n  addPluginVersion('OneDrive', 'uppy-onedrive');\n  addPluginVersion('Zoom', 'uppy-zoom');\n  addPluginVersion('Url', 'uppy-url');\n  return list.join(',');\n}\nfunction _attachAssemblyMetadata2(file, status) {\n  // Add the metadata parameters Transloadit needs.\n  const meta = _objectSpread(_objectSpread({}, file.meta), {}, {\n    assembly_url: status.assembly_url,\n    filename: file.name,\n    fieldname: 'file'\n  }); // Add Assembly-specific Tus endpoint.\n\n  const tus = _objectSpread(_objectSpread({}, file.tus), {}, {\n    endpoint: status.tus_url,\n    // Include X-Request-ID headers for better debugging.\n    addRequestId: true\n  }); // Set Companion location. We only add this, if 'file' has the attribute\n  // remote, because this is the criteria to identify remote files.\n  // We only replace the hostname for Transloadit's companions, so that\n  // people can also self-host them while still using Transloadit for encoding.\n\n  let remote = file.remote;\n  if (file.remote && TL_COMPANION.test(file.remote.companionUrl)) {\n    const newHost = status.companion_url.replace(/\\/$/, '');\n    const path = file.remote.url.replace(file.remote.companionUrl, '').replace(/^\\//, '');\n    remote = _objectSpread(_objectSpread({}, file.remote), {}, {\n      companionUrl: newHost,\n      url: `${newHost}/${path}`\n    });\n  } // Store the Assembly ID this file is in on the file under the `transloadit` key.\n\n  const newFile = _objectSpread(_objectSpread({}, file), {}, {\n    transloadit: {\n      assembly: status.assembly_id\n    }\n  }); // Only configure the Tus plugin if we are uploading straight to Transloadit (the default).\n\n  if (!this.opts.importFromUploadURLs) {\n    Object.assign(newFile, {\n      meta,\n      tus,\n      remote\n    });\n  }\n  return newFile;\n}\nfunction _createAssembly2(fileIDs, uploadID, options) {\n  this.uppy.log('[Transloadit] Create Assembly');\n  return this.client.createAssembly({\n    params: options.params,\n    fields: options.fields,\n    expectedFiles: fileIDs.length,\n    signature: options.signature\n  }).then(async newAssembly => {\n    const files = this.uppy.getFiles().filter(_ref2 => {\n      let id = _ref2.id;\n      return fileIDs.includes(id);\n    });\n    if (files.length !== fileIDs.length) {\n      if (files.length === 0) {\n        // All files have been removed, cancelling.\n        await this.client.cancelAssembly(newAssembly);\n        return null;\n      } // At least one file has been removed.\n\n      await this.client.updateNumberOfFilesInAssembly(newAssembly, files.length);\n    }\n    const assembly = new Assembly(newAssembly, _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue]);\n    const status = assembly.status;\n    const assemblyID = status.assembly_id;\n    const _this$getPluginState8 = this.getPluginState(),\n      assemblies = _this$getPluginState8.assemblies,\n      uploadsAssemblies = _this$getPluginState8.uploadsAssemblies;\n    this.setPluginState({\n      // Store the Assembly status.\n      assemblies: _objectSpread(_objectSpread({}, assemblies), {}, {\n        [assemblyID]: status\n      }),\n      // Store the list of Assemblies related to this upload.\n      uploadsAssemblies: _objectSpread(_objectSpread({}, uploadsAssemblies), {}, {\n        [uploadID]: [...uploadsAssemblies[uploadID], assemblyID]\n      })\n    });\n    const updatedFiles = {};\n    files.forEach(file => {\n      updatedFiles[file.id] = _classPrivateFieldLooseBase(this, _attachAssemblyMetadata)[_attachAssemblyMetadata](file, status);\n    });\n    this.uppy.setState({\n      files: _objectSpread(_objectSpread({}, this.uppy.getState().files), updatedFiles)\n    });\n    const fileRemovedHandler = (fileRemoved, reason) => {\n      if (reason === 'cancel-all') {\n        assembly.close();\n        this.uppy.off(fileRemovedHandler);\n      } else if (fileRemoved.id in updatedFiles) {\n        delete updatedFiles[fileRemoved.id];\n        const nbOfRemainingFiles = Object.keys(updatedFiles).length;\n        if (nbOfRemainingFiles === 0) {\n          assembly.close();\n          _classPrivateFieldLooseBase(this, _cancelAssembly)[_cancelAssembly](newAssembly).catch(() => {\n            /* ignore potential errors */\n          });\n          this.uppy.off(fileRemovedHandler);\n        } else {\n          this.client.updateNumberOfFilesInAssembly(newAssembly, nbOfRemainingFiles).catch(() => {\n            /* ignore potential errors */\n          });\n        }\n      }\n    };\n    this.uppy.on('file-removed', fileRemovedHandler);\n    this.uppy.emit('transloadit:assembly-created', status, fileIDs);\n    this.uppy.log(`[Transloadit] Created Assembly ${assemblyID}`);\n    return assembly;\n  }).catch(err => {\n    const wrapped = new ErrorWithCause(`${this.i18n('creatingAssemblyFailed')}: ${err.message}`, {\n      cause: err\n    });\n    if ('details' in err) {\n      wrapped.details = err.details;\n    }\n    if ('assembly' in err) {\n      wrapped.assembly = err.assembly;\n    }\n    throw wrapped;\n  });\n}\nfunction _createAssemblyWatcher2(assemblyID, uploadID) {\n  // AssemblyWatcher tracks completion states of all Assemblies in this upload.\n  const watcher = new AssemblyWatcher(this.uppy, assemblyID);\n  watcher.on('assembly-complete', id => {\n    const files = this.getAssemblyFiles(id);\n    files.forEach(file => {\n      this.completedFiles[file.id] = true;\n      this.uppy.emit('postprocess-complete', file);\n    });\n  });\n  watcher.on('assembly-error', (id, error) => {\n    // Clear postprocessing state for all our files.\n    const files = this.getAssemblyFiles(id);\n    files.forEach(file => {\n      // TODO Maybe make a postprocess-error event here?\n      this.uppy.emit('upload-error', file, error);\n      this.uppy.emit('postprocess-complete', file);\n    });\n  });\n  this.assemblyWatchers[uploadID] = watcher;\n}\nfunction _shouldWaitAfterUpload2() {\n  return this.opts.waitForEncoding || this.opts.waitForMetadata;\n}\nfunction _reserveFiles2(assembly, fileIDs) {\n  return Promise.all(fileIDs.map(fileID => {\n    const file = this.uppy.getFile(fileID);\n    return this.client.reserveFile(assembly.status, file);\n  }));\n}\nfunction _findFile2(uploadedFile) {\n  const files = this.uppy.getFiles();\n  for (let i = 0; i < files.length; i++) {\n    const file = files[i]; // Completed file upload.\n\n    if (file.uploadURL === uploadedFile.tus_upload_url) {\n      return file;\n    } // In-progress file upload.\n\n    if (file.tus && file.tus.uploadUrl === uploadedFile.tus_upload_url) {\n      return file;\n    }\n    if (!uploadedFile.is_tus_file) {\n      // Fingers-crossed check for non-tus uploads, eg imported from S3.\n      if (file.name === uploadedFile.name && file.size === uploadedFile.size) {\n        return file;\n      }\n    }\n  }\n  return undefined;\n}\nfunction _onFileUploadComplete2(assemblyId, uploadedFile) {\n  const state = this.getPluginState();\n  const file = _classPrivateFieldLooseBase(this, _findFile)[_findFile](uploadedFile);\n  if (!file) {\n    this.uppy.log('[Transloadit] Couldn’t file the file, it was likely removed in the process');\n    return;\n  }\n  this.setPluginState({\n    files: _objectSpread(_objectSpread({}, state.files), {}, {\n      [uploadedFile.id]: {\n        assembly: assemblyId,\n        id: file.id,\n        uploadedFile\n      }\n    })\n  });\n  this.uppy.emit('transloadit:upload', uploadedFile, this.getAssembly(assemblyId));\n}\nfunction _onResult2(assemblyId, stepName, result) {\n  const state = this.getPluginState();\n  const file = state.files[result.original_id]; // The `file` may not exist if an import robot was used instead of a file upload.\n\n  result.localId = file ? file.id : null; // eslint-disable-line no-param-reassign\n\n  const entry = {\n    result,\n    stepName,\n    id: result.id,\n    assembly: assemblyId\n  };\n  this.setPluginState({\n    results: [...state.results, entry]\n  });\n  this.uppy.emit('transloadit:result', stepName, result, this.getAssembly(assemblyId));\n}\nfunction _onAssemblyFinished2(status) {\n  const url = status.assembly_ssl_url;\n  this.client.getAssemblyStatus(url).then(finalStatus => {\n    const assemblyId = finalStatus.assembly_id;\n    const state = this.getPluginState();\n    this.setPluginState({\n      assemblies: _objectSpread(_objectSpread({}, state.assemblies), {}, {\n        [assemblyId]: finalStatus\n      })\n    });\n    this.uppy.emit('transloadit:complete', finalStatus);\n  });\n}\nasync function _cancelAssembly2(assembly) {\n  await this.client.cancelAssembly(assembly); // TODO bubble this through AssemblyWatcher so its event handlers can clean up correctly\n\n  this.uppy.emit('transloadit:assembly-cancelled', assembly);\n}\nfunction _connectAssembly2(assembly) {\n  const status = assembly.status;\n  const id = status.assembly_id;\n  this.activeAssemblies[id] = assembly; // Sync local `assemblies` state\n\n  assembly.on('status', newStatus => {\n    const _this$getPluginState9 = this.getPluginState(),\n      assemblies = _this$getPluginState9.assemblies;\n    this.setPluginState({\n      assemblies: _objectSpread(_objectSpread({}, assemblies), {}, {\n        [id]: newStatus\n      })\n    });\n  });\n  assembly.on('upload', file => {\n    _classPrivateFieldLooseBase(this, _onFileUploadComplete)[_onFileUploadComplete](id, file);\n  });\n  assembly.on('error', error => {\n    error.assembly = assembly.status; // eslint-disable-line no-param-reassign\n\n    this.uppy.emit('transloadit:assembly-error', assembly.status, error);\n  });\n  assembly.on('executing', () => {\n    this.uppy.emit('transloadit:assembly-executing', assembly.status);\n  });\n  if (this.opts.waitForEncoding) {\n    assembly.on('result', (stepName, result) => {\n      _classPrivateFieldLooseBase(this, _onResult)[_onResult](id, stepName, result);\n    });\n  }\n  if (this.opts.waitForEncoding) {\n    assembly.on('finished', () => {\n      _classPrivateFieldLooseBase(this, _onAssemblyFinished)[_onAssemblyFinished](assembly.status);\n    });\n  } else if (this.opts.waitForMetadata) {\n    assembly.on('metadata', () => {\n      _classPrivateFieldLooseBase(this, _onAssemblyFinished)[_onAssemblyFinished](assembly.status);\n    });\n  } // No need to connect to the socket if the Assembly has completed by now.\n\n  if (assembly.ok === 'ASSEMBLY_COMPLETE') {\n    return assembly;\n  }\n  assembly.connect();\n  return assembly;\n}\nTransloadit.VERSION = packageJson.version;\nTransloadit.COMPANION = COMPANION_URL;\nTransloadit.COMPANION_PATTERN = COMPANION_ALLOWED_HOSTS;\nexport { COMPANION_URL, COMPANION_ALLOWED_HOSTS };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}