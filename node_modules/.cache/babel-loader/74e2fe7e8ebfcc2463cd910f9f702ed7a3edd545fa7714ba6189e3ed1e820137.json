{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport BasePlugin from '@uppy/core/lib/BasePlugin.js';\nimport getDroppedFiles from '@uppy/utils/lib/getDroppedFiles';\nimport toArray from '@uppy/utils/lib/toArray';\nconst packageJson = {\n  \"version\": \"2.0.1\"\n};\nfunction isFileTransfer(event) {\n  var _event$dataTransfer$t, _event$dataTransfer$t2;\n  return (_event$dataTransfer$t = (_event$dataTransfer$t2 = event.dataTransfer.types) == null ? void 0 : _event$dataTransfer$t2.some(type => type === 'Files')) != null ? _event$dataTransfer$t : false;\n}\n/**\n * Drop Target plugin\n *\n */\n\nexport default class DropTarget extends BasePlugin {\n  constructor(uppy, opts) {\n    super(uppy, opts);\n    this.addFiles = files => {\n      const descriptors = files.map(file => ({\n        source: this.id,\n        name: file.name,\n        type: file.type,\n        data: file,\n        meta: {\n          // path of the file relative to the ancestor directory the user selected.\n          // e.g. 'docs/Old Prague/airbnb.pdf'\n          relativePath: file.relativePath || null\n        }\n      }));\n      try {\n        this.uppy.addFiles(descriptors);\n      } catch (err) {\n        this.uppy.log(err);\n      }\n    };\n    this.handleDrop = async event => {\n      var _this$opts$onDrop, _this$opts;\n      if (!isFileTransfer(event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      clearTimeout(this.removeDragOverClassTimeout); // Remove dragover class\n\n      event.currentTarget.classList.remove('uppy-is-drag-over');\n      this.setPluginState({\n        isDraggingOver: false\n      }); // Let any acquirer plugin (Url/Webcam/etc.) handle drops to the root\n\n      this.uppy.iteratePlugins(plugin => {\n        if (plugin.type === 'acquirer') {\n          // Every Plugin with .type acquirer can define handleRootDrop(event)\n          plugin.handleRootDrop == null ? void 0 : plugin.handleRootDrop(event);\n        }\n      }); // Add all dropped files, handle errors\n\n      let executedDropErrorOnce = false;\n      const logDropError = error => {\n        this.uppy.log(error, 'error'); // In practice all drop errors are most likely the same,\n        // so let's just show one to avoid overwhelming the user\n\n        if (!executedDropErrorOnce) {\n          this.uppy.info(error.message, 'error');\n          executedDropErrorOnce = true;\n        }\n      };\n      const files = await getDroppedFiles(event.dataTransfer, {\n        logDropError\n      });\n      if (files.length > 0) {\n        this.uppy.log('[DropTarget] Files were dropped');\n        this.addFiles(files);\n      }\n      (_this$opts$onDrop = (_this$opts = this.opts).onDrop) == null ? void 0 : _this$opts$onDrop.call(_this$opts, event);\n    };\n    this.handleDragOver = event => {\n      var _this$opts$onDragOver, _this$opts2;\n      if (!isFileTransfer(event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation(); // Add a small (+) icon on drop\n      // (and prevent browsers from interpreting this as files being _moved_ into the browser,\n      // https://github.com/transloadit/uppy/issues/1978)\n\n      event.dataTransfer.dropEffect = 'copy'; // eslint-disable-line no-param-reassign\n\n      clearTimeout(this.removeDragOverClassTimeout);\n      event.currentTarget.classList.add('uppy-is-drag-over');\n      this.setPluginState({\n        isDraggingOver: true\n      });\n      (_this$opts$onDragOver = (_this$opts2 = this.opts).onDragOver) == null ? void 0 : _this$opts$onDragOver.call(_this$opts2, event);\n    };\n    this.handleDragLeave = event => {\n      var _this$opts$onDragLeav, _this$opts3;\n      if (!isFileTransfer(event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      const currentTarget = event.currentTarget;\n      clearTimeout(this.removeDragOverClassTimeout); // Timeout against flickering, this solution is taken from drag-drop library.\n      // Solution with 'pointer-events: none' didn't work across browsers.\n\n      this.removeDragOverClassTimeout = setTimeout(() => {\n        currentTarget.classList.remove('uppy-is-drag-over');\n        this.setPluginState({\n          isDraggingOver: false\n        });\n      }, 50);\n      (_this$opts$onDragLeav = (_this$opts3 = this.opts).onDragLeave) == null ? void 0 : _this$opts$onDragLeav.call(_this$opts3, event);\n    };\n    this.addListeners = () => {\n      const target = this.opts.target;\n      if (target instanceof Element) {\n        this.nodes = [target];\n      } else if (typeof target === 'string') {\n        this.nodes = toArray(document.querySelectorAll(target));\n      }\n      if (!this.nodes && !this.nodes.length > 0) {\n        throw new Error(`\"${target}\" does not match any HTML elements`);\n      }\n      this.nodes.forEach(node => {\n        node.addEventListener('dragover', this.handleDragOver, false);\n        node.addEventListener('dragleave', this.handleDragLeave, false);\n        node.addEventListener('drop', this.handleDrop, false);\n      });\n    };\n    this.removeListeners = () => {\n      if (this.nodes) {\n        this.nodes.forEach(node => {\n          node.removeEventListener('dragover', this.handleDragOver, false);\n          node.removeEventListener('dragleave', this.handleDragLeave, false);\n          node.removeEventListener('drop', this.handleDrop, false);\n        });\n      }\n    };\n    this.type = 'acquirer';\n    this.id = this.opts.id || 'DropTarget';\n    this.title = 'Drop Target'; // Default options\n\n    const defaultOpts = {\n      target: null\n    }; // Merge default options with the ones set by user\n\n    this.opts = _objectSpread(_objectSpread({}, defaultOpts), opts);\n    this.removeDragOverClassTimeout = null;\n  }\n  install() {\n    this.setPluginState({\n      isDraggingOver: false\n    });\n    this.addListeners();\n  }\n  uninstall() {\n    this.removeListeners();\n  }\n}\nDropTarget.VERSION = packageJson.version;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}