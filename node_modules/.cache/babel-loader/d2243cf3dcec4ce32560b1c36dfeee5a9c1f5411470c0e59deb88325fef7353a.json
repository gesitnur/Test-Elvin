{"ast":null,"code":"function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction e(e, t, s) {\n  return t in e ? Object.defineProperty(e, t, {\n    value: s,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = s, e;\n}\nvar t = \"undefined\" != typeof self ? self : global;\nconst s = \"undefined\" != typeof navigator,\n  i = s && \"undefined\" == typeof HTMLImageElement,\n  n = !(\"undefined\" == typeof global || \"undefined\" == typeof process || !process.versions || !process.versions.node),\n  r = t.Buffer,\n  a = !!r,\n  h = e => void 0 !== e;\nfunction f(e) {\n  return void 0 === e || (e instanceof Map ? 0 === e.size : 0 === Object.values(e).filter(h).length);\n}\nfunction l(e) {\n  let t = new Error(e);\n  throw delete t.stack, t;\n}\nfunction o(e) {\n  let t = function (e) {\n    let t = 0;\n    return e.ifd0.enabled && (t += 1024), e.exif.enabled && (t += 2048), e.makerNote && (t += 2048), e.userComment && (t += 1024), e.gps.enabled && (t += 512), e.interop.enabled && (t += 100), e.ifd1.enabled && (t += 1024), t + 2048;\n  }(e);\n  return e.jfif.enabled && (t += 50), e.xmp.enabled && (t += 2e4), e.iptc.enabled && (t += 14e3), e.icc.enabled && (t += 6e3), t;\n}\nconst u = e => String.fromCharCode.apply(null, e),\n  d = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf-8\") : void 0;\nclass c {\n  static from(e, t) {\n    return e instanceof this && e.le === t ? e : new c(e, void 0, void 0, t);\n  }\n  constructor(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let s = arguments.length > 2 ? arguments[2] : undefined;\n    let i = arguments.length > 3 ? arguments[3] : undefined;\n    if (\"boolean\" == typeof i && (this.le = i), Array.isArray(e) && (e = new Uint8Array(e)), 0 === e) this.byteOffset = 0, this.byteLength = 0;else if (e instanceof ArrayBuffer) {\n      void 0 === s && (s = e.byteLength - t);\n      let i = new DataView(e, t, s);\n      this._swapDataView(i);\n    } else if (e instanceof Uint8Array || e instanceof DataView || e instanceof c) {\n      void 0 === s && (s = e.byteLength - t), (t += e.byteOffset) + s > e.byteOffset + e.byteLength && l(\"Creating view outside of available memory in ArrayBuffer\");\n      let i = new DataView(e.buffer, t, s);\n      this._swapDataView(i);\n    } else if (\"number\" == typeof e) {\n      let t = new DataView(new ArrayBuffer(e));\n      this._swapDataView(t);\n    } else l(\"Invalid input argument for BufferView: \" + e);\n  }\n  _swapArrayBuffer(e) {\n    this._swapDataView(new DataView(e));\n  }\n  _swapBuffer(e) {\n    this._swapDataView(new DataView(e.buffer, e.byteOffset, e.byteLength));\n  }\n  _swapDataView(e) {\n    this.dataView = e, this.buffer = e.buffer, this.byteOffset = e.byteOffset, this.byteLength = e.byteLength;\n  }\n  _lengthToEnd(e) {\n    return this.byteLength - e;\n  }\n  set(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : c;\n    return e instanceof DataView || e instanceof c ? e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer && (e = new Uint8Array(e)), e instanceof Uint8Array || l(\"BufferView.set(): Invalid data argument.\"), this.toUint8().set(e, t), new s(this, t, e.byteLength);\n  }\n  subarray(e, t) {\n    return t = t || this._lengthToEnd(e), new c(this, e, t);\n  }\n  toUint8() {\n    return new Uint8Array(this.buffer, this.byteOffset, this.byteLength);\n  }\n  getUint8Array(e, t) {\n    return new Uint8Array(this.buffer, this.byteOffset + e, t);\n  }\n  getString() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteLength;\n    let s = this.getUint8Array(e, t);\n    return i = s, d ? d.decode(i) : a ? Buffer.from(i).toString(\"utf8\") : decodeURIComponent(escape(u(i)));\n    var i;\n  }\n  getLatin1String() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteLength;\n    let s = this.getUint8Array(e, t);\n    return u(s);\n  }\n  getUnicodeString() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteLength;\n    const s = [];\n    for (let i = 0; i < t && e + i < this.byteLength; i += 2) s.push(this.getUint16(e + i));\n    return u(s);\n  }\n  getInt8(e) {\n    return this.dataView.getInt8(e);\n  }\n  getUint8(e) {\n    return this.dataView.getUint8(e);\n  }\n  getInt16(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getInt16(e, t);\n  }\n  getInt32(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getInt32(e, t);\n  }\n  getUint16(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getUint16(e, t);\n  }\n  getUint32(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getUint32(e, t);\n  }\n  getFloat32(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getFloat32(e, t);\n  }\n  getFloat64(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getFloat64(e, t);\n  }\n  getFloat(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getFloat32(e, t);\n  }\n  getDouble(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.le;\n    return this.dataView.getFloat64(e, t);\n  }\n  getUintBytes(e, t, s) {\n    switch (t) {\n      case 1:\n        return this.getUint8(e, s);\n      case 2:\n        return this.getUint16(e, s);\n      case 4:\n        return this.getUint32(e, s);\n      case 8:\n        return this.getUint64 && this.getUint64(e, s);\n    }\n  }\n  getUint(e, t, s) {\n    switch (t) {\n      case 8:\n        return this.getUint8(e, s);\n      case 16:\n        return this.getUint16(e, s);\n      case 32:\n        return this.getUint32(e, s);\n      case 64:\n        return this.getUint64 && this.getUint64(e, s);\n    }\n  }\n  toString(e) {\n    return this.dataView.toString(e, this.constructor.name);\n  }\n  ensureChunk() {}\n}\nfunction p(e, t) {\n  l(`${e} '${t}' was not loaded, try using full build of exifr.`);\n}\nclass g extends Map {\n  constructor(e) {\n    super(), this.kind = e;\n  }\n  get(e, t) {\n    return this.has(e) || p(this.kind, e), t && (e in t || function (e, t) {\n      l(`Unknown ${e} '${t}'.`);\n    }(this.kind, e), t[e].enabled || p(this.kind, e)), super.get(e);\n  }\n  keyList() {\n    return Array.from(this.keys());\n  }\n}\nvar m = new g(\"file parser\"),\n  y = new g(\"segment parser\"),\n  b = new g(\"file reader\");\nlet w = t.fetch;\nfunction k(e, t) {\n  return (i = e).startsWith(\"data:\") || i.length > 1e4 ? v(e, t, \"base64\") : n && e.includes(\"://\") ? O(e, t, \"url\", S) : n ? v(e, t, \"fs\") : s ? O(e, t, \"url\", S) : void l(\"Invalid input argument\");\n  var i;\n}\nasync function O(e, t, s, i) {\n  return b.has(s) ? v(e, t, s) : i ? async function (e, t) {\n    let s = await t(e);\n    return new c(s);\n  }(e, i) : void l(`Parser ${s} is not loaded`);\n}\nasync function v(e, t, s) {\n  let i = new (b.get(s))(e, t);\n  return await i.read(), i;\n}\nconst S = e => w(e).then(e => e.arrayBuffer()),\n  A = e => new Promise((t, s) => {\n    let i = new FileReader();\n    i.onloadend = () => t(i.result || new ArrayBuffer()), i.onerror = s, i.readAsArrayBuffer(e);\n  });\nclass U extends Map {\n  get tagKeys() {\n    return this.allKeys || (this.allKeys = Array.from(this.keys())), this.allKeys;\n  }\n  get tagValues() {\n    return this.allValues || (this.allValues = Array.from(this.values())), this.allValues;\n  }\n}\nfunction x(e, t, s) {\n  let i = new U();\n  for (let _ref of s) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    let e = _ref2[0];\n    let t = _ref2[1];\n    i.set(e, t);\n  }\n  if (Array.isArray(t)) for (let s of t) e.set(s, i);else e.set(t, i);\n  return i;\n}\nfunction C(e, t, s) {\n  let i,\n    n = e.get(t);\n  for (i of s) n.set(i[0], i[1]);\n}\nconst B = new Map(),\n  V = new Map(),\n  I = new Map(),\n  L = [\"chunked\", \"firstChunkSize\", \"firstChunkSizeNode\", \"firstChunkSizeBrowser\", \"chunkSize\", \"chunkLimit\"],\n  T = [\"jfif\", \"xmp\", \"icc\", \"iptc\", \"ihdr\"],\n  z = [\"tiff\", ...T],\n  P = [\"ifd0\", \"ifd1\", \"exif\", \"gps\", \"interop\"],\n  F = [...z, ...P],\n  j = [\"makerNote\", \"userComment\"],\n  E = [\"translateKeys\", \"translateValues\", \"reviveValues\", \"multiSegment\"],\n  M = [...E, \"sanitize\", \"mergeOutput\", \"silentErrors\"];\nclass _ {\n  get translate() {\n    return this.translateKeys || this.translateValues || this.reviveValues;\n  }\n}\nclass D extends _ {\n  get needed() {\n    return this.enabled || this.deps.size > 0;\n  }\n  constructor(t, s, i, n) {\n    if (super(), e(this, \"enabled\", !1), e(this, \"skip\", new Set()), e(this, \"pick\", new Set()), e(this, \"deps\", new Set()), e(this, \"translateKeys\", !1), e(this, \"translateValues\", !1), e(this, \"reviveValues\", !1), this.key = t, this.enabled = s, this.parse = this.enabled, this.applyInheritables(n), this.canBeFiltered = P.includes(t), this.canBeFiltered && (this.dict = B.get(t)), void 0 !== i) if (Array.isArray(i)) this.parse = this.enabled = !0, this.canBeFiltered && i.length > 0 && this.translateTagSet(i, this.pick);else if (\"object\" == typeof i) {\n      if (this.enabled = !0, this.parse = !1 !== i.parse, this.canBeFiltered) {\n        let e = i.pick,\n          t = i.skip;\n        e && e.length > 0 && this.translateTagSet(e, this.pick), t && t.length > 0 && this.translateTagSet(t, this.skip);\n      }\n      this.applyInheritables(i);\n    } else !0 === i || !1 === i ? this.parse = this.enabled = i : l(`Invalid options argument: ${i}`);\n  }\n  applyInheritables(e) {\n    let t, s;\n    for (t of E) s = e[t], void 0 !== s && (this[t] = s);\n  }\n  translateTagSet(e, t) {\n    if (this.dict) {\n      let s,\n        i,\n        _this$dict = this.dict,\n        n = _this$dict.tagKeys,\n        r = _this$dict.tagValues;\n      for (s of e) \"string\" == typeof s ? (i = r.indexOf(s), -1 === i && (i = n.indexOf(Number(s))), -1 !== i && t.add(Number(n[i]))) : t.add(s);\n    } else for (let s of e) t.add(s);\n  }\n  finalizeFilters() {\n    !this.enabled && this.deps.size > 0 ? (this.enabled = !0, X(this.pick, this.deps)) : this.enabled && this.pick.size > 0 && X(this.pick, this.deps);\n  }\n}\nvar N = {\n    jfif: !1,\n    tiff: !0,\n    xmp: !1,\n    icc: !1,\n    iptc: !1,\n    ifd0: !0,\n    ifd1: !1,\n    exif: !0,\n    gps: !0,\n    interop: !1,\n    ihdr: void 0,\n    makerNote: !1,\n    userComment: !1,\n    multiSegment: !1,\n    skip: [],\n    pick: [],\n    translateKeys: !0,\n    translateValues: !0,\n    reviveValues: !0,\n    sanitize: !0,\n    mergeOutput: !0,\n    silentErrors: !0,\n    chunked: !0,\n    firstChunkSize: void 0,\n    firstChunkSizeNode: 512,\n    firstChunkSizeBrowser: 65536,\n    chunkSize: 65536,\n    chunkLimit: 5\n  },\n  $ = new Map();\nclass R extends _ {\n  static useCached(e) {\n    let t = $.get(e);\n    return void 0 !== t || (t = new this(e), $.set(e, t)), t;\n  }\n  constructor(e) {\n    super(), !0 === e ? this.setupFromTrue() : void 0 === e ? this.setupFromUndefined() : Array.isArray(e) ? this.setupFromArray(e) : \"object\" == typeof e ? this.setupFromObject(e) : l(`Invalid options argument ${e}`), void 0 === this.firstChunkSize && (this.firstChunkSize = s ? this.firstChunkSizeBrowser : this.firstChunkSizeNode), this.mergeOutput && (this.ifd1.enabled = !1), this.filterNestedSegmentTags(), this.traverseTiffDependencyTree(), this.checkLoadedPlugins();\n  }\n  setupFromUndefined() {\n    let e;\n    for (e of L) this[e] = N[e];\n    for (e of M) this[e] = N[e];\n    for (e of j) this[e] = N[e];\n    for (e of F) this[e] = new D(e, N[e], void 0, this);\n  }\n  setupFromTrue() {\n    let e;\n    for (e of L) this[e] = N[e];\n    for (e of M) this[e] = N[e];\n    for (e of j) this[e] = !0;\n    for (e of F) this[e] = new D(e, !0, void 0, this);\n  }\n  setupFromArray(e) {\n    let t;\n    for (t of L) this[t] = N[t];\n    for (t of M) this[t] = N[t];\n    for (t of j) this[t] = N[t];\n    for (t of F) this[t] = new D(t, !1, void 0, this);\n    this.setupGlobalFilters(e, void 0, P);\n  }\n  setupFromObject(e) {\n    let t;\n    for (t of (P.ifd0 = P.ifd0 || P.image, P.ifd1 = P.ifd1 || P.thumbnail, Object.assign(this, e), L)) this[t] = W(e[t], N[t]);\n    for (t of M) this[t] = W(e[t], N[t]);\n    for (t of j) this[t] = W(e[t], N[t]);\n    for (t of z) this[t] = new D(t, N[t], e[t], this);\n    for (t of P) this[t] = new D(t, N[t], e[t], this.tiff);\n    this.setupGlobalFilters(e.pick, e.skip, P, F), !0 === e.tiff ? this.batchEnableWithBool(P, !0) : !1 === e.tiff ? this.batchEnableWithUserValue(P, e) : Array.isArray(e.tiff) ? this.setupGlobalFilters(e.tiff, void 0, P) : \"object\" == typeof e.tiff && this.setupGlobalFilters(e.tiff.pick, e.tiff.skip, P);\n  }\n  batchEnableWithBool(e, t) {\n    for (let s of e) this[s].enabled = t;\n  }\n  batchEnableWithUserValue(e, t) {\n    for (let s of e) {\n      let e = t[s];\n      this[s].enabled = !1 !== e && void 0 !== e;\n    }\n  }\n  setupGlobalFilters(e, t, s) {\n    let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : s;\n    if (e && e.length) {\n      for (let e of i) this[e].enabled = !1;\n      let t = K(e, s);\n      for (let _ref3 of t) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n        let e = _ref4[0];\n        let s = _ref4[1];\n        X(this[e].pick, s), this[e].enabled = !0;\n      }\n    } else if (t && t.length) {\n      let e = K(t, s);\n      for (let _ref5 of e) {\n        var _ref6 = _slicedToArray(_ref5, 2);\n        let t = _ref6[0];\n        let s = _ref6[1];\n        X(this[t].skip, s);\n      }\n    }\n  }\n  filterNestedSegmentTags() {\n    let e = this.ifd0,\n      t = this.exif,\n      s = this.xmp,\n      i = this.iptc,\n      n = this.icc;\n    this.makerNote ? t.deps.add(37500) : t.skip.add(37500), this.userComment ? t.deps.add(37510) : t.skip.add(37510), s.enabled || e.skip.add(700), i.enabled || e.skip.add(33723), n.enabled || e.skip.add(34675);\n  }\n  traverseTiffDependencyTree() {\n    let e = this.ifd0,\n      t = this.exif,\n      s = this.gps,\n      i = this.interop;\n    i.needed && (t.deps.add(40965), e.deps.add(40965)), t.needed && e.deps.add(34665), s.needed && e.deps.add(34853), this.tiff.enabled = P.some(e => !0 === this[e].enabled) || this.makerNote || this.userComment;\n    for (let e of P) this[e].finalizeFilters();\n  }\n  get onlyTiff() {\n    return !T.map(e => this[e].enabled).some(e => !0 === e) && this.tiff.enabled;\n  }\n  checkLoadedPlugins() {\n    for (let e of z) this[e].enabled && !y.has(e) && p(\"segment parser\", e);\n  }\n}\nfunction K(e, t) {\n  let s,\n    i,\n    n,\n    r,\n    a = [];\n  for (n of t) {\n    for (r of (s = B.get(n), i = [], s)) (e.includes(r[0]) || e.includes(r[1])) && i.push(r[0]);\n    i.length && a.push([n, i]);\n  }\n  return a;\n}\nfunction W(e, t) {\n  return void 0 !== e ? e : void 0 !== t ? t : void 0;\n}\nfunction X(e, t) {\n  for (let s of t) e.add(s);\n}\ne(R, \"default\", N);\nclass H {\n  constructor(t) {\n    e(this, \"parsers\", {}), e(this, \"output\", {}), e(this, \"errors\", []), e(this, \"pushToErrors\", e => this.errors.push(e)), this.options = R.useCached(t);\n  }\n  async read(e) {\n    this.file = await function (e, t) {\n      return \"string\" == typeof e ? k(e, t) : s && !i && e instanceof HTMLImageElement ? k(e.src, t) : e instanceof Uint8Array || e instanceof ArrayBuffer || e instanceof DataView ? new c(e) : s && e instanceof Blob ? O(e, t, \"blob\", A) : void l(\"Invalid input argument\");\n    }(e, this.options);\n  }\n  setup() {\n    if (this.fileParser) return;\n    let e = this.file,\n      t = e.getUint16(0);\n    for (let _ref7 of m) {\n      var _ref8 = _slicedToArray(_ref7, 2);\n      let s = _ref8[0];\n      let i = _ref8[1];\n      if (i.canHandle(e, t)) return this.fileParser = new i(this.options, this.file, this.parsers), e[s] = !0;\n    }\n    this.file.close && this.file.close(), l(\"Unknown file format\");\n  }\n  async parse() {\n    let e = this.output,\n      t = this.errors;\n    return this.setup(), this.options.silentErrors ? (await this.executeParsers().catch(this.pushToErrors), t.push(...this.fileParser.errors)) : await this.executeParsers(), this.file.close && this.file.close(), this.options.silentErrors && t.length > 0 && (e.errors = t), f(s = e) ? void 0 : s;\n    var s;\n  }\n  async executeParsers() {\n    let e = this.output;\n    await this.fileParser.parse();\n    let t = Object.values(this.parsers).map(async t => {\n      let s = await t.parse();\n      t.assignToOutput(e, s);\n    });\n    this.options.silentErrors && (t = t.map(e => e.catch(this.pushToErrors))), await Promise.all(t);\n  }\n  async extractThumbnail() {\n    this.setup();\n    let e = this.options,\n      t = this.file,\n      s = y.get(\"tiff\", e);\n    var i;\n    if (t.tiff ? i = {\n      start: 0,\n      type: \"tiff\"\n    } : t.jpeg && (i = await this.fileParser.getOrFindSegment(\"tiff\")), void 0 === i) return;\n    let n = await this.fileParser.ensureSegmentChunk(i),\n      r = this.parsers.tiff = new s(n, e, t),\n      a = await r.extractThumbnail();\n    return t.close && t.close(), a;\n  }\n}\nasync function Y(e, t) {\n  let s = new H(t);\n  return await s.read(e), s.parse();\n}\nvar G = Object.freeze({\n  __proto__: null,\n  parse: Y,\n  Exifr: H,\n  fileParsers: m,\n  segmentParsers: y,\n  fileReaders: b,\n  tagKeys: B,\n  tagValues: V,\n  tagRevivers: I,\n  createDictionary: x,\n  extendDictionary: C,\n  fetchUrlAsArrayBuffer: S,\n  readBlobAsArrayBuffer: A,\n  chunkedProps: L,\n  otherSegments: T,\n  segments: z,\n  tiffBlocks: P,\n  segmentsAndBlocks: F,\n  tiffExtractables: j,\n  inheritables: E,\n  allFormatters: M,\n  Options: R\n});\nclass J {\n  static findPosition(e, t) {\n    let s = e.getUint16(t + 2) + 2,\n      i = \"function\" == typeof this.headerLength ? this.headerLength(e, t, s) : this.headerLength,\n      n = t + i,\n      r = s - i;\n    return {\n      offset: t,\n      length: s,\n      headerLength: i,\n      start: n,\n      size: r,\n      end: n + r\n    };\n  }\n  static parse(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new this(e, new R({\n      [this.type]: t\n    }), e).parse();\n  }\n  normalizeInput(e) {\n    return e instanceof c ? e : new c(e);\n  }\n  constructor(t) {\n    let s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let i = arguments.length > 2 ? arguments[2] : undefined;\n    e(this, \"errors\", []), e(this, \"raw\", new Map()), e(this, \"handleError\", e => {\n      if (!this.options.silentErrors) throw e;\n      this.errors.push(e.message);\n    }), this.chunk = this.normalizeInput(t), this.file = i, this.type = this.constructor.type, this.globalOptions = this.options = s, this.localOptions = s[this.type], this.canTranslate = this.localOptions && this.localOptions.translate;\n  }\n  translate() {\n    this.canTranslate && (this.translated = this.translateBlock(this.raw, this.type));\n  }\n  get output() {\n    return this.translated ? this.translated : this.raw ? Object.fromEntries(this.raw) : void 0;\n  }\n  translateBlock(e, t) {\n    let s = I.get(t),\n      i = V.get(t),\n      n = B.get(t),\n      r = this.options[t],\n      a = r.reviveValues && !!s,\n      h = r.translateValues && !!i,\n      f = r.translateKeys && !!n,\n      l = {};\n    for (let _ref9 of e) {\n      var _ref10 = _slicedToArray(_ref9, 2);\n      let t = _ref10[0];\n      let r = _ref10[1];\n      a && s.has(t) ? r = s.get(t)(r) : h && i.has(t) && (r = this.translateValue(r, i.get(t))), f && n.has(t) && (t = n.get(t) || t), l[t] = r;\n    }\n    return l;\n  }\n  translateValue(e, t) {\n    return t[e] || t.DEFAULT || e;\n  }\n  assignToOutput(e, t) {\n    this.assignObjectToOutput(e, this.constructor.type, t);\n  }\n  assignObjectToOutput(e, t, s) {\n    if (this.globalOptions.mergeOutput) return Object.assign(e, s);\n    e[t] ? Object.assign(e[t], s) : e[t] = s;\n  }\n}\ne(J, \"headerLength\", 4), e(J, \"type\", void 0), e(J, \"multiSegment\", !1), e(J, \"canHandle\", () => !1);\nfunction q(e) {\n  return 192 === e || 194 === e || 196 === e || 219 === e || 221 === e || 218 === e || 254 === e;\n}\nfunction Q(e) {\n  return e >= 224 && e <= 239;\n}\nfunction Z(e, t, s) {\n  for (let _ref11 of y) {\n    var _ref12 = _slicedToArray(_ref11, 2);\n    let i = _ref12[0];\n    let n = _ref12[1];\n    if (n.canHandle(e, t, s)) return i;\n  }\n}\nclass ee extends class {\n  constructor(t, s, i) {\n    e(this, \"errors\", []), e(this, \"ensureSegmentChunk\", async e => {\n      let t = e.start,\n        s = e.size || 65536;\n      if (this.file.chunked) {\n        if (this.file.available(t, s)) e.chunk = this.file.subarray(t, s);else try {\n          e.chunk = await this.file.readChunk(t, s);\n        } catch (t) {\n          l(`Couldn't read segment: ${JSON.stringify(e)}. ${t.message}`);\n        }\n      } else this.file.byteLength > t + s ? e.chunk = this.file.subarray(t, s) : void 0 === e.size ? e.chunk = this.file.subarray(t) : l(\"Segment unreachable: \" + JSON.stringify(e));\n      return e.chunk;\n    }), this.extendOptions && this.extendOptions(t), this.options = t, this.file = s, this.parsers = i;\n  }\n  injectSegment(e, t) {\n    this.options[e].enabled && this.createParser(e, t);\n  }\n  createParser(e, t) {\n    let s = new (y.get(e))(t, this.options, this.file);\n    return this.parsers[e] = s;\n  }\n  createParsers(e) {\n    for (let t of e) {\n      let e = t.type,\n        s = t.chunk,\n        i = this.options[e];\n      if (i && i.enabled) {\n        let t = this.parsers[e];\n        t && t.append || t || this.createParser(e, s);\n      }\n    }\n  }\n  async readSegments(e) {\n    let t = e.map(this.ensureSegmentChunk);\n    await Promise.all(t);\n  }\n} {\n  constructor() {\n    super(...arguments), e(this, \"appSegments\", []), e(this, \"jpegSegments\", []), e(this, \"unknownSegments\", []);\n  }\n  static canHandle(e, t) {\n    return 65496 === t;\n  }\n  async parse() {\n    await this.findAppSegments(), await this.readSegments(this.appSegments), this.mergeMultiSegments(), this.createParsers(this.mergedAppSegments || this.appSegments);\n  }\n  setupSegmentFinderArgs(e) {\n    !0 === e ? (this.findAll = !0, this.wanted = new Set(y.keyList())) : (e = void 0 === e ? y.keyList().filter(e => this.options[e].enabled) : e.filter(e => this.options[e].enabled && y.has(e)), this.findAll = !1, this.remaining = new Set(e), this.wanted = new Set(e)), this.unfinishedMultiSegment = !1;\n  }\n  async findAppSegments() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let t = arguments.length > 1 ? arguments[1] : undefined;\n    this.setupSegmentFinderArgs(t);\n    let s = this.file,\n      i = this.findAll,\n      n = this.wanted,\n      r = this.remaining;\n    if (!i && this.file.chunked && (i = Array.from(n).some(e => {\n      let t = y.get(e),\n        s = this.options[e];\n      return t.multiSegment && s.multiSegment;\n    }), i && (await this.file.readWhole())), e = this.findAppSegmentsInRange(e, s.byteLength), !this.options.onlyTiff && s.chunked) {\n      let t = !1;\n      for (; r.size > 0 && !t && (s.canReadNextChunk || this.unfinishedMultiSegment);) {\n        let i = s.nextChunkOffset,\n          n = this.appSegments.some(e => !this.file.available(e.offset || e.start, e.length || e.size));\n        if (t = e > i && !n ? !(await s.readNextChunk(e)) : !(await s.readNextChunk(i)), void 0 === (e = this.findAppSegmentsInRange(e, s.byteLength))) return;\n      }\n    }\n  }\n  findAppSegmentsInRange(e, t) {\n    t -= 2;\n    let s,\n      i,\n      n,\n      r,\n      a,\n      h,\n      f = this.file,\n      l = this.findAll,\n      o = this.wanted,\n      u = this.remaining,\n      d = this.options;\n    for (; e < t; e++) if (255 === f.getUint8(e)) if (s = f.getUint8(e + 1), Q(s)) {\n      if (i = f.getUint16(e + 2), n = Z(f, e, i), n && o.has(n) && (r = y.get(n), a = r.findPosition(f, e), h = d[n], a.type = n, this.appSegments.push(a), !l && (r.multiSegment && h.multiSegment ? (this.unfinishedMultiSegment = a.chunkNumber < a.chunkCount, this.unfinishedMultiSegment || u.delete(n)) : u.delete(n), 0 === u.size))) break;\n      d.recordUnknownSegments && (a = J.findPosition(f, e), a.marker = s, this.unknownSegments.push(a)), e += i + 1;\n    } else if (q(s)) {\n      if (i = f.getUint16(e + 2), 218 === s && !1 !== d.stopAfterSos) return;\n      d.recordJpegSegments && this.jpegSegments.push({\n        offset: e,\n        length: i,\n        marker: s\n      }), e += i + 1;\n    }\n    return e;\n  }\n  mergeMultiSegments() {\n    if (!this.appSegments.some(e => e.multiSegment)) return;\n    let e = function (e, t) {\n      let s,\n        i,\n        n,\n        r = new Map();\n      for (let a = 0; a < e.length; a++) s = e[a], i = s[t], r.has(i) ? n = r.get(i) : r.set(i, n = []), n.push(s);\n      return Array.from(r);\n    }(this.appSegments, \"type\");\n    this.mergedAppSegments = e.map(_ref13 => {\n      let _ref14 = _slicedToArray(_ref13, 2),\n        e = _ref14[0],\n        t = _ref14[1];\n      let s = y.get(e, this.options);\n      if (s.handleMultiSegments) {\n        return {\n          type: e,\n          chunk: s.handleMultiSegments(t)\n        };\n      }\n      return t[0];\n    });\n  }\n  getSegment(e) {\n    return this.appSegments.find(t => t.type === e);\n  }\n  async getOrFindSegment(e) {\n    let t = this.getSegment(e);\n    return void 0 === t && (await this.findAppSegments(0, [e]), t = this.getSegment(e)), t;\n  }\n}\ne(ee, \"type\", \"jpeg\"), m.set(\"jpeg\", ee);\nconst te = [void 0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8, 4];\nclass se extends J {\n  parseHeader() {\n    var e = this.chunk.getUint16();\n    18761 === e ? this.le = !0 : 19789 === e && (this.le = !1), this.chunk.le = this.le, this.headerParsed = !0;\n  }\n  parseTags(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n    let _this$options$t = this.options[t],\n      i = _this$options$t.pick,\n      n = _this$options$t.skip;\n    i = new Set(i);\n    let r = i.size > 0,\n      a = 0 === n.size,\n      h = this.chunk.getUint16(e);\n    e += 2;\n    for (let f = 0; f < h; f++) {\n      let h = this.chunk.getUint16(e);\n      if (r) {\n        if (i.has(h) && (s.set(h, this.parseTag(e, h, t)), i.delete(h), 0 === i.size)) break;\n      } else !a && n.has(h) || s.set(h, this.parseTag(e, h, t));\n      e += 12;\n    }\n    return s;\n  }\n  parseTag(e, t, s) {\n    let i = this.chunk,\n      n = i.getUint16(e + 2),\n      r = i.getUint32(e + 4),\n      a = te[n];\n    if (a * r <= 4 ? e += 8 : e = i.getUint32(e + 8), (n < 1 || n > 13) && l(`Invalid TIFF value type. block: ${s.toUpperCase()}, tag: ${t.toString(16)}, type: ${n}, offset ${e}`), e > i.byteLength && l(`Invalid TIFF value offset. block: ${s.toUpperCase()}, tag: ${t.toString(16)}, type: ${n}, offset ${e} is outside of chunk size ${i.byteLength}`), 1 === n) return i.getUint8Array(e, r);\n    if (2 === n) return \"\" === (h = function (e) {\n      for (; e.endsWith(\"\\0\");) e = e.slice(0, -1);\n      return e;\n    }(h = i.getString(e, r)).trim()) ? void 0 : h;\n    var h;\n    if (7 === n) return i.getUint8Array(e, r);\n    if (1 === r) return this.parseTagValue(n, e);\n    {\n      let t = new (function (e) {\n          switch (e) {\n            case 1:\n              return Uint8Array;\n            case 3:\n              return Uint16Array;\n            case 4:\n              return Uint32Array;\n            case 5:\n              return Array;\n            case 6:\n              return Int8Array;\n            case 8:\n              return Int16Array;\n            case 9:\n              return Int32Array;\n            case 10:\n              return Array;\n            case 11:\n              return Float32Array;\n            case 12:\n              return Float64Array;\n            default:\n              return Array;\n          }\n        }(n))(r),\n        s = a;\n      for (let i = 0; i < r; i++) t[i] = this.parseTagValue(n, e), e += s;\n      return t;\n    }\n  }\n  parseTagValue(e, t) {\n    let s = this.chunk;\n    switch (e) {\n      case 1:\n        return s.getUint8(t);\n      case 3:\n        return s.getUint16(t);\n      case 4:\n        return s.getUint32(t);\n      case 5:\n        return s.getUint32(t) / s.getUint32(t + 4);\n      case 6:\n        return s.getInt8(t);\n      case 8:\n        return s.getInt16(t);\n      case 9:\n        return s.getInt32(t);\n      case 10:\n        return s.getInt32(t) / s.getInt32(t + 4);\n      case 11:\n        return s.getFloat(t);\n      case 12:\n        return s.getDouble(t);\n      case 13:\n        return s.getUint32(t);\n      default:\n        l(`Invalid tiff type ${e}`);\n    }\n  }\n}\nclass ie extends se {\n  static canHandle(e, t) {\n    return 225 === e.getUint8(t + 1) && 1165519206 === e.getUint32(t + 4) && 0 === e.getUint16(t + 8);\n  }\n  async parse() {\n    this.parseHeader();\n    let e = this.options;\n    return e.ifd0.enabled && (await this.parseIfd0Block()), e.exif.enabled && (await this.safeParse(\"parseExifBlock\")), e.gps.enabled && (await this.safeParse(\"parseGpsBlock\")), e.interop.enabled && (await this.safeParse(\"parseInteropBlock\")), e.ifd1.enabled && (await this.safeParse(\"parseThumbnailBlock\")), this.createOutput();\n  }\n  safeParse(e) {\n    let t = this[e]();\n    return void 0 !== t.catch && (t = t.catch(this.handleError)), t;\n  }\n  findIfd0Offset() {\n    void 0 === this.ifd0Offset && (this.ifd0Offset = this.chunk.getUint32(4));\n  }\n  findIfd1Offset() {\n    if (void 0 === this.ifd1Offset) {\n      this.findIfd0Offset();\n      let e = this.chunk.getUint16(this.ifd0Offset),\n        t = this.ifd0Offset + 2 + 12 * e;\n      this.ifd1Offset = this.chunk.getUint32(t);\n    }\n  }\n  parseBlock(e, t) {\n    let s = new Map();\n    return this[t] = s, this.parseTags(e, t, s), s;\n  }\n  async parseIfd0Block() {\n    if (this.ifd0) return;\n    let e = this.file;\n    this.findIfd0Offset(), this.ifd0Offset < 8 && l(\"Malformed EXIF data\"), !e.chunked && this.ifd0Offset > e.byteLength && l(`IFD0 offset points to outside of file.\\nthis.ifd0Offset: ${this.ifd0Offset}, file.byteLength: ${e.byteLength}`), e.tiff && (await e.ensureChunk(this.ifd0Offset, o(this.options)));\n    let t = this.parseBlock(this.ifd0Offset, \"ifd0\");\n    return 0 !== t.size ? (this.exifOffset = t.get(34665), this.interopOffset = t.get(40965), this.gpsOffset = t.get(34853), this.xmp = t.get(700), this.iptc = t.get(33723), this.icc = t.get(34675), this.options.sanitize && (t.delete(34665), t.delete(40965), t.delete(34853), t.delete(700), t.delete(33723), t.delete(34675)), t) : void 0;\n  }\n  async parseExifBlock() {\n    if (this.exif) return;\n    if (this.ifd0 || (await this.parseIfd0Block()), void 0 === this.exifOffset) return;\n    this.file.tiff && (await this.file.ensureChunk(this.exifOffset, o(this.options)));\n    let e = this.parseBlock(this.exifOffset, \"exif\");\n    return this.interopOffset || (this.interopOffset = e.get(40965)), this.makerNote = e.get(37500), this.userComment = e.get(37510), this.options.sanitize && (e.delete(40965), e.delete(37500), e.delete(37510)), this.unpack(e, 41728), this.unpack(e, 41729), e;\n  }\n  unpack(e, t) {\n    let s = e.get(t);\n    s && 1 === s.length && e.set(t, s[0]);\n  }\n  async parseGpsBlock() {\n    if (this.gps) return;\n    if (this.ifd0 || (await this.parseIfd0Block()), void 0 === this.gpsOffset) return;\n    let e = this.parseBlock(this.gpsOffset, \"gps\");\n    return e && e.has(2) && e.has(4) && (e.set(\"latitude\", ne(...e.get(2), e.get(1))), e.set(\"longitude\", ne(...e.get(4), e.get(3)))), e;\n  }\n  async parseInteropBlock() {\n    if (!this.interop && (this.ifd0 || (await this.parseIfd0Block()), void 0 !== this.interopOffset || this.exif || (await this.parseExifBlock()), void 0 !== this.interopOffset)) return this.parseBlock(this.interopOffset, \"interop\");\n  }\n  async parseThumbnailBlock() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    if (!this.ifd1 && !this.ifd1Parsed && (!this.options.mergeOutput || e)) return this.findIfd1Offset(), this.ifd1Offset > 0 && (this.parseBlock(this.ifd1Offset, \"ifd1\"), this.ifd1Parsed = !0), this.ifd1;\n  }\n  async extractThumbnail() {\n    if (this.headerParsed || this.parseHeader(), this.ifd1Parsed || (await this.parseThumbnailBlock(!0)), void 0 === this.ifd1) return;\n    let e = this.ifd1.get(513),\n      t = this.ifd1.get(514);\n    return this.chunk.getUint8Array(e, t);\n  }\n  get image() {\n    return this.ifd0;\n  }\n  get thumbnail() {\n    return this.ifd1;\n  }\n  createOutput() {\n    let e,\n      t,\n      s,\n      i = {};\n    for (t of P) if (e = this[t], !f(e)) if (s = this.canTranslate ? this.translateBlock(e, t) : Object.fromEntries(e), this.options.mergeOutput) {\n      if (\"ifd1\" === t) continue;\n      Object.assign(i, s);\n    } else i[t] = s;\n    return this.makerNote && (i.makerNote = this.makerNote), this.userComment && (i.userComment = this.userComment), i;\n  }\n  assignToOutput(e, t) {\n    if (this.globalOptions.mergeOutput) Object.assign(e, t);else for (let _ref15 of Object.entries(t)) {\n      var _ref16 = _slicedToArray(_ref15, 2);\n      let s = _ref16[0];\n      let i = _ref16[1];\n      this.assignObjectToOutput(e, s, i);\n    }\n  }\n}\nfunction ne(e, t, s, i) {\n  var n = e + t / 60 + s / 3600;\n  return \"S\" !== i && \"W\" !== i || (n *= -1), n;\n}\ne(ie, \"type\", \"tiff\"), e(ie, \"headerLength\", 10), y.set(\"tiff\", ie);\nvar re = Object.freeze({\n  __proto__: null,\n  default: G,\n  Exifr: H,\n  fileParsers: m,\n  segmentParsers: y,\n  fileReaders: b,\n  tagKeys: B,\n  tagValues: V,\n  tagRevivers: I,\n  createDictionary: x,\n  extendDictionary: C,\n  fetchUrlAsArrayBuffer: S,\n  readBlobAsArrayBuffer: A,\n  chunkedProps: L,\n  otherSegments: T,\n  segments: z,\n  tiffBlocks: P,\n  segmentsAndBlocks: F,\n  tiffExtractables: j,\n  inheritables: E,\n  allFormatters: M,\n  Options: R,\n  parse: Y\n});\nconst ae = {\n    ifd0: !1,\n    ifd1: !1,\n    exif: !1,\n    gps: !1,\n    interop: !1,\n    sanitize: !1,\n    reviveValues: !0,\n    translateKeys: !1,\n    translateValues: !1,\n    mergeOutput: !1\n  },\n  he = Object.assign({}, ae, {\n    firstChunkSize: 4e4,\n    gps: [1, 2, 3, 4]\n  });\nasync function fe(e) {\n  let t = new H(he);\n  await t.read(e);\n  let s = await t.parse();\n  if (s && s.gps) {\n    let _s$gps = s.gps,\n      e = _s$gps.latitude,\n      t = _s$gps.longitude;\n    return {\n      latitude: e,\n      longitude: t\n    };\n  }\n}\nconst le = Object.assign({}, ae, {\n  tiff: !1,\n  ifd1: !0,\n  mergeOutput: !1\n});\nasync function oe(e) {\n  let t = new H(le);\n  await t.read(e);\n  let s = await t.extractThumbnail();\n  return s && a ? r.from(s) : s;\n}\nasync function ue(e) {\n  let t = await this.thumbnail(e);\n  if (void 0 !== t) {\n    let e = new Blob([t]);\n    return URL.createObjectURL(e);\n  }\n}\nconst de = Object.assign({}, ae, {\n  firstChunkSize: 4e4,\n  ifd0: [274]\n});\nasync function ce(e) {\n  let t = new H(de);\n  await t.read(e);\n  let s = await t.parse();\n  if (s && s.ifd0) return s.ifd0[274];\n}\nconst pe = Object.freeze({\n  1: {\n    dimensionSwapped: !1,\n    scaleX: 1,\n    scaleY: 1,\n    deg: 0,\n    rad: 0\n  },\n  2: {\n    dimensionSwapped: !1,\n    scaleX: -1,\n    scaleY: 1,\n    deg: 0,\n    rad: 0\n  },\n  3: {\n    dimensionSwapped: !1,\n    scaleX: 1,\n    scaleY: 1,\n    deg: 180,\n    rad: 180 * Math.PI / 180\n  },\n  4: {\n    dimensionSwapped: !1,\n    scaleX: -1,\n    scaleY: 1,\n    deg: 180,\n    rad: 180 * Math.PI / 180\n  },\n  5: {\n    dimensionSwapped: !0,\n    scaleX: 1,\n    scaleY: -1,\n    deg: 90,\n    rad: 90 * Math.PI / 180\n  },\n  6: {\n    dimensionSwapped: !0,\n    scaleX: 1,\n    scaleY: 1,\n    deg: 90,\n    rad: 90 * Math.PI / 180\n  },\n  7: {\n    dimensionSwapped: !0,\n    scaleX: 1,\n    scaleY: -1,\n    deg: 270,\n    rad: 270 * Math.PI / 180\n  },\n  8: {\n    dimensionSwapped: !0,\n    scaleX: 1,\n    scaleY: 1,\n    deg: 270,\n    rad: 270 * Math.PI / 180\n  }\n});\nlet ge = !0,\n  me = !0;\nif (\"object\" == typeof navigator) {\n  let e = navigator.userAgent;\n  if (e.includes(\"iPad\") || e.includes(\"iPhone\")) {\n    let t = e.match(/OS (\\d+)_(\\d+)/);\n    if (t) {\n      let _t = _slicedToArray(t, 3),\n        e = _t[1],\n        s = _t[2],\n        i = Number(e) + .1 * Number(s);\n      ge = i < 13.4, me = !1;\n    }\n  } else if (e.includes(\"OS X 10\")) {\n    let _e$match = e.match(/OS X 10[_.](\\d+)/),\n      _e$match2 = _slicedToArray(_e$match, 2),\n      t = _e$match2[1];\n    ge = me = Number(t) < 15;\n  }\n  if (e.includes(\"Chrome/\")) {\n    let _e$match3 = e.match(/Chrome\\/(\\d+)/),\n      _e$match4 = _slicedToArray(_e$match3, 2),\n      t = _e$match4[1];\n    ge = me = Number(t) < 81;\n  } else if (e.includes(\"Firefox/\")) {\n    let _e$match5 = e.match(/Firefox\\/(\\d+)/),\n      _e$match6 = _slicedToArray(_e$match5, 2),\n      t = _e$match6[1];\n    ge = me = Number(t) < 77;\n  }\n}\nasync function ye(e) {\n  let t = await ce(e);\n  return Object.assign({\n    canvas: ge,\n    css: me\n  }, pe[t]);\n}\nclass be extends c {\n  constructor() {\n    super(...arguments), e(this, \"ranges\", new we()), 0 !== this.byteLength && this.ranges.add(0, this.byteLength);\n  }\n  _tryExtend(e, t, s) {\n    if (0 === e && 0 === this.byteLength && s) {\n      let e = new DataView(s.buffer || s, s.byteOffset, s.byteLength);\n      this._swapDataView(e);\n    } else {\n      let s = e + t;\n      if (s > this.byteLength) {\n        let _this$_extend = this._extend(s),\n          e = _this$_extend.dataView;\n        this._swapDataView(e);\n      }\n    }\n  }\n  _extend(e) {\n    let t;\n    t = a ? r.allocUnsafe(e) : new Uint8Array(e);\n    let s = new DataView(t.buffer, t.byteOffset, t.byteLength);\n    return t.set(new Uint8Array(this.buffer, this.byteOffset, this.byteLength), 0), {\n      uintView: t,\n      dataView: s\n    };\n  }\n  subarray(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n    return t = t || this._lengthToEnd(e), s && this._tryExtend(e, t), this.ranges.add(e, t), super.subarray(e, t);\n  }\n  set(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n    s && this._tryExtend(t, e.byteLength, e);\n    let i = super.set(e, t);\n    return this.ranges.add(t, i.byteLength), i;\n  }\n  async ensureChunk(e, t) {\n    this.chunked && (this.ranges.available(e, t) || (await this.readChunk(e, t)));\n  }\n  available(e, t) {\n    return this.ranges.available(e, t);\n  }\n}\nclass we {\n  constructor() {\n    e(this, \"list\", []);\n  }\n  get length() {\n    return this.list.length;\n  }\n  add(e, t) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let i = e + t,\n      n = this.list.filter(t => ke(e, t.offset, i) || ke(e, t.end, i));\n    if (n.length > 0) {\n      e = Math.min(e, ...n.map(e => e.offset)), i = Math.max(i, ...n.map(e => e.end)), t = i - e;\n      let s = n.shift();\n      s.offset = e, s.length = t, s.end = i, this.list = this.list.filter(e => !n.includes(e));\n    } else this.list.push({\n      offset: e,\n      length: t,\n      end: i\n    });\n  }\n  available(e, t) {\n    let s = e + t;\n    return this.list.some(t => t.offset <= e && s <= t.end);\n  }\n}\nfunction ke(e, t, s) {\n  return e <= t && t <= s;\n}\nclass Oe extends be {\n  constructor(t, s) {\n    super(0), e(this, \"chunksRead\", 0), this.input = t, this.options = s;\n  }\n  async readWhole() {\n    this.chunked = !1, await this.readChunk(this.nextChunkOffset);\n  }\n  async readChunked() {\n    this.chunked = !0, await this.readChunk(0, this.options.firstChunkSize);\n  }\n  async readNextChunk() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.nextChunkOffset;\n    if (this.fullyRead) return this.chunksRead++, !1;\n    let t = this.options.chunkSize,\n      s = await this.readChunk(e, t);\n    return !!s && s.byteLength === t;\n  }\n  async readChunk(e, t) {\n    if (this.chunksRead++, 0 !== (t = this.safeWrapAddress(e, t))) return this._readChunk(e, t);\n  }\n  safeWrapAddress(e, t) {\n    return void 0 !== this.size && e + t > this.size ? Math.max(0, this.size - e) : t;\n  }\n  get nextChunkOffset() {\n    if (0 !== this.ranges.list.length) return this.ranges.list[0].length;\n  }\n  get canReadNextChunk() {\n    return this.chunksRead < this.options.chunkLimit;\n  }\n  get fullyRead() {\n    return void 0 !== this.size && this.nextChunkOffset === this.size;\n  }\n  read() {\n    return this.options.chunked ? this.readChunked() : this.readWhole();\n  }\n  close() {}\n}\nb.set(\"blob\", class extends Oe {\n  async readWhole() {\n    this.chunked = !1;\n    let e = await A(this.input);\n    this._swapArrayBuffer(e);\n  }\n  readChunked() {\n    return this.chunked = !0, this.size = this.input.size, super.readChunked();\n  }\n  async _readChunk(e, t) {\n    let s = t ? e + t : void 0,\n      i = this.input.slice(e, s),\n      n = await A(i);\n    return this.set(n, e, !0);\n  }\n});\nexport default re;\nexport { H as Exifr, R as Options, M as allFormatters, L as chunkedProps, x as createDictionary, C as extendDictionary, S as fetchUrlAsArrayBuffer, m as fileParsers, b as fileReaders, fe as gps, he as gpsOnlyOptions, E as inheritables, ce as orientation, de as orientationOnlyOptions, T as otherSegments, Y as parse, A as readBlobAsArrayBuffer, ge as rotateCanvas, me as rotateCss, ye as rotation, pe as rotations, y as segmentParsers, z as segments, F as segmentsAndBlocks, B as tagKeys, I as tagRevivers, V as tagValues, oe as thumbnail, le as thumbnailOnlyOptions, ue as thumbnailUrl, P as tiffBlocks, j as tiffExtractables };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}