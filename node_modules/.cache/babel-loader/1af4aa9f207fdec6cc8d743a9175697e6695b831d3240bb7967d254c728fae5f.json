{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport { h } from 'preact';\nimport AuthView from \"./AuthView.js\";\nimport Header from \"./Header.js\";\nimport Browser from \"../Browser.js\";\nimport LoaderView from \"../Loader.js\";\nimport CloseWrapper from '../CloseWrapper.js';\nimport View from '../View.js';\nconst packageJson = {\n  \"version\": \"3.0.2\"\n};\nfunction getOrigin() {\n  // eslint-disable-next-line no-restricted-globals\n  return location.origin;\n}\nfunction getRegex(value) {\n  if (typeof value === 'string') {\n    return new RegExp(`^${value}$`);\n  }\n  if (value instanceof RegExp) {\n    return value;\n  }\n  return undefined;\n}\nfunction isOriginAllowed(origin, allowedOrigin) {\n  const patterns = Array.isArray(allowedOrigin) ? allowedOrigin.map(getRegex) : [getRegex(allowedOrigin)];\n  return patterns.some(pattern => (pattern == null ? void 0 : pattern.test(origin)) || (pattern == null ? void 0 : pattern.test(`${origin}/`))); // allowing for trailing '/'\n}\n/**\n * Class to easily generate generic views for Provider plugins\n */\n\nvar _updateFilesAndFolders = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateFilesAndFolders\");\nexport default class ProviderView extends View {\n  /**\n   * @param {object} plugin instance of the plugin\n   * @param {object} opts\n   */\n  constructor(plugin, opts) {\n    super(plugin, opts); // set default options\n\n    Object.defineProperty(this, _updateFilesAndFolders, {\n      value: _updateFilesAndFolders2\n    });\n    const defaultOptions = {\n      viewType: 'list',\n      showTitles: true,\n      showFilter: true,\n      showBreadcrumbs: true\n    }; // merge default options with the ones set by user\n\n    this.opts = _objectSpread(_objectSpread({}, defaultOptions), opts); // Logic\n\n    this.filterQuery = this.filterQuery.bind(this);\n    this.getFolder = this.getFolder.bind(this);\n    this.getNextFolder = this.getNextFolder.bind(this);\n    this.logout = this.logout.bind(this);\n    this.handleAuth = this.handleAuth.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n    this.listAllFiles = this.listAllFiles.bind(this);\n    this.donePicking = this.donePicking.bind(this); // Visual\n\n    this.render = this.render.bind(this); // Set default state for the plugin\n\n    this.plugin.setPluginState({\n      authenticated: false,\n      files: [],\n      folders: [],\n      directories: [],\n      filterInput: '',\n      isSearchVisible: false,\n      currentSelection: []\n    });\n  } // eslint-disable-next-line class-methods-use-this\n\n  tearDown() {// Nothing.\n  }\n\n  /**\n   * Based on folder ID, fetch a new folder and update it to state\n   *\n   * @param  {string} id Folder id\n   * @returns {Promise}   Folders/files in folder\n   */\n  getFolder(id, name) {\n    return this.sharedHandler.loaderWrapper(this.provider.list(id), res => {\n      const folders = [];\n      const files = [];\n      let updatedDirectories;\n      const state = this.plugin.getPluginState();\n      const index = state.directories.findIndex(dir => id === dir.id);\n      if (index !== -1) {\n        updatedDirectories = state.directories.slice(0, index + 1);\n      } else {\n        updatedDirectories = state.directories.concat([{\n          id,\n          title: name\n        }]);\n      }\n      this.username = res.username || this.username;\n      _classPrivateFieldLooseBase(this, _updateFilesAndFolders)[_updateFilesAndFolders](res, files, folders);\n      this.plugin.setPluginState({\n        directories: updatedDirectories,\n        filterInput: ''\n      });\n    }, this.handleError);\n  }\n  /**\n   * Fetches new folder\n   *\n   * @param  {object} folder\n   */\n\n  getNextFolder(folder) {\n    this.getFolder(folder.requestPath, folder.name);\n    this.lastCheckbox = undefined;\n  }\n  /**\n   * Removes session token on client side.\n   */\n\n  logout() {\n    this.provider.logout().then(res => {\n      if (res.ok) {\n        if (!res.revoked) {\n          const message = this.plugin.uppy.i18n('companionUnauthorizeHint', {\n            provider: this.plugin.title,\n            url: res.manual_revoke_url\n          });\n          this.plugin.uppy.info(message, 'info', 7000);\n        }\n        const newState = {\n          authenticated: false,\n          files: [],\n          folders: [],\n          directories: [],\n          filterInput: ''\n        };\n        this.plugin.setPluginState(newState);\n      }\n    }).catch(this.handleError);\n  }\n  filterQuery(e) {\n    const state = this.plugin.getPluginState();\n    this.plugin.setPluginState(_objectSpread(_objectSpread({}, state), {}, {\n      filterInput: e ? e.target.value : ''\n    }));\n  }\n  /**\n   * Adds all files found inside of specified folder.\n   *\n   * Uses separated state while folder contents are being fetched and\n   * mantains list of selected folders, which are separated from files.\n   */\n\n  addFolder(folder) {\n    const folderId = this.providerFileToId(folder);\n    const folders = _objectSpread({}, this.plugin.getPluginState().selectedFolders);\n    if (folderId in folders && folders[folderId].loading) {\n      return;\n    }\n    folders[folderId] = {\n      loading: true,\n      files: []\n    };\n    this.plugin.setPluginState({\n      selectedFolders: _objectSpread({}, folders)\n    }); // eslint-disable-next-line consistent-return\n\n    return this.listAllFiles(folder.requestPath).then(files => {\n      let count = 0; // If the same folder is added again, we don't want to send\n      // X amount of duplicate file notifications, we want to say\n      // the folder was already added. This checks if all files are duplicate,\n      // if that's the case, we don't add the files.\n\n      files.forEach(file => {\n        const id = this.providerFileToId(file);\n        if (!this.plugin.uppy.checkIfFileAlreadyExists(id)) {\n          count++;\n        }\n      });\n      if (count > 0) {\n        files.forEach(file => this.addFile(file));\n      }\n      const ids = files.map(this.providerFileToId);\n      folders[folderId] = {\n        loading: false,\n        files: ids\n      };\n      this.plugin.setPluginState({\n        selectedFolders: folders,\n        filterInput: ''\n      });\n      let message;\n      if (count === 0) {\n        message = this.plugin.uppy.i18n('folderAlreadyAdded', {\n          folder: folder.name\n        });\n      } else if (files.length) {\n        message = this.plugin.uppy.i18n('folderAdded', {\n          smart_count: count,\n          folder: folder.name\n        });\n      } else {\n        message = this.plugin.uppy.i18n('emptyFolderAdded');\n      }\n      this.plugin.uppy.info(message);\n    }).catch(e => {\n      const selectedFolders = _objectSpread({}, this.plugin.getPluginState().selectedFolders);\n      delete selectedFolders[folderId];\n      this.plugin.setPluginState({\n        selectedFolders\n      });\n      this.handleError(e);\n    });\n  }\n  async handleAuth() {\n    await this.provider.ensurePreAuth();\n    const authState = btoa(JSON.stringify({\n      origin: getOrigin()\n    }));\n    const clientVersion = `@uppy/provider-views=${ProviderView.VERSION}`;\n    const link = this.provider.authUrl({\n      state: authState,\n      uppyVersions: clientVersion\n    });\n    const authWindow = window.open(link, '_blank');\n    const handleToken = e => {\n      if (e.source !== authWindow) {\n        this.plugin.uppy.log('rejecting event from unknown source');\n        return;\n      }\n      if (!isOriginAllowed(e.origin, this.plugin.opts.companionAllowedHosts) || e.source !== authWindow) {\n        this.plugin.uppy.log(`rejecting event from ${e.origin} vs allowed pattern ${this.plugin.opts.companionAllowedHosts}`);\n      } // Check if it's a string before doing the JSON.parse to maintain support\n      // for older Companion versions that used object references\n\n      const data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;\n      if (data.error) {\n        this.plugin.uppy.log('auth aborted', 'warning');\n        const uppy = this.plugin.uppy;\n        const message = uppy.i18n('authAborted');\n        uppy.info({\n          message\n        }, 'warning', 5000);\n        return;\n      }\n      if (!data.token) {\n        this.plugin.uppy.log('did not receive token from auth window', 'error');\n        return;\n      }\n      authWindow.close();\n      window.removeEventListener('message', handleToken);\n      this.provider.setAuthToken(data.token);\n      this.preFirstRender();\n    };\n    window.addEventListener('message', handleToken);\n  }\n  async handleScroll(event) {\n    const path = this.nextPagePath || null;\n    if (this.shouldHandleScroll(event) && path) {\n      this.isHandlingScroll = true;\n      try {\n        const response = await this.provider.list(path);\n        const _this$plugin$getPlugi = this.plugin.getPluginState(),\n          files = _this$plugin$getPlugi.files,\n          folders = _this$plugin$getPlugi.folders;\n        _classPrivateFieldLooseBase(this, _updateFilesAndFolders)[_updateFilesAndFolders](response, files, folders);\n      } catch (error) {\n        this.handleError(error);\n      } finally {\n        this.isHandlingScroll = false;\n      }\n    }\n  }\n  async listAllFiles(path, files) {\n    if (files === void 0) {\n      files = null;\n    }\n    files = files || []; // eslint-disable-line no-param-reassign\n\n    const res = await this.provider.list(path);\n    res.items.forEach(item => {\n      if (!item.isFolder) {\n        files.push(item);\n      } else {\n        this.addFolder(item);\n      }\n    });\n    const moreFiles = res.nextPagePath;\n    if (moreFiles) {\n      return this.listAllFiles(moreFiles, files);\n    }\n    return files;\n  }\n  donePicking() {\n    const _this$plugin$getPlugi2 = this.plugin.getPluginState(),\n      currentSelection = _this$plugin$getPlugi2.currentSelection;\n    const promises = currentSelection.map(file => {\n      if (file.isFolder) {\n        return this.addFolder(file);\n      }\n      return this.addFile(file);\n    });\n    this.sharedHandler.loaderWrapper(Promise.all(promises), () => {\n      this.clearSelection();\n    }, () => {});\n  }\n  render(state, viewOptions) {\n    var _this = this;\n    if (viewOptions === void 0) {\n      viewOptions = {};\n    }\n    const _this$plugin$getPlugi3 = this.plugin.getPluginState(),\n      authenticated = _this$plugin$getPlugi3.authenticated,\n      didFirstRender = _this$plugin$getPlugi3.didFirstRender;\n    if (!didFirstRender) {\n      this.preFirstRender();\n    }\n    const targetViewOptions = _objectSpread(_objectSpread({}, this.opts), viewOptions);\n    const _this$plugin$getPlugi4 = this.plugin.getPluginState(),\n      files = _this$plugin$getPlugi4.files,\n      folders = _this$plugin$getPlugi4.folders,\n      filterInput = _this$plugin$getPlugi4.filterInput,\n      loading = _this$plugin$getPlugi4.loading,\n      currentSelection = _this$plugin$getPlugi4.currentSelection;\n    const _this$sharedHandler = this.sharedHandler,\n      isChecked = _this$sharedHandler.isChecked,\n      toggleCheckbox = _this$sharedHandler.toggleCheckbox,\n      recordShiftKeyPress = _this$sharedHandler.recordShiftKeyPress,\n      filterItems = _this$sharedHandler.filterItems;\n    const hasInput = filterInput !== '';\n    const headerProps = {\n      showBreadcrumbs: targetViewOptions.showBreadcrumbs,\n      getFolder: this.getFolder,\n      directories: this.plugin.getPluginState().directories,\n      pluginIcon: this.plugin.icon,\n      title: this.plugin.title,\n      logout: this.logout,\n      username: this.username,\n      i18n: this.plugin.uppy.i18n\n    };\n    const browserProps = {\n      isChecked,\n      toggleCheckbox,\n      recordShiftKeyPress,\n      currentSelection,\n      files: hasInput ? filterItems(files) : files,\n      folders: hasInput ? filterItems(folders) : folders,\n      username: this.username,\n      getNextFolder: this.getNextFolder,\n      getFolder: this.getFolder,\n      filterItems: this.sharedHandler.filterItems,\n      filterQuery: this.filterQuery,\n      logout: this.logout,\n      handleScroll: this.handleScroll,\n      listAllFiles: this.listAllFiles,\n      done: this.donePicking,\n      cancel: this.cancelPicking,\n      headerComponent: Header(headerProps),\n      title: this.plugin.title,\n      viewType: targetViewOptions.viewType,\n      showTitles: targetViewOptions.showTitles,\n      showFilter: targetViewOptions.showFilter,\n      showBreadcrumbs: targetViewOptions.showBreadcrumbs,\n      pluginIcon: this.plugin.icon,\n      i18n: this.plugin.uppy.i18n,\n      uppyFiles: this.plugin.uppy.getFiles(),\n      validateRestrictions: function () {\n        return _this.plugin.uppy.validateRestrictions(...arguments);\n      }\n    };\n    if (loading) {\n      return h(CloseWrapper, {\n        onUnmount: this.clearSelection\n      }, h(LoaderView, {\n        i18n: this.plugin.uppy.i18n\n      }));\n    }\n    if (!authenticated) {\n      return h(CloseWrapper, {\n        onUnmount: this.clearSelection\n      }, h(AuthView, {\n        pluginName: this.plugin.title,\n        pluginIcon: this.plugin.icon,\n        handleAuth: this.handleAuth,\n        i18n: this.plugin.uppy.i18n,\n        i18nArray: this.plugin.uppy.i18nArray\n      }));\n    }\n    return h(CloseWrapper, {\n      onUnmount: this.clearSelection\n    }, h(Browser, browserProps));\n  }\n}\nfunction _updateFilesAndFolders2(res, files, folders) {\n  this.nextPagePath = res.nextPagePath;\n  res.items.forEach(item => {\n    if (item.isFolder) {\n      folders.push(item);\n    } else {\n      files.push(item);\n    }\n  });\n  this.plugin.setPluginState({\n    folders,\n    files\n  });\n}\nProviderView.VERSION = packageJson.version;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}