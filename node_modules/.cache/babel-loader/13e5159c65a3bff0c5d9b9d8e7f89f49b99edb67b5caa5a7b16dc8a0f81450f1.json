{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nlet _Symbol$for;\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport { nanoid } from 'nanoid/non-secure';\nconst packageJson = {\n  \"version\": \"3.0.2\"\n}; // Redux action name.\n\nexport const STATE_UPDATE = 'uppy/STATE_UPDATE'; // Pluck Uppy state from the Redux store in the default location.\n\nconst defaultSelector = id => state => state.uppy[id];\nfunction getPatch(prev, next) {\n  const nextKeys = Object.keys(next);\n  const patch = {};\n  nextKeys.forEach(k => {\n    if (prev[k] !== next[k]) patch[k] = next[k];\n  });\n  return patch;\n}\n/**\n * Redux store.\n *\n * @param {object} opts.store - The Redux store to use.\n * @param {string} opts.id - This store instance's ID. Defaults to a random string.\n *    If you need to access Uppy state through Redux, eg. to render custom UI, set this to something constant.\n * @param {Function} opts.selector - Function, `(state) => uppyState`, to pluck state from the Redux store.\n *    Defaults to retrieving `state.uppy[opts.id]`. Override if you placed Uppy state elsewhere in the Redux store.\n */\n\nvar _id = /*#__PURE__*/_classPrivateFieldLooseKey(\"id\");\nvar _selector = /*#__PURE__*/_classPrivateFieldLooseKey(\"selector\");\nvar _store = /*#__PURE__*/_classPrivateFieldLooseKey(\"store\");\n_Symbol$for = Symbol.for('uppy test: get id');\nexport class ReduxStore {\n  constructor(opts) {\n    Object.defineProperty(this, _id, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _selector, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _store, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _store)[_store] = opts.store;\n    _classPrivateFieldLooseBase(this, _id)[_id] = opts.id || nanoid();\n    _classPrivateFieldLooseBase(this, _selector)[_selector] = opts.selector || defaultSelector(_classPrivateFieldLooseBase(this, _id)[_id]); // Calling `setState` to dispatch an action to the Redux store.\n    // The intent is to make sure that the reducer has run once.\n\n    this.setState({});\n  }\n  setState(patch) {\n    _classPrivateFieldLooseBase(this, _store)[_store].dispatch({\n      type: STATE_UPDATE,\n      id: _classPrivateFieldLooseBase(this, _id)[_id],\n      payload: patch\n    });\n  }\n  getState() {\n    return _classPrivateFieldLooseBase(this, _selector)[_selector](_classPrivateFieldLooseBase(this, _store)[_store].getState());\n  }\n  subscribe(cb) {\n    let prevState = this.getState();\n    return _classPrivateFieldLooseBase(this, _store)[_store].subscribe(() => {\n      const nextState = this.getState();\n      if (prevState !== nextState) {\n        const patch = getPatch(prevState, nextState);\n        cb(prevState, nextState, patch);\n        prevState = nextState;\n      }\n    });\n  }\n  [_Symbol$for]() {\n    return _classPrivateFieldLooseBase(this, _id)[_id];\n  }\n}\nReduxStore.VERSION = packageJson.version;\nexport function reducer(state, action) {\n  if (state === void 0) {\n    state = {};\n  }\n  if (action.type === STATE_UPDATE) {\n    const newState = _objectSpread(_objectSpread({}, state[action.id]), action.payload);\n    return _objectSpread(_objectSpread({}, state), {}, {\n      [action.id]: newState\n    });\n  }\n  return state;\n}\nexport function middleware() {\n  // Do nothing, at the moment.\n  return () => next => action => {\n    next(action);\n  };\n}\nexport default ReduxStore;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}