{"ast":null,"code":"var _class, _temp;\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar _require = require('@uppy/core'),\n  Plugin = _require.Plugin;\nvar _require2 = require('@uppy/companion-client'),\n  Socket = _require2.Socket,\n  Provider = _require2.Provider,\n  RequestClient = _require2.RequestClient;\nvar EventTracker = require('@uppy/utils/lib/EventTracker');\nvar emitSocketProgress = require('@uppy/utils/lib/emitSocketProgress');\nvar getSocketHost = require('@uppy/utils/lib/getSocketHost');\nvar RateLimitedQueue = require('@uppy/utils/lib/RateLimitedQueue');\nvar Uploader = require('./MultipartUploader');\nfunction assertServerError(res) {\n  if (res && res.error) {\n    var error = new Error(res.message);\n    _extends(error, res.error);\n    throw error;\n  }\n  return res;\n}\nmodule.exports = (_temp = _class = /*#__PURE__*/function (_Plugin) {\n  _inheritsLoose(AwsS3Multipart, _Plugin);\n  function AwsS3Multipart(uppy, opts) {\n    var _this;\n    _this = _Plugin.call(this, uppy, opts) || this;\n    _this.type = 'uploader';\n    _this.id = _this.opts.id || 'AwsS3Multipart';\n    _this.title = 'AWS S3 Multipart';\n    _this.client = new RequestClient(uppy, opts);\n    var defaultOptions = {\n      timeout: 30 * 1000,\n      limit: 0,\n      retryDelays: [0, 1000, 3000, 5000],\n      createMultipartUpload: _this.createMultipartUpload.bind(_assertThisInitialized(_this)),\n      listParts: _this.listParts.bind(_assertThisInitialized(_this)),\n      prepareUploadPart: _this.prepareUploadPart.bind(_assertThisInitialized(_this)),\n      abortMultipartUpload: _this.abortMultipartUpload.bind(_assertThisInitialized(_this)),\n      completeMultipartUpload: _this.completeMultipartUpload.bind(_assertThisInitialized(_this))\n    };\n    _this.opts = _extends({}, defaultOptions, opts);\n    _this.upload = _this.upload.bind(_assertThisInitialized(_this));\n    _this.requests = new RateLimitedQueue(_this.opts.limit);\n    _this.uploaders = Object.create(null);\n    _this.uploaderEvents = Object.create(null);\n    _this.uploaderSockets = Object.create(null);\n    return _this;\n  }\n  /**\n   * Clean up all references for a file's upload: the MultipartUploader instance,\n   * any events related to the file, and the Companion WebSocket connection.\n   *\n   * Set `opts.abort` to tell S3 that the multipart upload is cancelled and must be removed.\n   * This should be done when the user cancels the upload, not when the upload is completed or errored.\n   */\n\n  var _proto = AwsS3Multipart.prototype;\n  _proto.resetUploaderReferences = function resetUploaderReferences(fileID, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    if (this.uploaders[fileID]) {\n      this.uploaders[fileID].abort({\n        really: opts.abort || false\n      });\n      this.uploaders[fileID] = null;\n    }\n    if (this.uploaderEvents[fileID]) {\n      this.uploaderEvents[fileID].remove();\n      this.uploaderEvents[fileID] = null;\n    }\n    if (this.uploaderSockets[fileID]) {\n      this.uploaderSockets[fileID].close();\n      this.uploaderSockets[fileID] = null;\n    }\n  };\n  _proto.assertHost = function assertHost(method) {\n    if (!this.opts.companionUrl) {\n      throw new Error(\"Expected a `companionUrl` option containing a Companion address, or if you are not using Companion, a custom `\" + method + \"` implementation.\");\n    }\n  };\n  _proto.createMultipartUpload = function createMultipartUpload(file) {\n    this.assertHost('createMultipartUpload');\n    var metadata = {};\n    Object.keys(file.meta).map(function (key) {\n      if (file.meta[key] != null) {\n        metadata[key] = file.meta[key].toString();\n      }\n    });\n    return this.client.post('s3/multipart', {\n      filename: file.name,\n      type: file.type,\n      metadata: metadata\n    }).then(assertServerError);\n  };\n  _proto.listParts = function listParts(file, _ref) {\n    var key = _ref.key,\n      uploadId = _ref.uploadId;\n    this.assertHost('listParts');\n    var filename = encodeURIComponent(key);\n    return this.client.get(\"s3/multipart/\" + uploadId + \"?key=\" + filename).then(assertServerError);\n  };\n  _proto.prepareUploadPart = function prepareUploadPart(file, _ref2) {\n    var key = _ref2.key,\n      uploadId = _ref2.uploadId,\n      number = _ref2.number;\n    this.assertHost('prepareUploadPart');\n    var filename = encodeURIComponent(key);\n    return this.client.get(\"s3/multipart/\" + uploadId + \"/\" + number + \"?key=\" + filename).then(assertServerError);\n  };\n  _proto.completeMultipartUpload = function completeMultipartUpload(file, _ref3) {\n    var key = _ref3.key,\n      uploadId = _ref3.uploadId,\n      parts = _ref3.parts;\n    this.assertHost('completeMultipartUpload');\n    var filename = encodeURIComponent(key);\n    var uploadIdEnc = encodeURIComponent(uploadId);\n    return this.client.post(\"s3/multipart/\" + uploadIdEnc + \"/complete?key=\" + filename, {\n      parts: parts\n    }).then(assertServerError);\n  };\n  _proto.abortMultipartUpload = function abortMultipartUpload(file, _ref4) {\n    var key = _ref4.key,\n      uploadId = _ref4.uploadId;\n    this.assertHost('abortMultipartUpload');\n    var filename = encodeURIComponent(key);\n    var uploadIdEnc = encodeURIComponent(uploadId);\n    return this.client.delete(\"s3/multipart/\" + uploadIdEnc + \"?key=\" + filename).then(assertServerError);\n  };\n  _proto.uploadFile = function uploadFile(file) {\n    var _this2 = this;\n    return new Promise(function (resolve, reject) {\n      var onStart = function onStart(data) {\n        var cFile = _this2.uppy.getFile(file.id);\n        _this2.uppy.setFileState(file.id, {\n          s3Multipart: _extends({}, cFile.s3Multipart, {\n            key: data.key,\n            uploadId: data.uploadId\n          })\n        });\n      };\n      var onProgress = function onProgress(bytesUploaded, bytesTotal) {\n        _this2.uppy.emit('upload-progress', file, {\n          uploader: _this2,\n          bytesUploaded: bytesUploaded,\n          bytesTotal: bytesTotal\n        });\n      };\n      var onError = function onError(err) {\n        _this2.uppy.log(err);\n        _this2.uppy.emit('upload-error', file, err);\n        queuedRequest.done();\n        _this2.resetUploaderReferences(file.id);\n        reject(err);\n      };\n      var onSuccess = function onSuccess(result) {\n        var uploadResp = {\n          body: _extends({}, result),\n          uploadURL: result.location\n        };\n        queuedRequest.done();\n        _this2.resetUploaderReferences(file.id);\n        var cFile = _this2.uppy.getFile(file.id);\n        _this2.uppy.emit('upload-success', cFile || file, uploadResp);\n        if (result.location) {\n          _this2.uppy.log(\"Download \" + upload.file.name + \" from \" + result.location);\n        }\n        resolve(upload);\n      };\n      var onPartComplete = function onPartComplete(part) {\n        var cFile = _this2.uppy.getFile(file.id);\n        if (!cFile) {\n          return;\n        }\n        _this2.uppy.emit('s3-multipart:part-uploaded', cFile, part);\n      };\n      var upload = new Uploader(file.data, _extends({\n        // .bind to pass the file object to each handler.\n        createMultipartUpload: _this2.opts.createMultipartUpload.bind(_this2, file),\n        listParts: _this2.opts.listParts.bind(_this2, file),\n        prepareUploadPart: _this2.opts.prepareUploadPart.bind(_this2, file),\n        completeMultipartUpload: _this2.opts.completeMultipartUpload.bind(_this2, file),\n        abortMultipartUpload: _this2.opts.abortMultipartUpload.bind(_this2, file),\n        getChunkSize: _this2.opts.getChunkSize ? _this2.opts.getChunkSize.bind(_this2) : null,\n        onStart: onStart,\n        onProgress: onProgress,\n        onError: onError,\n        onSuccess: onSuccess,\n        onPartComplete: onPartComplete,\n        limit: _this2.opts.limit || 5,\n        retryDelays: _this2.opts.retryDelays || []\n      }, file.s3Multipart));\n      _this2.uploaders[file.id] = upload;\n      _this2.uploaderEvents[file.id] = new EventTracker(_this2.uppy);\n      var queuedRequest = _this2.requests.run(function () {\n        if (!file.isPaused) {\n          upload.start();\n        } // Don't do anything here, the caller will take care of cancelling the upload itself\n        // using resetUploaderReferences(). This is because resetUploaderReferences() has to be\n        // called when this request is still in the queue, and has not been started yet, too. At\n        // that point this cancellation function is not going to be called.\n\n        return function () {};\n      });\n      _this2.onFileRemove(file.id, function (removed) {\n        queuedRequest.abort();\n        _this2.resetUploaderReferences(file.id, {\n          abort: true\n        });\n        resolve(\"upload \" + removed.id + \" was removed\");\n      });\n      _this2.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n        _this2.resetUploaderReferences(file.id, {\n          abort: true\n        });\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n      _this2.onFilePause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          upload.pause();\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this2.requests.run(function () {\n            upload.start();\n            return function () {};\n          });\n        }\n      });\n      _this2.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        upload.pause();\n      });\n      _this2.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n        if (file.error) {\n          upload.abort();\n        }\n        queuedRequest = _this2.requests.run(function () {\n          upload.start();\n          return function () {};\n        });\n      }); // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n\n      if (!file.progress.uploadStarted || !file.isRestored) {\n        _this2.uppy.emit('upload-started', file);\n      }\n    });\n  };\n  _proto.uploadRemote = function uploadRemote(file) {\n    var _this3 = this;\n    this.resetUploaderReferences(file.id); // Don't double-emit upload-started for Golden Retriever-restored files that were already started\n\n    if (!file.progress.uploadStarted || !file.isRestored) {\n      this.uppy.emit('upload-started', file);\n    }\n    if (file.serverToken) {\n      return this.connectToServerSocket(file);\n    }\n    return new Promise(function (resolve, reject) {\n      var Client = file.remote.providerOptions.provider ? Provider : RequestClient;\n      var client = new Client(_this3.uppy, file.remote.providerOptions);\n      client.post(file.remote.url, _extends({}, file.remote.body, {\n        protocol: 's3-multipart',\n        size: file.data.size,\n        metadata: file.meta\n      })).then(function (res) {\n        _this3.uppy.setFileState(file.id, {\n          serverToken: res.token\n        });\n        file = _this3.uppy.getFile(file.id);\n        return file;\n      }).then(function (file) {\n        return _this3.connectToServerSocket(file);\n      }).then(function () {\n        resolve();\n      }).catch(function (err) {\n        _this3.uppy.emit('upload-error', file, err);\n        reject(err);\n      });\n    });\n  };\n  _proto.connectToServerSocket = function connectToServerSocket(file) {\n    var _this4 = this;\n    return new Promise(function (resolve, reject) {\n      var token = file.serverToken;\n      var host = getSocketHost(file.remote.companionUrl);\n      var socket = new Socket({\n        target: host + \"/api/\" + token,\n        autoOpen: false\n      });\n      _this4.uploaderSockets[file.id] = socket;\n      _this4.uploaderEvents[file.id] = new EventTracker(_this4.uppy);\n      _this4.onFileRemove(file.id, function (removed) {\n        queuedRequest.abort();\n        socket.send('pause', {});\n        _this4.resetUploaderReferences(file.id, {\n          abort: true\n        });\n        resolve(\"upload \" + file.id + \" was removed\");\n      });\n      _this4.onFilePause(file.id, function (isPaused) {\n        if (isPaused) {\n          // Remove this file from the queue so another file can start in its place.\n          queuedRequest.abort();\n          socket.send('pause', {});\n        } else {\n          // Resuming an upload should be queued, else you could pause and then resume a queued upload to make it skip the queue.\n          queuedRequest.abort();\n          queuedRequest = _this4.requests.run(function () {\n            socket.send('resume', {});\n            return function () {};\n          });\n        }\n      });\n      _this4.onPauseAll(file.id, function () {\n        queuedRequest.abort();\n        socket.send('pause', {});\n      });\n      _this4.onCancelAll(file.id, function () {\n        queuedRequest.abort();\n        socket.send('pause', {});\n        _this4.resetUploaderReferences(file.id);\n        resolve(\"upload \" + file.id + \" was canceled\");\n      });\n      _this4.onResumeAll(file.id, function () {\n        queuedRequest.abort();\n        if (file.error) {\n          socket.send('pause', {});\n        }\n        queuedRequest = _this4.requests.run(function () {\n          socket.send('resume', {});\n        });\n      });\n      _this4.onRetry(file.id, function () {\n        // Only do the retry if the upload is actually in progress;\n        // else we could try to send these messages when the upload is still queued.\n        // We may need a better check for this since the socket may also be closed\n        // for other reasons, like network failures.\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n      _this4.onRetryAll(file.id, function () {\n        if (socket.isOpen) {\n          socket.send('pause', {});\n          socket.send('resume', {});\n        }\n      });\n      socket.on('progress', function (progressData) {\n        return emitSocketProgress(_this4, progressData, file);\n      });\n      socket.on('error', function (errData) {\n        _this4.uppy.emit('upload-error', file, new Error(errData.error));\n        _this4.resetUploaderReferences(file.id);\n        queuedRequest.done();\n        reject(new Error(errData.error));\n      });\n      socket.on('success', function (data) {\n        var uploadResp = {\n          uploadURL: data.url\n        };\n        _this4.uppy.emit('upload-success', file, uploadResp);\n        _this4.resetUploaderReferences(file.id);\n        queuedRequest.done();\n        resolve();\n      });\n      var queuedRequest = _this4.requests.run(function () {\n        socket.open();\n        if (file.isPaused) {\n          socket.send('pause', {});\n        }\n        return function () {};\n      });\n    });\n  };\n  _proto.upload = function upload(fileIDs) {\n    var _this5 = this;\n    if (fileIDs.length === 0) return Promise.resolve();\n    var promises = fileIDs.map(function (id) {\n      var file = _this5.uppy.getFile(id);\n      if (file.isRemote) {\n        return _this5.uploadRemote(file);\n      }\n      return _this5.uploadFile(file);\n    });\n    return Promise.all(promises);\n  };\n  _proto.onFileRemove = function onFileRemove(fileID, cb) {\n    this.uploaderEvents[fileID].on('file-removed', function (file) {\n      if (fileID === file.id) cb(file.id);\n    });\n  };\n  _proto.onFilePause = function onFilePause(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-pause', function (targetFileID, isPaused) {\n      if (fileID === targetFileID) {\n        // const isPaused = this.uppy.pauseResume(fileID)\n        cb(isPaused);\n      }\n    });\n  };\n  _proto.onRetry = function onRetry(fileID, cb) {\n    this.uploaderEvents[fileID].on('upload-retry', function (targetFileID) {\n      if (fileID === targetFileID) {\n        cb();\n      }\n    });\n  };\n  _proto.onRetryAll = function onRetryAll(fileID, cb) {\n    var _this6 = this;\n    this.uploaderEvents[fileID].on('retry-all', function (filesToRetry) {\n      if (!_this6.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto.onPauseAll = function onPauseAll(fileID, cb) {\n    var _this7 = this;\n    this.uploaderEvents[fileID].on('pause-all', function () {\n      if (!_this7.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto.onCancelAll = function onCancelAll(fileID, cb) {\n    var _this8 = this;\n    this.uploaderEvents[fileID].on('cancel-all', function () {\n      if (!_this8.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto.onResumeAll = function onResumeAll(fileID, cb) {\n    var _this9 = this;\n    this.uploaderEvents[fileID].on('resume-all', function () {\n      if (!_this9.uppy.getFile(fileID)) return;\n      cb();\n    });\n  };\n  _proto.install = function install() {\n    var _this$uppy$getState = this.uppy.getState(),\n      capabilities = _this$uppy$getState.capabilities;\n    this.uppy.setState({\n      capabilities: _extends({}, capabilities, {\n        resumableUploads: true\n      })\n    });\n    this.uppy.addUploader(this.upload);\n  };\n  _proto.uninstall = function uninstall() {\n    var _this$uppy$getState2 = this.uppy.getState(),\n      capabilities = _this$uppy$getState2.capabilities;\n    this.uppy.setState({\n      capabilities: _extends({}, capabilities, {\n        resumableUploads: false\n      })\n    });\n    this.uppy.removeUploader(this.upload);\n  };\n  return AwsS3Multipart;\n}(Plugin), _class.VERSION = \"1.8.18\", _temp);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}