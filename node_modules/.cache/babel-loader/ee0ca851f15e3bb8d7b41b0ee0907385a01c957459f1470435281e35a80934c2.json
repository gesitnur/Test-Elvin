{"ast":null,"code":"function _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nimport Emitter from 'component-emitter';\nimport { io } from 'socket.io-client';\nimport has from '@uppy/utils/lib/hasProperty';\nimport NetworkError from '@uppy/utils/lib/NetworkError';\nimport fetchWithNetworkError from '@uppy/utils/lib/fetchWithNetworkError';\nimport parseUrl from './parseUrl.js';\nconst ASSEMBLY_UPLOADING = 'ASSEMBLY_UPLOADING';\nconst ASSEMBLY_EXECUTING = 'ASSEMBLY_EXECUTING';\nconst ASSEMBLY_COMPLETED = 'ASSEMBLY_COMPLETED';\nconst statusOrder = [ASSEMBLY_UPLOADING, ASSEMBLY_EXECUTING, ASSEMBLY_COMPLETED];\n/**\n * Check that an assembly status is equal to or larger than some desired status.\n * It checks for things that are larger so that a comparison like this works,\n * when the old assembly status is UPLOADING but the new is FINISHED:\n *\n * !isStatus(oldStatus, ASSEMBLY_EXECUTING) && isStatus(newState, ASSEMBLY_EXECUTING)\n *\n * …so that we can emit the 'executing' event even if the execution step was so\n * fast that we missed it.\n */\n\nfunction isStatus(status, test) {\n  return statusOrder.indexOf(status) >= statusOrder.indexOf(test);\n}\nvar _rateLimitedQueue = /*#__PURE__*/_classPrivateFieldLooseKey(\"rateLimitedQueue\");\nvar _fetchWithNetworkError = /*#__PURE__*/_classPrivateFieldLooseKey(\"fetchWithNetworkError\");\nvar _previousFetchStatusStillPending = /*#__PURE__*/_classPrivateFieldLooseKey(\"previousFetchStatusStillPending\");\nvar _onFinished = /*#__PURE__*/_classPrivateFieldLooseKey(\"onFinished\");\nvar _connectSocket = /*#__PURE__*/_classPrivateFieldLooseKey(\"connectSocket\");\nvar _onError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onError\");\nvar _beginPolling = /*#__PURE__*/_classPrivateFieldLooseKey(\"beginPolling\");\nvar _fetchStatus = /*#__PURE__*/_classPrivateFieldLooseKey(\"fetchStatus\");\nvar _diffStatus = /*#__PURE__*/_classPrivateFieldLooseKey(\"diffStatus\");\nclass TransloaditAssembly extends Emitter {\n  constructor(assembly, rateLimitedQueue) {\n    super(); // The current assembly status.\n\n    Object.defineProperty(this, _diffStatus, {\n      value: _diffStatus2\n    });\n    Object.defineProperty(this, _fetchStatus, {\n      value: _fetchStatus2\n    });\n    Object.defineProperty(this, _beginPolling, {\n      value: _beginPolling2\n    });\n    Object.defineProperty(this, _onError, {\n      value: _onError2\n    });\n    Object.defineProperty(this, _connectSocket, {\n      value: _connectSocket2\n    });\n    Object.defineProperty(this, _onFinished, {\n      value: _onFinished2\n    });\n    Object.defineProperty(this, _rateLimitedQueue, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _fetchWithNetworkError, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _previousFetchStatusStillPending, {\n      writable: true,\n      value: false\n    });\n    this.status = assembly; // The socket.io connection.\n\n    this.socket = null; // The interval timer for full status updates.\n\n    this.pollInterval = null; // Whether this assembly has been closed (finished or errored)\n\n    this.closed = false;\n    _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue] = rateLimitedQueue;\n    _classPrivateFieldLooseBase(this, _fetchWithNetworkError)[_fetchWithNetworkError] = rateLimitedQueue.wrapPromiseFunction(fetchWithNetworkError);\n  }\n  connect() {\n    _classPrivateFieldLooseBase(this, _connectSocket)[_connectSocket]();\n    _classPrivateFieldLooseBase(this, _beginPolling)[_beginPolling]();\n  }\n  update() {\n    return _classPrivateFieldLooseBase(this, _fetchStatus)[_fetchStatus]({\n      diff: true\n    });\n  }\n  /**\n   * Update this assembly's status with a full new object. Events will be\n   * emitted for status changes, new files, and new results.\n   *\n   * @param {object} next The new assembly status object.\n   */\n\n  updateStatus(next) {\n    _classPrivateFieldLooseBase(this, _diffStatus)[_diffStatus](this.status, next);\n    this.status = next;\n  }\n  /**\n   * Diff two assembly statuses, and emit the events necessary to go from `prev`\n   * to `next`.\n   *\n   * @param {object} prev The previous assembly status.\n   * @param {object} next The new assembly status.\n   */\n\n  /**\n   * Stop updating this assembly.\n   */\n  close() {\n    this.closed = true;\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n    clearInterval(this.pollInterval);\n    this.pollInterval = null;\n  }\n}\nfunction _onFinished2() {\n  this.emit('finished');\n  this.close();\n}\nfunction _connectSocket2() {\n  const parsed = parseUrl(this.status.websocket_url);\n  const socket = io(parsed.origin, {\n    transports: ['websocket'],\n    path: parsed.pathname\n  });\n  socket.on('connect', () => {\n    socket.emit('assembly_connect', {\n      id: this.status.assembly_id\n    });\n    this.emit('connect');\n  });\n  socket.on('connect_error', () => {\n    socket.disconnect();\n    this.socket = null;\n  });\n  socket.on('assembly_finished', () => {\n    _classPrivateFieldLooseBase(this, _onFinished)[_onFinished]();\n  });\n  socket.on('assembly_upload_finished', file => {\n    this.emit('upload', file);\n    this.status.uploads.push(file);\n  });\n  socket.on('assembly_uploading_finished', () => {\n    this.emit('executing');\n  });\n  socket.on('assembly_upload_meta_data_extracted', () => {\n    this.emit('metadata');\n    _classPrivateFieldLooseBase(this, _fetchStatus)[_fetchStatus]({\n      diff: false\n    });\n  });\n  socket.on('assembly_result_finished', (stepName, result) => {\n    this.emit('result', stepName, result);\n    if (!this.status.results[stepName]) {\n      this.status.results[stepName] = [];\n    }\n    this.status.results[stepName].push(result);\n  });\n  socket.on('assembly_error', err => {\n    _classPrivateFieldLooseBase(this, _onError)[_onError](err); // Refetch for updated status code\n\n    _classPrivateFieldLooseBase(this, _fetchStatus)[_fetchStatus]({\n      diff: false\n    });\n  });\n  this.socket = socket;\n}\nfunction _onError2(err) {\n  this.emit('error', Object.assign(new Error(err.message), err));\n  this.close();\n}\nfunction _beginPolling2() {\n  this.pollInterval = setInterval(() => {\n    if (!this.socket || !this.socket.connected) {\n      _classPrivateFieldLooseBase(this, _fetchStatus)[_fetchStatus]();\n    }\n  }, 2000);\n}\nasync function _fetchStatus2(_temp) {\n  let _ref = _temp === void 0 ? {} : _temp,\n    _ref$diff = _ref.diff,\n    diff = _ref$diff === void 0 ? true : _ref$diff;\n  if (this.closed || _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue].isPaused || _classPrivateFieldLooseBase(this, _previousFetchStatusStillPending)[_previousFetchStatusStillPending]) return;\n  try {\n    _classPrivateFieldLooseBase(this, _previousFetchStatusStillPending)[_previousFetchStatusStillPending] = true;\n    const response = await _classPrivateFieldLooseBase(this, _fetchWithNetworkError)[_fetchWithNetworkError](this.status.assembly_ssl_url);\n    _classPrivateFieldLooseBase(this, _previousFetchStatusStillPending)[_previousFetchStatusStillPending] = false;\n    if (this.closed) return;\n    if (response.status === 429) {\n      _classPrivateFieldLooseBase(this, _rateLimitedQueue)[_rateLimitedQueue].rateLimit(2000);\n      return;\n    }\n    if (!response.ok) {\n      _classPrivateFieldLooseBase(this, _onError)[_onError](new NetworkError(response.statusText));\n      return;\n    }\n    const status = await response.json(); // Avoid updating if we closed during this request's lifetime.\n\n    if (this.closed) return;\n    this.emit('status', status);\n    if (diff) {\n      this.updateStatus(status);\n    } else {\n      this.status = status;\n    }\n  } catch (err) {\n    _classPrivateFieldLooseBase(this, _onError)[_onError](err);\n  }\n}\nfunction _diffStatus2(prev, next) {\n  const prevStatus = prev.ok;\n  const nextStatus = next.ok;\n  if (next.error && !prev.error) {\n    return _classPrivateFieldLooseBase(this, _onError)[_onError](next);\n  } // Desired emit order:\n  //  - executing\n  //  - (n × upload)\n  //  - metadata\n  //  - (m × result)\n  //  - finished\n  // The below checks run in this order, that way even if we jump from\n  // UPLOADING straight to FINISHED all the events are emitted as expected.\n\n  const nowExecuting = isStatus(nextStatus, ASSEMBLY_EXECUTING) && !isStatus(prevStatus, ASSEMBLY_EXECUTING);\n  if (nowExecuting) {\n    // Without WebSockets, this is our only way to tell if uploading finished.\n    // Hence, we emit this just before the 'upload's and before the 'metadata'\n    // event for the most intuitive ordering, corresponding to the _usual_\n    // ordering (if not guaranteed) that you'd get on the WebSocket.\n    this.emit('executing');\n  } // Find new uploaded files.\n\n  Object.keys(next.uploads).filter(upload => !has(prev.uploads, upload)).forEach(upload => {\n    this.emit('upload', next.uploads[upload]);\n  });\n  if (nowExecuting) {\n    this.emit('metadata');\n  } // Find new results.\n\n  Object.keys(next.results).forEach(stepName => {\n    const nextResults = next.results[stepName];\n    const prevResults = prev.results[stepName];\n    nextResults.filter(n => !prevResults || !prevResults.some(p => p.id === n.id)).forEach(result => {\n      this.emit('result', stepName, result);\n    });\n  });\n  if (isStatus(nextStatus, ASSEMBLY_COMPLETED) && !isStatus(prevStatus, ASSEMBLY_COMPLETED)) {\n    this.emit('finished');\n  }\n  return undefined;\n}\nexport default TransloaditAssembly;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}